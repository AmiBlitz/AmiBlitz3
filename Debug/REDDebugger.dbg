00000008 <REDDebugger.ab3@0> 
00000014 <REDDebugger.ab3@57> optimize 5 ; don't use fpu because all calc must in FFP!!!!
00000014 <error.include.ab3@1> XINCLUDE "error.include.ab3"
0000004C <error.include.ab3@62> XINCLUDE "error.include.ab3"
00000074 <error.include.ab3@63> XINCLUDE "error.include.ab3"
0000009C <error.include.ab3@64> XINCLUDE "error.include.ab3"
000000C4 <error.include.ab3@65> XINCLUDE "error.include.ab3"
000000CA <error.include.ab3@66> XINCLUDE "error.include.ab3"
000000FE <error.include.ab3@67> XINCLUDE "error.include.ab3"
00000132 <error.include.ab3@68> XINCLUDE "error.include.ab3"
00000166 <error.include.ab3@69> XINCLUDE "error.include.ab3"
00000182 <error.include.ab3@73> XINCLUDE "error.include.ab3"
00000190 <error.include.ab3@104> XINCLUDE "error.include.ab3"
000001D2 <error.include.ab3@124> XINCLUDE "error.include.ab3"
00000256 <error.include.ab3@126> XINCLUDE "error.include.ab3"
000002C2 <error.include.ab3@127> XINCLUDE "error.include.ab3"
000002DC <error.include.ab3@129> XINCLUDE "error.include.ab3"
00000314 <error.include.ab3@130> XINCLUDE "error.include.ab3"
00000374 <error.include.ab3@131> XINCLUDE "error.include.ab3"
00000382 <error.include.ab3@133> XINCLUDE "error.include.ab3"
00000390 <error.include.ab3@134> XINCLUDE "error.include.ab3"
0000039E <error.include.ab3@135> XINCLUDE "error.include.ab3"
000003AC <error.include.ab3@136> XINCLUDE "error.include.ab3"
000003D4 <error.include.ab3@137> XINCLUDE "error.include.ab3"
000003E2 <error.include.ab3@138> XINCLUDE "error.include.ab3"
000003EA <error.include.ab3@139> XINCLUDE "error.include.ab3"
0000041C <error.include.ab3@141> XINCLUDE "error.include.ab3"
00000436 <error.include.ab3@146> XINCLUDE "error.include.ab3"
0000046E <error.include.ab3@147> XINCLUDE "error.include.ab3"
00000474 <error.include.ab3@148> XINCLUDE "error.include.ab3"
000004B8 <error.include.ab3@149> XINCLUDE "error.include.ab3"
00000500 <error.include.ab3@150> XINCLUDE "error.include.ab3"
0000050A <error.include.ab3@154> XINCLUDE "error.include.ab3"
00000524 <error.include.ab3@156> XINCLUDE "error.include.ab3"
0000056E <error.include.ab3@195> XINCLUDE "error.include.ab3"
00000576 <error.include.ab3@197> XINCLUDE "error.include.ab3"
000005E2 <error.include.ab3@198> XINCLUDE "error.include.ab3"
00000604 <error.include.ab3@199> XINCLUDE "error.include.ab3"
00000664 <error.include.ab3@200> XINCLUDE "error.include.ab3"
00000672 <error.include.ab3@202> XINCLUDE "error.include.ab3"
00000680 <error.include.ab3@203> XINCLUDE "error.include.ab3"
0000068E <error.include.ab3@204> XINCLUDE "error.include.ab3"
0000069C <error.include.ab3@205> XINCLUDE "error.include.ab3"
000006FC <error.include.ab3@206> XINCLUDE "error.include.ab3"
0000070A <error.include.ab3@207> XINCLUDE "error.include.ab3"
00000740 <error.include.ab3@210> XINCLUDE "error.include.ab3"
0000074A <error.include.ab3@214> XINCLUDE "error.include.ab3"
00000766 <error.include.ab3@215> XINCLUDE "error.include.ab3"
000007A0 <error.include.ab3@231> XINCLUDE "error.include.ab3"
0000080C <error.include.ab3@234> XINCLUDE "error.include.ab3"
00000826 <error.include.ab3@235> XINCLUDE "error.include.ab3"
00000886 <error.include.ab3@236> XINCLUDE "error.include.ab3"
00000894 <error.include.ab3@237> XINCLUDE "error.include.ab3"
000008A2 <error.include.ab3@238> XINCLUDE "error.include.ab3"
000008B0 <error.include.ab3@239> XINCLUDE "error.include.ab3"
000008BE <error.include.ab3@240> XINCLUDE "error.include.ab3"
000008E6 <error.include.ab3@241> XINCLUDE "error.include.ab3"
000008F4 <error.include.ab3@242> XINCLUDE "error.include.ab3"
000008FC <error.include.ab3@243> XINCLUDE "error.include.ab3"
0000092E <error.include.ab3@245> XINCLUDE "error.include.ab3"
00000948 <error.include.ab3@249> XINCLUDE "error.include.ab3"
0000098C <error.include.ab3@250> XINCLUDE "error.include.ab3"
000009A6 <error.include.ab3@252> XINCLUDE "error.include.ab3"
000009A6 <REDDebugger.ab3@60> XINCLUDE "error.include.ab3"
000009A6 <dos.include.ab3@1> XINCLUDE "dos.include.ab3"
000009A6 <multilist.include.ab3@1> XINCLUDE "dos.include.ab3"
000009A6 <strptr.include.ab3@1> XINCLUDE "dos.include.ab3"
000009A6 <useful.include.ab3@1> XINCLUDE "dos.include.ab3"
000009A6 <strptr.include.ab3@37> XINCLUDE "dos.include.ab3"
000009C0 <strptr.include.ab3@96> XINCLUDE "dos.include.ab3"
000009CA <strptr.include.ab3@97> XINCLUDE "dos.include.ab3"
00000A12 <strptr.include.ab3@98> XINCLUDE "dos.include.ab3"
00000A16 <strptr.include.ab3@100> XINCLUDE "dos.include.ab3"
00000A30 <strptr.include.ab3@302> XINCLUDE "dos.include.ab3"
00000A3A <strptr.include.ab3@303> XINCLUDE "dos.include.ab3"
00000A48 <strptr.include.ab3@304> XINCLUDE "dos.include.ab3"
00000A7A <strptr.include.ab3@305> XINCLUDE "dos.include.ab3"
00000A98 <strptr.include.ab3@307> XINCLUDE "dos.include.ab3"
00000AA2 <strptr.include.ab3@308> XINCLUDE "dos.include.ab3"
00000AA2 <multilist.include.ab3@44> XINCLUDE "dos.include.ab3"
00000AB8 <multilist.include.ab3@61> XINCLUDE "dos.include.ab3"
00000AD2 <multilist.include.ab3@406> XINCLUDE "dos.include.ab3"
00000ADC <multilist.include.ab3@407> XINCLUDE "dos.include.ab3"
00000AFE <multilist.include.ab3@408> XINCLUDE "dos.include.ab3"
00000B22 <multilist.include.ab3@409> XINCLUDE "dos.include.ab3"
00000B34 <multilist.include.ab3@410> XINCLUDE "dos.include.ab3"
00000B4C <multilist.include.ab3@411> XINCLUDE "dos.include.ab3"
00000B60 <multilist.include.ab3@412> XINCLUDE "dos.include.ab3"
00000B72 <multilist.include.ab3@415> XINCLUDE "dos.include.ab3"
00000B82 <multilist.include.ab3@416> XINCLUDE "dos.include.ab3"
00000B88 <multilist.include.ab3@417> XINCLUDE "dos.include.ab3"
00000B98 <multilist.include.ab3@418> XINCLUDE "dos.include.ab3"
00000BA8 <multilist.include.ab3@419> XINCLUDE "dos.include.ab3"
00000BC2 <multilist.include.ab3@420> XINCLUDE "dos.include.ab3"
00000BC6 <multilist.include.ab3@422> XINCLUDE "dos.include.ab3"
00000BE0 <multilist.include.ab3@585> XINCLUDE "dos.include.ab3"
00000C10 <multilist.include.ab3@586> XINCLUDE "dos.include.ab3"
00000C1A <multilist.include.ab3@588> XINCLUDE "dos.include.ab3"
00000C24 <multilist.include.ab3@589> XINCLUDE "dos.include.ab3"
00000C46 <multilist.include.ab3@590> XINCLUDE "dos.include.ab3"
00000C6A <multilist.include.ab3@591> XINCLUDE "dos.include.ab3"
00000C7C <multilist.include.ab3@592> XINCLUDE "dos.include.ab3"
00000C94 <multilist.include.ab3@593> XINCLUDE "dos.include.ab3"
00000CA8 <multilist.include.ab3@594> XINCLUDE "dos.include.ab3"
00000CBA <multilist.include.ab3@597> XINCLUDE "dos.include.ab3"
00000CCA <multilist.include.ab3@598> XINCLUDE "dos.include.ab3"
00000CD0 <multilist.include.ab3@599> XINCLUDE "dos.include.ab3"
00000CE0 <multilist.include.ab3@600> XINCLUDE "dos.include.ab3"
00000CF0 <multilist.include.ab3@601> XINCLUDE "dos.include.ab3"
00000D0A <multilist.include.ab3@602> XINCLUDE "dos.include.ab3"
00000D10 <multilist.include.ab3@603> XINCLUDE "dos.include.ab3"
00000D16 <multilist.include.ab3@604> XINCLUDE "dos.include.ab3"
00000D1A <multilist.include.ab3@605> XINCLUDE "dos.include.ab3"
00000D34 <multilist.include.ab3@713> XINCLUDE "dos.include.ab3"
00000D3C <multilist.include.ab3@714> XINCLUDE "dos.include.ab3"
00000D46 <multilist.include.ab3@715> XINCLUDE "dos.include.ab3"
00000D5C <multilist.include.ab3@716> XINCLUDE "dos.include.ab3"
00000D70 <multilist.include.ab3@717> XINCLUDE "dos.include.ab3"
00000D94 <multilist.include.ab3@718> XINCLUDE "dos.include.ab3"
00000DA2 <multilist.include.ab3@721> XINCLUDE "dos.include.ab3"
00000DAC <multilist.include.ab3@722> XINCLUDE "dos.include.ab3"
00000DB2 <multilist.include.ab3@723> XINCLUDE "dos.include.ab3"
00000DBC <multilist.include.ab3@724> XINCLUDE "dos.include.ab3"
00000DC2 <multilist.include.ab3@725> XINCLUDE "dos.include.ab3"
00000DE0 <multilist.include.ab3@742> XINCLUDE "dos.include.ab3"
00000DE8 <multilist.include.ab3@743> XINCLUDE "dos.include.ab3"
00000DF2 <multilist.include.ab3@744> XINCLUDE "dos.include.ab3"
00000E10 <multilist.include.ab3@745> XINCLUDE "dos.include.ab3"
00000E26 <multilist.include.ab3@746> XINCLUDE "dos.include.ab3"
00000E3A <multilist.include.ab3@747> XINCLUDE "dos.include.ab3"
00000E6E <multilist.include.ab3@748> XINCLUDE "dos.include.ab3"
00000E7C <multilist.include.ab3@751> XINCLUDE "dos.include.ab3"
00000E86 <multilist.include.ab3@752> XINCLUDE "dos.include.ab3"
00000E8C <multilist.include.ab3@753> XINCLUDE "dos.include.ab3"
00000E96 <multilist.include.ab3@754> XINCLUDE "dos.include.ab3"
00000E9A <multilist.include.ab3@756> XINCLUDE "dos.include.ab3"
00000EA0 <multilist.include.ab3@757> XINCLUDE "dos.include.ab3"
00000EBA <multilist.include.ab3@795> XINCLUDE "dos.include.ab3"
00000EC4 <multilist.include.ab3@796> XINCLUDE "dos.include.ab3"
00000ECE <multilist.include.ab3@797> XINCLUDE "dos.include.ab3"
00000EE4 <multilist.include.ab3@798> XINCLUDE "dos.include.ab3"
00000EF4 <multilist.include.ab3@799> XINCLUDE "dos.include.ab3"
00000EFE <multilist.include.ab3@801> XINCLUDE "dos.include.ab3"
00000F04 <multilist.include.ab3@802> XINCLUDE "dos.include.ab3"
00000F08 <multilist.include.ab3@803> XINCLUDE "dos.include.ab3"
00000F2A <multilist.include.ab3@821> XINCLUDE "dos.include.ab3"
00000F32 <multilist.include.ab3@822> XINCLUDE "dos.include.ab3"
00000F4C <multilist.include.ab3@823> XINCLUDE "dos.include.ab3"
00000F56 <multilist.include.ab3@824> XINCLUDE "dos.include.ab3"
00000F6C <multilist.include.ab3@825> XINCLUDE "dos.include.ab3"
00000F80 <multilist.include.ab3@826> XINCLUDE "dos.include.ab3"
00000FD6 <multilist.include.ab3@827> XINCLUDE "dos.include.ab3"
00001010 <multilist.include.ab3@828> XINCLUDE "dos.include.ab3"
00001022 <multilist.include.ab3@829> XINCLUDE "dos.include.ab3"
00001044 <multilist.include.ab3@830> XINCLUDE "dos.include.ab3"
0000104A <multilist.include.ab3@831> XINCLUDE "dos.include.ab3"
000010A0 <multilist.include.ab3@832> XINCLUDE "dos.include.ab3"
000010DA <multilist.include.ab3@833> XINCLUDE "dos.include.ab3"
000010E0 <multilist.include.ab3@835> XINCLUDE "dos.include.ab3"
0000111A <multilist.include.ab3@836> XINCLUDE "dos.include.ab3"
00001154 <multilist.include.ab3@837> XINCLUDE "dos.include.ab3"
00001166 <multilist.include.ab3@839> XINCLUDE "dos.include.ab3"
00001170 <multilist.include.ab3@840> XINCLUDE "dos.include.ab3"
00001176 <multilist.include.ab3@841> XINCLUDE "dos.include.ab3"
00001180 <multilist.include.ab3@842> XINCLUDE "dos.include.ab3"
00001194 <multilist.include.ab3@843> XINCLUDE "dos.include.ab3"
000011DA <multilist.include.ab3@870> XINCLUDE "dos.include.ab3"
000011E2 <multilist.include.ab3@871> XINCLUDE "dos.include.ab3"
00001200 <multilist.include.ab3@872> XINCLUDE "dos.include.ab3"
0000122C <multilist.include.ab3@873> XINCLUDE "dos.include.ab3"
0000124A <multilist.include.ab3@874> XINCLUDE "dos.include.ab3"
00001264 <multilist.include.ab3@875> XINCLUDE "dos.include.ab3"
0000127E <multilist.include.ab3@876> XINCLUDE "dos.include.ab3"
00001300 <multilist.include.ab3@877> XINCLUDE "dos.include.ab3"
00001314 <multilist.include.ab3@879> XINCLUDE "dos.include.ab3"
0000132C <multilist.include.ab3@880> XINCLUDE "dos.include.ab3"
00001332 <multilist.include.ab3@881> XINCLUDE "dos.include.ab3"
0000134A <multilist.include.ab3@882> XINCLUDE "dos.include.ab3"
00001360 <multilist.include.ab3@884> XINCLUDE "dos.include.ab3"
0000137A <multilist.include.ab3@886> XINCLUDE "dos.include.ab3"
0000138E <multilist.include.ab3@887> XINCLUDE "dos.include.ab3"
0000139C <multilist.include.ab3@888> XINCLUDE "dos.include.ab3"
000013F2 <multilist.include.ab3@889> XINCLUDE "dos.include.ab3"
00001428 <multilist.include.ab3@890> XINCLUDE "dos.include.ab3"
00001458 <multilist.include.ab3@891> XINCLUDE "dos.include.ab3"
000014E0 <multilist.include.ab3@893> XINCLUDE "dos.include.ab3"
000014E6 <multilist.include.ab3@894> XINCLUDE "dos.include.ab3"
000014F4 <multilist.include.ab3@895> XINCLUDE "dos.include.ab3"
0000154A <multilist.include.ab3@896> XINCLUDE "dos.include.ab3"
00001580 <multilist.include.ab3@897> XINCLUDE "dos.include.ab3"
000015B0 <multilist.include.ab3@898> XINCLUDE "dos.include.ab3"
000015B6 <multilist.include.ab3@901> XINCLUDE "dos.include.ab3"
000015D0 <multilist.include.ab3@902> XINCLUDE "dos.include.ab3"
000015DE <multilist.include.ab3@903> XINCLUDE "dos.include.ab3"
00001618 <multilist.include.ab3@904> XINCLUDE "dos.include.ab3"
0000164E <multilist.include.ab3@905> XINCLUDE "dos.include.ab3"
0000167E <multilist.include.ab3@906> XINCLUDE "dos.include.ab3"
0000168C <multilist.include.ab3@909> XINCLUDE "dos.include.ab3"
00001696 <multilist.include.ab3@910> XINCLUDE "dos.include.ab3"
0000169C <multilist.include.ab3@911> XINCLUDE "dos.include.ab3"
000016A6 <multilist.include.ab3@912> XINCLUDE "dos.include.ab3"
000016BA <multilist.include.ab3@913> XINCLUDE "dos.include.ab3"
000016BA <dos.include.ab3@57> XINCLUDE "dos.include.ab3"
000016BA <wbstart.include.ab3@1> XINCLUDE "dos.include.ab3"
000016D0 <wbstart.include.ab3@58> XINCLUDE "dos.include.ab3"
000016DA <wbstart.include.ab3@59> XINCLUDE "dos.include.ab3"
000016F2 <wbstart.include.ab3@61> XINCLUDE "dos.include.ab3"
000016F4 <wbstart.include.ab3@63> XINCLUDE "dos.include.ab3"
00001722 <wbstart.include.ab3@64> XINCLUDE "dos.include.ab3"
00001722 <dos.include.ab3@59> XINCLUDE "dos.include.ab3"
00001738 <dos.include.ab3@61> XINCLUDE "dos.include.ab3"
00001740 <dos.include.ab3@79> XINCLUDE "dos.include.ab3"
00001748 <dos.include.ab3@80> XINCLUDE "dos.include.ab3"
00001770 <dos.include.ab3@81> XINCLUDE "dos.include.ab3"
00001778 <dos.include.ab3@82> XINCLUDE "dos.include.ab3"
000017A0 <dos.include.ab3@83> XINCLUDE "dos.include.ab3"
000017C8 <dos.include.ab3@84> XINCLUDE "dos.include.ab3"
000017F0 <dos.include.ab3@85> XINCLUDE "dos.include.ab3"
000017F8 <dos.include.ab3@86> XINCLUDE "dos.include.ab3"
00001800 <dos.include.ab3@87> XINCLUDE "dos.include.ab3"
00001808 <dos.include.ab3@88> XINCLUDE "dos.include.ab3"
00001810 <dos.include.ab3@89> XINCLUDE "dos.include.ab3"
00001818 <dos.include.ab3@90> XINCLUDE "dos.include.ab3"
00001820 <dos.include.ab3@91> XINCLUDE "dos.include.ab3"
00001828 <dos.include.ab3@92> XINCLUDE "dos.include.ab3"
00001830 <dos.include.ab3@93> XINCLUDE "dos.include.ab3"
00001838 <dos.include.ab3@94> XINCLUDE "dos.include.ab3"
00001858 <dos.include.ab3@95> XINCLUDE "dos.include.ab3"
00001860 <dos.include.ab3@96> XINCLUDE "dos.include.ab3"
00001868 <dos.include.ab3@97> XINCLUDE "dos.include.ab3"
00001890 <dos.include.ab3@99> XINCLUDE "dos.include.ab3"
000018A6 <dos.include.ab3@130> XINCLUDE "dos.include.ab3"
000018B2 <dos.include.ab3@131> XINCLUDE "dos.include.ab3"
000018B6 <dos.include.ab3@132> XINCLUDE "dos.include.ab3"
000018CC <dos.include.ab3@479> XINCLUDE "dos.include.ab3"
000018CE <dos.include.ab3@480> XINCLUDE "dos.include.ab3"
00001908 <dos.include.ab3@541> XINCLUDE "dos.include.ab3"
0000193C <dos.include.ab3@543> XINCLUDE "dos.include.ab3"
00001962 <dos.include.ab3@544> XINCLUDE "dos.include.ab3"
00001982 <dos.include.ab3@545> XINCLUDE "dos.include.ab3"
000019A2 <dos.include.ab3@546> XINCLUDE "dos.include.ab3"
000019CC <dos.include.ab3@705> XINCLUDE "dos.include.ab3"
00001A3C <dos.include.ab3@706> XINCLUDE "dos.include.ab3"
00001A66 <dos.include.ab3@707> XINCLUDE "dos.include.ab3"
00001A84 <dos.include.ab3@708> XINCLUDE "dos.include.ab3"
00001AAE <dos.include.ab3@743> XINCLUDE "dos.include.ab3"
00001ACE <dos.include.ab3@744> XINCLUDE "dos.include.ab3"
00001AFA <dos.include.ab3@745> XINCLUDE "dos.include.ab3"
00001B04 <dos.include.ab3@746> XINCLUDE "dos.include.ab3"
00001B1E <dos.include.ab3@747> XINCLUDE "dos.include.ab3"
00001B48 <dos.include.ab3@1171> XINCLUDE "dos.include.ab3"
00001B56 <dos.include.ab3@1173> XINCLUDE "dos.include.ab3"
00001C1C <dos.include.ab3@1174> XINCLUDE "dos.include.ab3"
00001C46 <dos.include.ab3@1175> XINCLUDE "dos.include.ab3"
00001C6E <dos.include.ab3@1177> XINCLUDE "dos.include.ab3"
00001C98 <dos.include.ab3@1178> XINCLUDE "dos.include.ab3"
00001CC2 <dos.include.ab3@1180> XINCLUDE "dos.include.ab3"
00001CE0 <dos.include.ab3@1181> XINCLUDE "dos.include.ab3"
00001CF6 <dos.include.ab3@1375> XINCLUDE "dos.include.ab3"
00001CFC <dos.include.ab3@1377> XINCLUDE "dos.include.ab3"
00001D06 <dos.include.ab3@1378> XINCLUDE "dos.include.ab3"
00001D10 <dos.include.ab3@1379> XINCLUDE "dos.include.ab3"
00001D2E <dos.include.ab3@1382> XINCLUDE "dos.include.ab3"
00001D34 <dos.include.ab3@1383> XINCLUDE "dos.include.ab3"
00001D3A <dos.include.ab3@1384> XINCLUDE "dos.include.ab3"
00001D4A <dos.include.ab3@1386> XINCLUDE "dos.include.ab3"
00001D50 <dos.include.ab3@1387> XINCLUDE "dos.include.ab3"
00001D58 <dos.include.ab3@1388> XINCLUDE "dos.include.ab3"
00001D80 <dos.include.ab3@1389> XINCLUDE "dos.include.ab3"
00001D8A <dos.include.ab3@1390> XINCLUDE "dos.include.ab3"
00001D94 <dos.include.ab3@1392> XINCLUDE "dos.include.ab3"
00001DA8 <dos.include.ab3@1393> XINCLUDE "dos.include.ab3"
00001DBE <dos.include.ab3@1498> XINCLUDE "dos.include.ab3"
00001DC4 <dos.include.ab3@1504> XINCLUDE "dos.include.ab3"
00001DE8 <dos.include.ab3@1505> XINCLUDE "dos.include.ab3"
00001E0C <dos.include.ab3@1506> XINCLUDE "dos.include.ab3"
00001E30 <dos.include.ab3@1507> XINCLUDE "dos.include.ab3"
00001E36 <dos.include.ab3@1508> XINCLUDE "dos.include.ab3"
00001E62 <dos.include.ab3@1509> XINCLUDE "dos.include.ab3"
00001E64 <dos.include.ab3@1510> XINCLUDE "dos.include.ab3"
00001E92 <dos.include.ab3@1511> XINCLUDE "dos.include.ab3"
00001EC0 <dos.include.ab3@2359> XINCLUDE "dos.include.ab3"
00001EDA <dos.include.ab3@2360> XINCLUDE "dos.include.ab3"
00001EF8 <dos.include.ab3@2361> XINCLUDE "dos.include.ab3"
00001F02 <dos.include.ab3@2362> XINCLUDE "dos.include.ab3"
00001F12 <dos.include.ab3@2363> XINCLUDE "dos.include.ab3"
00001F1A <dos.include.ab3@2364> XINCLUDE "dos.include.ab3"
00001F22 <dos.include.ab3@2366> XINCLUDE "dos.include.ab3"
00001F3C <dos.include.ab3@2367> XINCLUDE "dos.include.ab3"
00001F3C <REDDebugger.ab3@61> XINCLUDE "dos.include.ab3"
00001F3C <common.ab3@1> XINCLUDE "/Shared/common.ab3"
00001F64 <common.ab3@49> XINCLUDE "/Shared/common.ab3"
00001F6A <common.ab3@264> XINCLUDE "/Shared/common.ab3"
00001F6C <common.ab3@265> XINCLUDE "/Shared/common.ab3"
000020FC <common.ab3@266> XINCLUDE "/Shared/common.ab3"
00002100 <common.ab3@267> XINCLUDE "/Shared/common.ab3"
00002104 <common.ab3@269> XINCLUDE "/Shared/common.ab3"
00002108 <common.ab3@270> XINCLUDE "/Shared/common.ab3"
0000210C <common.ab3@272> XINCLUDE "/Shared/common.ab3"
00002110 <common.ab3@273> XINCLUDE "/Shared/common.ab3"
00002114 <common.ab3@274> XINCLUDE "/Shared/common.ab3"
00002118 <common.ab3@275> XINCLUDE "/Shared/common.ab3"
0000211C <common.ab3@276> XINCLUDE "/Shared/common.ab3"
00002120 <common.ab3@277> XINCLUDE "/Shared/common.ab3"
00002124 <common.ab3@278> XINCLUDE "/Shared/common.ab3"
00002128 <common.ab3@279> XINCLUDE "/Shared/common.ab3"
0000212C <common.ab3@280> XINCLUDE "/Shared/common.ab3"
00002130 <common.ab3@282> XINCLUDE "/Shared/common.ab3"
00002134 <common.ab3@284> XINCLUDE "/Shared/common.ab3"
00002138 <common.ab3@285> XINCLUDE "/Shared/common.ab3"
0000213C <common.ab3@286> XINCLUDE "/Shared/common.ab3"
00002140 <common.ab3@287> XINCLUDE "/Shared/common.ab3"
00002144 <common.ab3@288> XINCLUDE "/Shared/common.ab3"
00002148 <common.ab3@289> XINCLUDE "/Shared/common.ab3"
0000214C <common.ab3@290> XINCLUDE "/Shared/common.ab3"
00002150 <common.ab3@291> XINCLUDE "/Shared/common.ab3"
00002154 <common.ab3@292> XINCLUDE "/Shared/common.ab3"
00002158 <common.ab3@293> XINCLUDE "/Shared/common.ab3"
00002160 <common.ab3@296> XINCLUDE "/Shared/common.ab3"
00002164 <common.ab3@297> XINCLUDE "/Shared/common.ab3"
00002166 <common.ab3@298> XINCLUDE "/Shared/common.ab3"
0000216A <common.ab3@299> XINCLUDE "/Shared/common.ab3"
0000216C <common.ab3@300> XINCLUDE "/Shared/common.ab3"
00002170 <common.ab3@301> XINCLUDE "/Shared/common.ab3"
00002174 <common.ab3@302> XINCLUDE "/Shared/common.ab3"
00002178 <common.ab3@303> XINCLUDE "/Shared/common.ab3"
0000217C <common.ab3@304> XINCLUDE "/Shared/common.ab3"
00002180 <common.ab3@305> XINCLUDE "/Shared/common.ab3"
00002188 <common.ab3@306> XINCLUDE "/Shared/common.ab3"
00002190 <common.ab3@307> XINCLUDE "/Shared/common.ab3"
00002194 <common.ab3@308> XINCLUDE "/Shared/common.ab3"
00002198 <common.ab3@309> XINCLUDE "/Shared/common.ab3"
0000219C <common.ab3@310> XINCLUDE "/Shared/common.ab3"
0000219E <common.ab3@312> XINCLUDE "/Shared/common.ab3"
0000225E <common.ab3@313> XINCLUDE "/Shared/common.ab3"
000022A6 <common.ab3@314> XINCLUDE "/Shared/common.ab3"
000022AA <common.ab3@316> XINCLUDE "/Shared/common.ab3"
000022AC <common.ab3@317> XINCLUDE "/Shared/common.ab3"
000022B0 <common.ab3@318> XINCLUDE "/Shared/common.ab3"
000022B2 <common.ab3@319> XINCLUDE "/Shared/common.ab3"
000022B4 <common.ab3@320> XINCLUDE "/Shared/common.ab3"
000022B6 <common.ab3@321> XINCLUDE "/Shared/common.ab3"
000022B8 <common.ab3@322> XINCLUDE "/Shared/common.ab3"
000022BA <common.ab3@324> XINCLUDE "/Shared/common.ab3"
000022BC <common.ab3@325> XINCLUDE "/Shared/common.ab3"
000022BD <common.ab3@329> XINCLUDE "/Shared/common.ab3"
000022BE <common.ab3@331> XINCLUDE "/Shared/common.ab3"
000022C0 <common.ab3@332> XINCLUDE "/Shared/common.ab3"
000022C2 <common.ab3@333> XINCLUDE "/Shared/common.ab3"
000022C4 <common.ab3@335> XINCLUDE "/Shared/common.ab3"
000022C6 <common.ab3@338> XINCLUDE "/Shared/common.ab3"
000022C8 <common.ab3@340> XINCLUDE "/Shared/common.ab3"
000022CA <common.ab3@342> XINCLUDE "/Shared/common.ab3"
000022CE <common.ab3@344> XINCLUDE "/Shared/common.ab3"
000022D0 <common.ab3@346> XINCLUDE "/Shared/common.ab3"
000022D2 <common.ab3@347> XINCLUDE "/Shared/common.ab3"
000022D4 <common.ab3@349> XINCLUDE "/Shared/common.ab3"
000022D8 <common.ab3@351> XINCLUDE "/Shared/common.ab3"
000022DA <common.ab3@352> XINCLUDE "/Shared/common.ab3"
000022DC <common.ab3@353> XINCLUDE "/Shared/common.ab3"
000022E0 <common.ab3@356> XINCLUDE "/Shared/common.ab3"
000022E2 <common.ab3@357> XINCLUDE "/Shared/common.ab3"
000022E4 <common.ab3@358> XINCLUDE "/Shared/common.ab3"
000022E6 <common.ab3@359> XINCLUDE "/Shared/common.ab3"
000022E8 <common.ab3@361> XINCLUDE "/Shared/common.ab3"
000022EA <common.ab3@362> XINCLUDE "/Shared/common.ab3"
000022EE <common.ab3@364> XINCLUDE "/Shared/common.ab3"
000022F0 <common.ab3@365> XINCLUDE "/Shared/common.ab3"
000022F2 <common.ab3@366> XINCLUDE "/Shared/common.ab3"
000022F4 <common.ab3@370> XINCLUDE "/Shared/common.ab3"
000022F6 <common.ab3@371> XINCLUDE "/Shared/common.ab3"
000022FA <common.ab3@372> XINCLUDE "/Shared/common.ab3"
000022FE <common.ab3@377> XINCLUDE "/Shared/common.ab3"
00002300 <common.ab3@383> XINCLUDE "/Shared/common.ab3"
00002302 <common.ab3@384> XINCLUDE "/Shared/common.ab3"
00002304 <common.ab3@385> XINCLUDE "/Shared/common.ab3"
00002308 <common.ab3@386> XINCLUDE "/Shared/common.ab3"
0000230A <common.ab3@387> XINCLUDE "/Shared/common.ab3"
0000230C <common.ab3@388> XINCLUDE "/Shared/common.ab3"
0000230E <common.ab3@389> XINCLUDE "/Shared/common.ab3"
00002310 <common.ab3@390> XINCLUDE "/Shared/common.ab3"
00002312 <common.ab3@392> XINCLUDE "/Shared/common.ab3"
00002314 <common.ab3@394> XINCLUDE "/Shared/common.ab3"
00002316 <common.ab3@396> XINCLUDE "/Shared/common.ab3"
0000231A <common.ab3@397> XINCLUDE "/Shared/common.ab3"
0000231C <common.ab3@398> XINCLUDE "/Shared/common.ab3"
0000234A <common.ab3@399> XINCLUDE "/Shared/common.ab3"
00002354 <common.ab3@400> XINCLUDE "/Shared/common.ab3"
00002358 <common.ab3@401> XINCLUDE "/Shared/common.ab3"
0000235A <common.ab3@403> XINCLUDE "/Shared/common.ab3"
0000235C <common.ab3@404> XINCLUDE "/Shared/common.ab3"
00002360 <common.ab3@405> XINCLUDE "/Shared/common.ab3"
00002364 <common.ab3@406> XINCLUDE "/Shared/common.ab3"
0000236D <common.ab3@407> XINCLUDE "/Shared/common.ab3"
00002370 <common.ab3@408> XINCLUDE "/Shared/common.ab3"
0000239D <common.ab3@409> XINCLUDE "/Shared/common.ab3"
000023DD <common.ab3@410> XINCLUDE "/Shared/common.ab3"
000023E9 <common.ab3@411> XINCLUDE "/Shared/common.ab3"
00002439 <common.ab3@412> XINCLUDE "/Shared/common.ab3"
00002445 <common.ab3@413> XINCLUDE "/Shared/common.ab3"
00002495 <common.ab3@414> XINCLUDE "/Shared/common.ab3"
00002591 <common.ab3@415> XINCLUDE "/Shared/common.ab3"
00002593 <common.ab3@416> XINCLUDE "/Shared/common.ab3"
00002653 <common.ab3@417> XINCLUDE "/Shared/common.ab3"
00002693 <common.ab3@418> XINCLUDE "/Shared/common.ab3"
00002695 <common.ab3@419> XINCLUDE "/Shared/common.ab3"
00002696 <common.ab3@420> XINCLUDE "/Shared/common.ab3"
0000269A <common.ab3@423> XINCLUDE "/Shared/common.ab3"
0000269E <common.ab3@425> XINCLUDE "/Shared/common.ab3"
000026A2 <common.ab3@426> XINCLUDE "/Shared/common.ab3"
000026A6 <common.ab3@427> XINCLUDE "/Shared/common.ab3"
000026AA <common.ab3@429> XINCLUDE "/Shared/common.ab3"
000026AE <common.ab3@431> XINCLUDE "/Shared/common.ab3"
000026B2 <common.ab3@432> XINCLUDE "/Shared/common.ab3"
000026B6 <common.ab3@433> XINCLUDE "/Shared/common.ab3"
000026BA <common.ab3@434> XINCLUDE "/Shared/common.ab3"
000026BE <common.ab3@435> XINCLUDE "/Shared/common.ab3"
000026C2 <common.ab3@436> XINCLUDE "/Shared/common.ab3"
000026C6 <common.ab3@437> XINCLUDE "/Shared/common.ab3"
000026CA <common.ab3@438> XINCLUDE "/Shared/common.ab3"
000026CE <common.ab3@440> XINCLUDE "/Shared/common.ab3"
000026D2 <common.ab3@442> XINCLUDE "/Shared/common.ab3"
000026D6 <common.ab3@444> XINCLUDE "/Shared/common.ab3"
000026DA <common.ab3@446> XINCLUDE "/Shared/common.ab3"
000026DE <common.ab3@447> XINCLUDE "/Shared/common.ab3"
000026E8 <common.ab3@448> XINCLUDE "/Shared/common.ab3"
000026EC <common.ab3@449> XINCLUDE "/Shared/common.ab3"
000026F0 <common.ab3@452> XINCLUDE "/Shared/common.ab3"
000026F2 <common.ab3@453> XINCLUDE "/Shared/common.ab3"
000026F4 <common.ab3@454> XINCLUDE "/Shared/common.ab3"
00002712 <common.ab3@455> XINCLUDE "/Shared/common.ab3"
00002716 <common.ab3@456> XINCLUDE "/Shared/common.ab3"
00002718 <common.ab3@458> XINCLUDE "/Shared/common.ab3"
0000271C <common.ab3@459> XINCLUDE "/Shared/common.ab3"
00002750 <common.ab3@460> XINCLUDE "/Shared/common.ab3"
00002754 <common.ab3@461> XINCLUDE "/Shared/common.ab3"
00002762 <common.ab3@463> XINCLUDE "/Shared/common.ab3"
00002774 <common.ab3@464> XINCLUDE "/Shared/common.ab3"
00002776 <common.ab3@465> XINCLUDE "/Shared/common.ab3"
0000278A <common.ab3@466> XINCLUDE "/Shared/common.ab3"
000027A0 <common.ab3@467> XINCLUDE "/Shared/common.ab3"
000027B6 <common.ab3@468> XINCLUDE "/Shared/common.ab3"
000027CC <common.ab3@469> XINCLUDE "/Shared/common.ab3"
000027E2 <common.ab3@470> XINCLUDE "/Shared/common.ab3"
000027E4 <common.ab3@471> XINCLUDE "/Shared/common.ab3"
000027E6 <common.ab3@472> XINCLUDE "/Shared/common.ab3"
000027EA <common.ab3@474> XINCLUDE "/Shared/common.ab3"
000027EE <common.ab3@476> XINCLUDE "/Shared/common.ab3"
000027F2 <common.ab3@478> XINCLUDE "/Shared/common.ab3"
000027F6 <common.ab3@479> XINCLUDE "/Shared/common.ab3"
000027FA <common.ab3@480> XINCLUDE "/Shared/common.ab3"
000027FE <common.ab3@481> XINCLUDE "/Shared/common.ab3"
00002802 <common.ab3@482> XINCLUDE "/Shared/common.ab3"
00002806 <common.ab3@483> XINCLUDE "/Shared/common.ab3"
0000280A <common.ab3@484> XINCLUDE "/Shared/common.ab3"
0000280E <common.ab3@485> XINCLUDE "/Shared/common.ab3"
00002814 <common.ab3@486> XINCLUDE "/Shared/common.ab3"
00002826 <common.ab3@487> XINCLUDE "/Shared/common.ab3"
00002828 <common.ab3@491> XINCLUDE "/Shared/common.ab3"
0000282C <common.ab3@492> XINCLUDE "/Shared/common.ab3"
0000282E <common.ab3@493> XINCLUDE "/Shared/common.ab3"
00002832 <common.ab3@494> XINCLUDE "/Shared/common.ab3"
00002834 <common.ab3@495> XINCLUDE "/Shared/common.ab3"
00002838 <common.ab3@496> XINCLUDE "/Shared/common.ab3"
0000283A <common.ab3@497> XINCLUDE "/Shared/common.ab3"
0000283E <common.ab3@498> XINCLUDE "/Shared/common.ab3"
00002840 <common.ab3@499> XINCLUDE "/Shared/common.ab3"
00002844 <common.ab3@500> XINCLUDE "/Shared/common.ab3"
00002846 <common.ab3@501> XINCLUDE "/Shared/common.ab3"
0000284A <common.ab3@502> XINCLUDE "/Shared/common.ab3"
0000284C <common.ab3@503> XINCLUDE "/Shared/common.ab3"
00002850 <common.ab3@504> XINCLUDE "/Shared/common.ab3"
00002852 <common.ab3@505> XINCLUDE "/Shared/common.ab3"
00002856 <common.ab3@506> XINCLUDE "/Shared/common.ab3"
00002858 <common.ab3@507> XINCLUDE "/Shared/common.ab3"
0000285C <common.ab3@508> XINCLUDE "/Shared/common.ab3"
0000285E <common.ab3@509> XINCLUDE "/Shared/common.ab3"
00002862 <common.ab3@510> XINCLUDE "/Shared/common.ab3"
00002864 <common.ab3@511> XINCLUDE "/Shared/common.ab3"
00002868 <common.ab3@512> XINCLUDE "/Shared/common.ab3"
0000286A <common.ab3@513> XINCLUDE "/Shared/common.ab3"
0000286E <common.ab3@514> XINCLUDE "/Shared/common.ab3"
00002870 <common.ab3@515> XINCLUDE "/Shared/common.ab3"
00002874 <common.ab3@516> XINCLUDE "/Shared/common.ab3"
00002876 <common.ab3@517> XINCLUDE "/Shared/common.ab3"
0000287A <common.ab3@518> XINCLUDE "/Shared/common.ab3"
0000287C <common.ab3@519> XINCLUDE "/Shared/common.ab3"
00002890 <common.ab3@523> XINCLUDE "/Shared/common.ab3"
000028A4 <common.ab3@524> XINCLUDE "/Shared/common.ab3"
000028B8 <common.ab3@525> XINCLUDE "/Shared/common.ab3"
000028BA <common.ab3@526> XINCLUDE "/Shared/common.ab3"
000028BE <common.ab3@527> XINCLUDE "/Shared/common.ab3"
000028C2 <common.ab3@528> XINCLUDE "/Shared/common.ab3"
000028C6 <common.ab3@529> XINCLUDE "/Shared/common.ab3"
000028CA <common.ab3@530> XINCLUDE "/Shared/common.ab3"
000028CE <common.ab3@531> XINCLUDE "/Shared/common.ab3"
000028D2 <common.ab3@532> XINCLUDE "/Shared/common.ab3"
000028D6 <common.ab3@533> XINCLUDE "/Shared/common.ab3"
000028D7 <common.ab3@534> XINCLUDE "/Shared/common.ab3"
000028D8 <common.ab3@535> XINCLUDE "/Shared/common.ab3"
000028D9 <common.ab3@536> XINCLUDE "/Shared/common.ab3"
000028DC <common.ab3@537> XINCLUDE "/Shared/common.ab3"
000028E0 <common.ab3@538> XINCLUDE "/Shared/common.ab3"
000028E4 <common.ab3@539> XINCLUDE "/Shared/common.ab3"
000028E8 <common.ab3@540> XINCLUDE "/Shared/common.ab3"
000028EC <common.ab3@541> XINCLUDE "/Shared/common.ab3"
000028F0 <common.ab3@542> XINCLUDE "/Shared/common.ab3"
000028F4 <common.ab3@543> XINCLUDE "/Shared/common.ab3"
000028F5 <common.ab3@544> XINCLUDE "/Shared/common.ab3"
000028F6 <common.ab3@545> XINCLUDE "/Shared/common.ab3"
000028F8 <common.ab3@546> XINCLUDE "/Shared/common.ab3"
000028FC <common.ab3@547> XINCLUDE "/Shared/common.ab3"
00002900 <common.ab3@548> XINCLUDE "/Shared/common.ab3"
00002904 <common.ab3@549> XINCLUDE "/Shared/common.ab3"
00002908 <common.ab3@551> XINCLUDE "/Shared/common.ab3"
0000290C <common.ab3@552> XINCLUDE "/Shared/common.ab3"
00002910 <common.ab3@553> XINCLUDE "/Shared/common.ab3"
00002914 <common.ab3@554> XINCLUDE "/Shared/common.ab3"
00002918 <common.ab3@555> XINCLUDE "/Shared/common.ab3"
0000291C <common.ab3@556> XINCLUDE "/Shared/common.ab3"
00002920 <common.ab3@557> XINCLUDE "/Shared/common.ab3"
00002924 <common.ab3@558> XINCLUDE "/Shared/common.ab3"
00002928 <common.ab3@562> XINCLUDE "/Shared/common.ab3"
0000292C <common.ab3@563> XINCLUDE "/Shared/common.ab3"
00002930 <common.ab3@564> XINCLUDE "/Shared/common.ab3"
00002932 <common.ab3@565> XINCLUDE "/Shared/common.ab3"
00002933 <common.ab3@566> XINCLUDE "/Shared/common.ab3"
00002937 <common.ab3@567> XINCLUDE "/Shared/common.ab3"
0000293B <common.ab3@568> XINCLUDE "/Shared/common.ab3"
0000293F <common.ab3@569> XINCLUDE "/Shared/common.ab3"
00002943 <common.ab3@570> XINCLUDE "/Shared/common.ab3"
00002944 <common.ab3@572> XINCLUDE "/Shared/common.ab3"
00002948 <common.ab3@575> XINCLUDE "/Shared/common.ab3"
0000294C <common.ab3@576> XINCLUDE "/Shared/common.ab3"
00002950 <common.ab3@577> XINCLUDE "/Shared/common.ab3"
00002951 <common.ab3@578> XINCLUDE "/Shared/common.ab3"
00002952 <common.ab3@580> XINCLUDE "/Shared/common.ab3"
00002956 <common.ab3@582> XINCLUDE "/Shared/common.ab3"
0000295A <common.ab3@583> XINCLUDE "/Shared/common.ab3"
0000295C <common.ab3@584> XINCLUDE "/Shared/common.ab3"
0000295E <common.ab3@585> XINCLUDE "/Shared/common.ab3"
00002962 <common.ab3@589> XINCLUDE "/Shared/common.ab3"
00002966 <common.ab3@590> XINCLUDE "/Shared/common.ab3"
0000296A <common.ab3@592> XINCLUDE "/Shared/common.ab3"
0000296E <common.ab3@593> XINCLUDE "/Shared/common.ab3"
00002972 <common.ab3@595> XINCLUDE "/Shared/common.ab3"
00002976 <common.ab3@596> XINCLUDE "/Shared/common.ab3"
0000297A <common.ab3@598> XINCLUDE "/Shared/common.ab3"
0000297E <common.ab3@599> XINCLUDE "/Shared/common.ab3"
00002982 <common.ab3@600> XINCLUDE "/Shared/common.ab3"
00002986 <common.ab3@601> XINCLUDE "/Shared/common.ab3"
0000298A <common.ab3@602> XINCLUDE "/Shared/common.ab3"
0000298E <common.ab3@603> XINCLUDE "/Shared/common.ab3"
00002992 <common.ab3@604> XINCLUDE "/Shared/common.ab3"
00002996 <common.ab3@605> XINCLUDE "/Shared/common.ab3"
0000299A <common.ab3@606> XINCLUDE "/Shared/common.ab3"
0000299E <common.ab3@607> XINCLUDE "/Shared/common.ab3"
000029A2 <common.ab3@608> XINCLUDE "/Shared/common.ab3"
000029A6 <common.ab3@609> XINCLUDE "/Shared/common.ab3"
000029AA <common.ab3@610> XINCLUDE "/Shared/common.ab3"
000029AE <common.ab3@611> XINCLUDE "/Shared/common.ab3"
000029AE <REDDebugger.ab3@62> XINCLUDE "/Shared/common.ab3"
000029AE <ted.include.ab3@1> XINCLUDE "/Shared/ted.include.ab3"
000029C8 <ted.include.ab3@161> XINCLUDE "/Shared/ted.include.ab3"
000029D2 <ted.include.ab3@162> XINCLUDE "/Shared/ted.include.ab3"
000029F4 <ted.include.ab3@163> XINCLUDE "/Shared/ted.include.ab3"
00002A0C <ted.include.ab3@164> XINCLUDE "/Shared/ted.include.ab3"
00002A26 <ted.include.ab3@166> XINCLUDE "/Shared/ted.include.ab3"
00002A58 <ted.include.ab3@167> XINCLUDE "/Shared/ted.include.ab3"
00002A62 <ted.include.ab3@168> XINCLUDE "/Shared/ted.include.ab3"
00002A68 <ted.include.ab3@170> XINCLUDE "/Shared/ted.include.ab3"
00002A7A <ted.include.ab3@171> XINCLUDE "/Shared/ted.include.ab3"
00002AEE <ted.include.ab3@172> XINCLUDE "/Shared/ted.include.ab3"
00002AF4 <ted.include.ab3@173> XINCLUDE "/Shared/ted.include.ab3"
00002B2E <ted.include.ab3@174> XINCLUDE "/Shared/ted.include.ab3"
00002B38 <ted.include.ab3@177> XINCLUDE "/Shared/ted.include.ab3"
00002B3E <ted.include.ab3@178> XINCLUDE "/Shared/ted.include.ab3"
00002B54 <ted.include.ab3@180> XINCLUDE "/Shared/ted.include.ab3"
00002B5E <ted.include.ab3@181> XINCLUDE "/Shared/ted.include.ab3"
00002B76 <ted.include.ab3@183> XINCLUDE "/Shared/ted.include.ab3"
00002B78 <ted.include.ab3@185> XINCLUDE "/Shared/ted.include.ab3"
00002BA6 <ted.include.ab3@186> XINCLUDE "/Shared/ted.include.ab3"
00002BBC <ted.include.ab3@222> XINCLUDE "/Shared/ted.include.ab3"
00002BD2 <ted.include.ab3@223> XINCLUDE "/Shared/ted.include.ab3"
00002BF8 <ted.include.ab3@224> XINCLUDE "/Shared/ted.include.ab3"
00002C02 <ted.include.ab3@226> XINCLUDE "/Shared/ted.include.ab3"
00002C16 <ted.include.ab3@227> XINCLUDE "/Shared/ted.include.ab3"
00002C16 <REDDebugger.ab3@63> XINCLUDE "/Shared/ted.include.ab3"
00002C16 <rastport.include.ab3@1> XINCLUDE "rastport.include.ab3"
00002C3E <rastport.include.ab3@32> XINCLUDE "rastport.include.ab3"
00002C4A <rastport.include.ab3@39> XINCLUDE "rastport.include.ab3"
00002C74 <rastport.include.ab3@41> XINCLUDE "rastport.include.ab3"
00002C8A <rastport.include.ab3@42> XINCLUDE "rastport.include.ab3"
00002CA2 <rastport.include.ab3@43> XINCLUDE "rastport.include.ab3"
00002CC8 <rastport.include.ab3@44> XINCLUDE "rastport.include.ab3"
00002CEE <rastport.include.ab3@45> XINCLUDE "rastport.include.ab3"
00002CFA <rastport.include.ab3@46> XINCLUDE "rastport.include.ab3"
00002D04 <rastport.include.ab3@47> XINCLUDE "rastport.include.ab3"
00002D26 <rastport.include.ab3@48> XINCLUDE "rastport.include.ab3"
00002D44 <rastport.include.ab3@49> XINCLUDE "rastport.include.ab3"
00002D6A <rastport.include.ab3@52> XINCLUDE "rastport.include.ab3"
00002D84 <rastport.include.ab3@54> XINCLUDE "rastport.include.ab3"
00002D98 <rastport.include.ab3@55> XINCLUDE "rastport.include.ab3"
00002DB6 <rastport.include.ab3@56> XINCLUDE "rastport.include.ab3"
00002DC6 <rastport.include.ab3@57> XINCLUDE "rastport.include.ab3"
00002DD2 <rastport.include.ab3@58> XINCLUDE "rastport.include.ab3"
00002DD6 <rastport.include.ab3@60> XINCLUDE "rastport.include.ab3"
00002DF0 <rastport.include.ab3@169> XINCLUDE "rastport.include.ab3"
00002DFA <rastport.include.ab3@171> XINCLUDE "rastport.include.ab3"
00002E0C <rastport.include.ab3@172> XINCLUDE "rastport.include.ab3"
00002E22 <rastport.include.ab3@173> XINCLUDE "rastport.include.ab3"
00002E42 <rastport.include.ab3@174> XINCLUDE "rastport.include.ab3"
00002E6C <rastport.include.ab3@175> XINCLUDE "rastport.include.ab3"
00002E7C <rastport.include.ab3@176> XINCLUDE "rastport.include.ab3"
00002E94 <rastport.include.ab3@177> XINCLUDE "rastport.include.ab3"
00002E9A <rastport.include.ab3@180> XINCLUDE "rastport.include.ab3"
00002E9E <rastport.include.ab3@181> XINCLUDE "rastport.include.ab3"
00002EB8 <rastport.include.ab3@231> XINCLUDE "rastport.include.ab3"
00002EC2 <rastport.include.ab3@233> XINCLUDE "rastport.include.ab3"
00002ED4 <rastport.include.ab3@234> XINCLUDE "rastport.include.ab3"
00002EEA <rastport.include.ab3@235> XINCLUDE "rastport.include.ab3"
00002EF4 <rastport.include.ab3@236> XINCLUDE "rastport.include.ab3"
00002F02 <rastport.include.ab3@237> XINCLUDE "rastport.include.ab3"
00002F12 <rastport.include.ab3@238> XINCLUDE "rastport.include.ab3"
00002F1C <rastport.include.ab3@239> XINCLUDE "rastport.include.ab3"
00002F40 <rastport.include.ab3@240> XINCLUDE "rastport.include.ab3"
00002F5A <rastport.include.ab3@241> XINCLUDE "rastport.include.ab3"
00002F74 <rastport.include.ab3@242> XINCLUDE "rastport.include.ab3"
00002F7E <rastport.include.ab3@243> XINCLUDE "rastport.include.ab3"
00002F84 <rastport.include.ab3@245> XINCLUDE "rastport.include.ab3"
00002F88 <rastport.include.ab3@246> XINCLUDE "rastport.include.ab3"
00002F9E <rastport.include.ab3@432> XINCLUDE "rastport.include.ab3"
00002FA8 <rastport.include.ab3@434> XINCLUDE "rastport.include.ab3"
00002FBA <rastport.include.ab3@435> XINCLUDE "rastport.include.ab3"
00002FCC <rastport.include.ab3@436> XINCLUDE "rastport.include.ab3"
00002FD6 <rastport.include.ab3@437> XINCLUDE "rastport.include.ab3"
00002FDC <rastport.include.ab3@438> XINCLUDE "rastport.include.ab3"
00002FDE <rastport.include.ab3@439> XINCLUDE "rastport.include.ab3"
0000300C <rastport.include.ab3@440> XINCLUDE "rastport.include.ab3"
0000300C <REDDebugger.ab3@64> XINCLUDE "rastport.include.ab3"
0000300C <asl.include.ab3@1> XINCLUDE "asl.include.ab3"
00003030 <asl.include.ab3@94> XINCLUDE "asl.include.ab3"
00003058 <asl.include.ab3@95> XINCLUDE "asl.include.ab3"
0000307C <asl.include.ab3@96> XINCLUDE "asl.include.ab3"
000030AA <asl.include.ab3@157> XINCLUDE "asl.include.ab3"
0000311A <asl.include.ab3@158> XINCLUDE "asl.include.ab3"
00003138 <asl.include.ab3@159> XINCLUDE "asl.include.ab3"
00003150 <asl.include.ab3@160> XINCLUDE "asl.include.ab3"
0000316E <asl.include.ab3@177> XINCLUDE "asl.include.ab3"
0000338C <asl.include.ab3@178> XINCLUDE "asl.include.ab3"
000033B8 <asl.include.ab3@181> XINCLUDE "asl.include.ab3"
000033E6 <asl.include.ab3@182> XINCLUDE "asl.include.ab3"
00003412 <asl.include.ab3@183> XINCLUDE "asl.include.ab3"
0000343E <asl.include.ab3@184> XINCLUDE "asl.include.ab3"
0000346A <asl.include.ab3@185> XINCLUDE "asl.include.ab3"
00003496 <asl.include.ab3@186> XINCLUDE "asl.include.ab3"
000034DA <asl.include.ab3@187> XINCLUDE "asl.include.ab3"
00003548 <asl.include.ab3@189> XINCLUDE "asl.include.ab3"
000035B6 <asl.include.ab3@190> XINCLUDE "asl.include.ab3"
00003624 <asl.include.ab3@191> XINCLUDE "asl.include.ab3"
0000366E <asl.include.ab3@192> XINCLUDE "asl.include.ab3"
0000368A <asl.include.ab3@193> XINCLUDE "asl.include.ab3"
000036B4 <asl.include.ab3@195> XINCLUDE "asl.include.ab3"
000036BE <asl.include.ab3@196> XINCLUDE "asl.include.ab3"
000036DC <asl.include.ab3@197> XINCLUDE "asl.include.ab3"
000036FE <asl.include.ab3@199> XINCLUDE "asl.include.ab3"
0000372C <asl.include.ab3@201> XINCLUDE "asl.include.ab3"
00003764 <asl.include.ab3@202> XINCLUDE "asl.include.ab3"
00003778 <asl.include.ab3@203> XINCLUDE "asl.include.ab3"
0000377E <asl.include.ab3@204> XINCLUDE "asl.include.ab3"
0000378E <asl.include.ab3@206> XINCLUDE "asl.include.ab3"
0000379E <asl.include.ab3@207> XINCLUDE "asl.include.ab3"
000037AE <asl.include.ab3@208> XINCLUDE "asl.include.ab3"
000037BE <asl.include.ab3@209> XINCLUDE "asl.include.ab3"
000037CE <asl.include.ab3@212> XINCLUDE "asl.include.ab3"
000037D8 <asl.include.ab3@214> XINCLUDE "asl.include.ab3"
000037EC <asl.include.ab3@215> XINCLUDE "asl.include.ab3"
00003802 <asl.include.ab3@230> XINCLUDE "asl.include.ab3"
00003830 <asl.include.ab3@231> XINCLUDE "asl.include.ab3"
00003838 <asl.include.ab3@232> XINCLUDE "asl.include.ab3"
0000384E <asl.include.ab3@246> XINCLUDE "asl.include.ab3"
0000385E <asl.include.ab3@247> XINCLUDE "asl.include.ab3"
00003862 <asl.include.ab3@248> XINCLUDE "asl.include.ab3"
000038AC <asl.include.ab3@263> XINCLUDE "asl.include.ab3"
000038E0 <asl.include.ab3@264> XINCLUDE "asl.include.ab3"
00003918 <asl.include.ab3@265> XINCLUDE "asl.include.ab3"
00003950 <asl.include.ab3@266> XINCLUDE "asl.include.ab3"
0000396A <asl.include.ab3@267> XINCLUDE "asl.include.ab3"
0000396A <REDDebugger.ab3@66> XINCLUDE "asl.include.ab3"
00003976 <REDDebugger.ab3@68> SystemBitMap 1
000039B0 <REDDebugger.ab3@385> Poke.b ?initstate  ,Vallong("\\__VER_MAJOR")
000039F0 <REDDebugger.ab3@386> Poke.b ?initstate+1,Vallong("\\__VER_MINOR")
00003A18 <REDDebugger.ab3@389> prefs.prefstype\fontname = ""; use system default "topaz.font",8
00003A26 <REDDebugger.ab3@390> prefs.prefstype\fontsize = 0 ; use system default "topaz.font",8
00003A2E <REDDebugger.ab3@391> stepnumber               = 1
00003A34 <REDDebugger.ab3@392> searchtype               = 1
00003A3E <REDDebugger.ab3@393> dowin                    = -1
00003A44 <REDDebugger.ab3@394> pmodevalid               = 0
00003A56 <REDDebugger.ab3@395> configsize.l             = Peek.w(?sizeofsave)
00003A7E <REDDebugger.ab3@396> array$                   = ""
00003A88 <REDDebugger.ab3@400> ScreenBarHeight.l   = 10 + 1
00003AB0 <REDDebugger.ab3@401> ScreenFontNameStr.s = "topaz.font"
00003AB8 <REDDebugger.ab3@402> ScreenFontYSize.l   = 8
00003AC0 <REDDebugger.ab3@403> WinBorTop.l         = 2
00003AD4 <REDDebugger.ab3@404> WinBorTextTop.l     = WinBorTop + ScreenFontYSize + 1
00003ADC <REDDebugger.ab3@405> WinBorLeft.l        = 4
00003AE4 <REDDebugger.ab3@406> WinBorRight.l       = 4
00003AEC <REDDebugger.ab3@407> WinBorBottom.l      = 2
00003AF4 <REDDebugger.ab3@408> WinSizeBorRight.l   = 18    ; set default size for hires
00003AFC <REDDebugger.ab3@409> WinSizeBorBottom.l  = 10    ; set default size for hires
00003B08 <REDDebugger.ab3@412> proz.l = Processor                                     ; needed for fpu register pos
00003B38 <REDDebugger.ab3@413> If proz = 3 OR proz = 2 Then MOVE.l #-200   ,fpuoffset ; 020/030
00003B54 <REDDebugger.ab3@414> If proz = 4 Then MOVE.l #-200+24,fpuoffset             ; 040
00003B70 <REDDebugger.ab3@415> If proz = 5 Then MOVE.l #-200+18,fpuoffset             ; 060
00003B98 <REDDebugger.ab3@420> Dim List varinfo.variabletype(19)
00003BC0 <REDDebugger.ab3@421> Dim List d_e.d_event(50)
00003BE8 <REDDebugger.ab3@422> Dim List objwins.structurewindow(9)
00003C0C <REDDebugger.ab3@424> Dim wininfo.wininfotype(Maximum Window)
00003C9C <REDDebugger.ab3@425> Dim memwin.w(1),mempointer.l(1),memlock$(1),memlockpf$(1)
00003CC0 <REDDebugger.ab3@426> Dim winstatus.w(Maximum Window)
00003CE4 <REDDebugger.ab3@427> Dim customcomm$(#MAXCUSTOMCOMMANDS)
00003D08 <REDDebugger.ab3@428> Dim srcStr.s(200)
00003D2C <REDDebugger.ab3@429> Dim disStr.s(200)
00003D50 <REDDebugger.ab3@430> Dim memStr.s(200)
00003D74 <REDDebugger.ab3@431> Dim fp$(8)
00003D8A <REDDebugger.ab3@433> mempointer(0)  = 0
00003DA0 <REDDebugger.ab3@434> mempointer(1)  = 0
00003DC8 <REDDebugger.ab3@435> objtype$       = "bwlsqf"  ;this is for the type check to trace variables
00003DD2 <REDDebugger.ab3@436> old_active_win = -1
00003DDC <REDDebugger.ab3@437> active_win     = -1
00003DE6 <REDDebugger.ab3@438> breakpoint_adr = ?breakpoint
00003DF0 <REDDebugger.ab3@439> breakstore.l   = ?breakstore
00003DF6 <REDDebugger.ab3@440> watch0.l       = False ; this check the NULL pointer, works only on OS3 wihtout enforcer
00003E1E <REDDebugger.ab3@444> typetitle$     = ""
00003E46 <REDDebugger.ab3@445> warn1$         = "REDDebugger is attempting to close its screen.\\nPlease close all visitor windows."
00003E88 <REDDebugger.ab3@446> 
00003ECE <REDDebugger.ab3@447> 
00003F14 <REDDebugger.ab3@448> 
00003F3C <REDDebugger.ab3@449> laststructure$ = ""
00003F76 <REDDebugger.ab3@450> scrtitle$      = "RED Debugger v"+!versions
00003F9E <REDDebugger.ab3@451> varfollow$     = "Variable trace"
00003FC6 <REDDebugger.ab3@452> cntrlwin$      = "Program mode:       "                    ; 6 spaces in string for mode!
00003FDC <REDDebugger.ab3@454> MaxLen autoeval$   = 80
00003FF2 <REDDebugger.ab3@455> MaxLen strg$       = 128
00004008 <REDDebugger.ab3@456> MaxLen ex$         = 128
0000401E <REDDebugger.ab3@457> MaxLen ev$         = 128
00004034 <REDDebugger.ab3@458> MaxLen evalbuffer$ = 256
0000403E <REDDebugger.ab3@500> vbr_test.l = cr_vbr
00004050 <REDDebugger.ab3@501> If vbr_test = 0
0000408A <REDDebugger.ab3@502> 
00004092 <REDDebugger.ab3@509> OSVersion = #AmigaOS3
000040CA <REDDebugger.ab3@510> 
00004100 <REDDebugger.ab3@511> 
00004106 <REDDebugger.ab3@515> Gosub StartOfDayInit
0000410E <REDDebugger.ab3@526>   rexxwiny.w    = ScreenBarHeight
00004114 <REDDebugger.ab3@527>   rexxwinx.w    = 0
0000413C <REDDebugger.ab3@528>   rexxportname$ = "REDDebugger"
00004152 <REDDebugger.ab3@530>   Statement CreateDebuggerPort{}
0000415E <REDDebugger.ab3@533>     rexxport.l=CreateMsgPort_
00004168 <REDDebugger.ab3@534>     If rexxport
0000417E <REDDebugger.ab3@535>       Poke.l rexxport+10,&rexxportname$
0000418E <REDDebugger.ab3@536>       AddPort_ rexxport
00004190 <REDDebugger.ab3@538>   End Statement
000041A6 <REDDebugger.ab3@541>   Statement ReplyDebuggerMsg{}
000041BE <REDDebugger.ab3@544>     If rexxport=0 Then Statement Return
000041D8 <REDDebugger.ab3@545>     If msg Then ReplyMsg_ msg
000041E0 <REDDebugger.ab3@546>     msg = 0
000041E2 <REDDebugger.ab3@547>   End Statement
000041F8 <REDDebugger.ab3@550>   Statement DeleteDebuggerPort{}
00004210 <REDDebugger.ab3@553>     If rexxport=0 Then Statement Return
00004220 <REDDebugger.ab3@554>     RemPort_ rexxport
00004230 <REDDebugger.ab3@555>     DeleteMsgPort_ rexxport
00004232 <REDDebugger.ab3@556>   End Statement
0000424C <REDDebugger.ab3@560>   If FindPort_(&rexxportname$)
000042B2 <REDDebugger.ab3@561>     a = RTEZRequest(scrtitle$,"    Already running!    ","  _Ok  ")
000042B8 <REDDebugger.ab3@562>     End
000042BE <REDDebugger.ab3@564>   CreateDebuggerPort{}
000042D6 <REDDebugger.ab3@565>   AddWaitEvent PortSigBit(rexxport),$10000000 ; add port to WaitEvent
000042DC <REDDebugger.ab3@566>   background_redo.w=1
000042E6 <REDDebugger.ab3@569>     If background_redo
00004320 <REDDebugger.ab3@570>       *scr._Screen = GetPubScreen(0,"Workbench")
00004396 <REDDebugger.ab3@571>       textlen.w    = TextLength_(*scr\_RastPort,scrtitle$,Len(scrtitle$))
00004412 <REDDebugger.ab3@572>       Window 0,rexxwinx,rexxwiny,textlen+64,WinBorTextTop,$21000e,scrtitle$,-1,-1 ; rexxportname$,-1,-1
00004418 <REDDebugger.ab3@573>       background_redo = 0
00004422 <REDDebugger.ab3@576>     ev = WaitEvent ; close mini win
00004434 <REDDebugger.ab3@577>     If ev = $10000000
00004442 <REDDebugger.ab3@578>       rexxwinx = WindowX
00004450 <REDDebugger.ab3@579>       rexxwiny = WindowY
0000446A <REDDebugger.ab3@581>       Free Screen 0
000044A0 <REDDebugger.ab3@582>       ReleasePubScreen 0,"Workbench"
000044A8 <REDDebugger.ab3@583>       msg = 1
000044C0 <REDDebugger.ab3@585>       While msg <> 0
000044D4 <REDDebugger.ab3@586>         msg = GetMsg_(rexxport)
000044DE <REDDebugger.ab3@587>         If msg
000044F2 <REDDebugger.ab3@588>           ad.l = Peek.l(msg+20)
00004516 <REDDebugger.ab3@589>           If Peek.l(msg + 24) = #IDENTIFIER
00004524 <REDDebugger.ab3@590>             GetReg a0,ad
0000452A <REDDebugger.ab3@591>             MOVE.l a0,d_table
00004530 <REDDebugger.ab3@592>             MOVE.l a5,d_a5
00004572 <REDDebugger.ab3@593>             MaxLen d_d$=256 : MaxLen d_ev$=256 : MaxLen d_ex$=256
00004584 <REDDebugger.ab3@594>             Poke.l ?d_dadd,&d_d$
000045A8 <REDDebugger.ab3@595>             statego.w = 0 : dstatus.w = 0 : prtcode.w = 0 : Poke.l ?statego_,&statego
000045DE <REDDebugger.ab3@596>             buffmem.l = AllocMem_(#bufflen,$10001) : Poke.l ?buffmem_,buffmem : CLR bufferput
0000463A <REDDebugger.ab3@597>             FillArray winstatus(),0
00004640 <REDDebugger.ab3@598>             ReplyDebuggerMsg{}
00004646 <REDDebugger.ab3@599>             Gosub mainstart
000046A2 <REDDebugger.ab3@601>             FillArray memwin(),0
000046FE <REDDebugger.ab3@602>             FillArray mempointer(),0
00004708 <REDDebugger.ab3@603>             ClearList varinfo()
00004712 <REDDebugger.ab3@604>             ClearList d_e()
0000471C <REDDebugger.ab3@605>             ClearList objwins()
00004782 <REDDebugger.ab3@606>             ali.l = 0 : lt$ = "" : task = 0 : autoeval = 0 : autoeval$ = ""
00004788 <REDDebugger.ab3@607>             pfregs = 0
000047BE <REDDebugger.ab3@608>             !ComData_SetB{comByte_RunningFlag,#0}
000047C4 <REDDebugger.ab3@609>             ted_CloseLib{}
000047CA <REDDebugger.ab3@613>       Wend
000047D0 <REDDebugger.ab3@615>       background_redo = 2
000047E8 <REDDebugger.ab3@617>   Until ev = $200                 ;replace endless loop for normal end condition  tomsmart1 2012 07 12
000047EE <REDDebugger.ab3@619>   DeleteDebuggerPort{}
000047F4 <REDDebugger.ab3@633> End
0000480E <REDDebugger.ab3@642> Statement d_sethandler{adr.l}
0000481E <REDDebugger.ab3@645>   LEA htable(pc),a0 : !d_call{2}
00004824 <REDDebugger.ab3@646>   MOVE.l a0,mybuffer
0000482A <REDDebugger.ab3@647>   MOVE.l a1,progmode
0000483C <REDDebugger.ab3@648>   PutReg a2,token_addr
0000484E <REDDebugger.ab3@649>   PutReg a3,task ; blitz program process
00004860 <REDDebugger.ab3@650>   PutReg d0,signal
00004872 <REDDebugger.ab3@651>   signalset = (0 BitSet signal)
00004878 <REDDebugger.ab3@652>   TST.b newdebug
0000487C <REDDebugger.ab3@653>   BEQ nd1
0000488E <REDDebugger.ab3@656>   If *TokenBase_Pointer <> 0                   ; test if we had a vailed comdata_tokenbase pointer
00004894 <REDDebugger.ab3@657>     token_addr = *TokenBase_Pointer            ; yes then we use it insteed of the debuglib one
0000489E <REDDebugger.ab3@660>   vbr_temp.l = cr_vbr
000048A2 <REDDebugger.ab3@662>   MOVE.l vbr_temp@(A5),a0
000048AA <REDDebugger.ab3@663>   MOVE.l trap15addr,$bc(a0)
000048AE <REDDebugger.ab3@666> End Statement
000048C8 <REDDebugger.ab3@678> Function.l getad {ad.l}
00004920 <REDDebugger.ab3@681>   If (ad = 0) Then error{"\\__THIS_FUNCTION: Null pointer exception!"} : Function Return 0
0000492E <REDDebugger.ab3@682>   i2.l = Peek.l(ad)
00004948 <REDDebugger.ab3@683>   If Peek.l(ad) AND $80000000
00004958 <REDDebugger.ab3@684>     i2 = i2 AND $7fffffff
0000496A <REDDebugger.ab3@685>     If startcode = 0
00004970 <REDDebugger.ab3@686>       GetD0 ad : MOVE.l d0,a0
00004976 <REDDebugger.ab3@687>       MOVE.l #"DuCk",d1
0000497C <REDDebugger.ab3@688>       MOVE.l #"AmiB",d2
00004982 <REDDebugger.ab3@689>       MOVE.l #10 000 000,d0
00004984 <REDDebugger.ab3@692>       ADDQ.l #1,a0
00004986 <REDDebugger.ab3@693>       CMP.l (a0),d1
0000498A <REDDebugger.ab3@694>       BEQ 'loop1
0000498C <REDDebugger.ab3@695>       SUBQ.l #1,d0
00004990 <REDDebugger.ab3@696>       BNE 'loop
00004994 <REDDebugger.ab3@697>       BRA 'loop3
00004998 <REDDebugger.ab3@700>       CMP.l 4(a0),d2
0000499C <REDDebugger.ab3@701>       BNE 'loop
0000499E <REDDebugger.ab3@702>       MOVE.l a0,d0
000049A2 <REDDebugger.ab3@703>       startcode = PutD0
000049B6 <REDDebugger.ab3@704>       startcode = Peek.l(startcode+8)
000049C6 <REDDebugger.ab3@708>     Function Return i2+startcode
000049CC <REDDebugger.ab3@709>   Else
000049DC <REDDebugger.ab3@710>     Function Return Peek.l(ad)
000049E2 <REDDebugger.ab3@712> End Function
000049FC <REDDebugger.ab3@716> Function.l getad2 {ad.l}
00004A54 <REDDebugger.ab3@719>   If (ad = 0) Then error{"\\__THIS_FUNCTION: Null pointer exception!"} : Function Return 0
00004A62 <REDDebugger.ab3@720>   i2.l = Peek.l(ad)
00004A7C <REDDebugger.ab3@721>   If Peek.l(ad) AND $80000000
00004A8C <REDDebugger.ab3@722>     i2 = i2 AND $7fffffff
00004A9E <REDDebugger.ab3@723>     If startcode = 0
00004AA4 <REDDebugger.ab3@724>       GetD0 ad : MOVE.l d0,a0
00004AAA <REDDebugger.ab3@725>       MOVE.l #"DuCk",d1
00004AB0 <REDDebugger.ab3@726>       MOVE.l #"AmiB",d2
00004AB6 <REDDebugger.ab3@727>       MOVE.l #10 000 000,d0
00004AB8 <REDDebugger.ab3@730>       ADDQ.l #1,a0
00004ABA <REDDebugger.ab3@731>       CMP.l (a0),d1
00004ABE <REDDebugger.ab3@732>       BEQ 'loop1
00004AC0 <REDDebugger.ab3@733>       SUBQ.l #1,d0
00004AC4 <REDDebugger.ab3@734>       BNE 'loop
00004AC8 <REDDebugger.ab3@735>       BRA 'loop3
00004ACC <REDDebugger.ab3@738>       CMP.l 4(a0),d2
00004AD0 <REDDebugger.ab3@739>       BNE 'loop
00004AD2 <REDDebugger.ab3@740>       MOVE.l a0,d0
00004AD6 <REDDebugger.ab3@741>       startcode = PutD0
00004AEA <REDDebugger.ab3@742>       startcode = Peek.l(startcode+8)
00004AFA <REDDebugger.ab3@746>     Function Return i2+startcode
00004B00 <REDDebugger.ab3@747>   Else
00004B0A <REDDebugger.ab3@748>     Function Return ad
00004B10 <REDDebugger.ab3@750> End Function
00004B3E <REDDebugger.ab3@753> Statement d_eval{t$,dosignal.w}
00004B8E <REDDebugger.ab3@757>     d_ev$=t$ : GetReg a0,&d_ev$ : !d_call{4}
00004B98 <REDDebugger.ab3@758>     If task
00004BA6 <REDDebugger.ab3@759>       If dosignal = #SIGNAL
00004BB4 <REDDebugger.ab3@760>         If dstatus = #STOPPED
00004BC2 <REDDebugger.ab3@761>           stepcnt+1
00004BDA <REDDebugger.ab3@763>           Signal_ task,signalset
00004BE0 <REDDebugger.ab3@767>     Else
00004C1A <REDDebugger.ab3@768>       error{"Task = 0"}
00004C32 <REDDebugger.ab3@773> End Statement
00004C5C <REDDebugger.ab3@776> Statement d_exec{t$}
00004CAC <REDDebugger.ab3@780>     d_ex$=t$ : GetReg a0,&d_ex$ : !d_call{5}
00004CBA <REDDebugger.ab3@781>     If dstatus = #STOPPED
00004CC8 <REDDebugger.ab3@782>       stepcnt+1
00004CE0 <REDDebugger.ab3@783>       Signal_ task,signalset
00004CF8 <REDDebugger.ab3@788> End Statement
00004D0E <REDDebugger.ab3@791> Statement d_quit{}
00004D1C <REDDebugger.ab3@794>   If dstatus <> #STOPPED
00004D28 <REDDebugger.ab3@795>     !d_call{1}
00004D30 <REDDebugger.ab3@796>     stepcnt = 0
00004D42 <REDDebugger.ab3@797>     Delay_ 2
00004D4E <REDDebugger.ab3@800>   !d_call{6}
00004D5C <REDDebugger.ab3@801>   stepcnt+1
00004D74 <REDDebugger.ab3@802>   Signal_ task,signalset
00004D76 <REDDebugger.ab3@803> End Statement
00004DA4 <REDDebugger.ab3@818> Statement add_event{t.l,s$}
00004DAC <REDDebugger.ab3@821>   Forbid_
00004DBE <REDDebugger.ab3@822>    If AddLast(d_e())
00004DCE <REDDebugger.ab3@823>      d_e()\t = t
00004DF4 <REDDebugger.ab3@824>      MOVE.w bufferput(pc),d0 : SUBQ.w #4,d0 : AND.w #buffand,d0 : PutReg d0,d_e()\i
00004E32 <REDDebugger.ab3@825>      d_e()\s = s$
00004E3A <REDDebugger.ab3@827>   Permit_
00004E52 <REDDebugger.ab3@828> End Statement
00004E64 <REDDebugger.ab3@832>   Dc.b "$VER: REDDebugger "
00004E7F <REDDebugger.ab3@833>   Dc.b !versions," (\\__DATE_GER__) Build \\__VER_PATCH.\\__VER_BUILD",0
00004E80 <REDDebugger.ab3@834>   Even
00004E84 <REDDebugger.ab3@837> varhandler:     Dc.l 0 ; Message waiting for debugger
00004E88 <REDDebugger.ab3@838> mybuffer:       Dc.l 0 ; Pointer to registers!
00004E8C <REDDebugger.ab3@839> progmode:       Dc.l 0 ; Pointer to word that hold program mode
00004E90 <REDDebugger.ab3@841> d_dadd:         Dc.l 0
00004E94 <REDDebugger.ab3@842> d_table:        Dc.l 0
00004E98 <REDDebugger.ab3@843> d_a5:           Dc.l 0
00004E9C <REDDebugger.ab3@844> statego_:       Dc.l 0
00004EA0 <REDDebugger.ab3@845> buffmem_:       Dc.l 0
00004EA2 <REDDebugger.ab3@846> bufferput:      Dc.w 0
00004EAE <REDDebugger.ab3@849>  Dc.l d_statehandler   ,d_superhandler,d_userhandler
00004EBA <REDDebugger.ab3@850>  Dc.l d_waithandler    ,d_evalhandler ,d_cleanup
00004EC2 <REDDebugger.ab3@851>  Dc.l d_vartracehandler,d_prochandler
00004ECE <REDDebugger.ab3@855>   MOVE.l buffmem_(pc),a1 : ADD bufferput(pc),a1 : MOVE.l 64(a0),(a1)
00004EDC <REDDebugger.ab3@856>   ADDQ #4,bufferput : ANDI #buffand,bufferput
00004EDE <REDDebugger.ab3@858>   MOVE.l    (a1),a0
00004EE2 <REDDebugger.ab3@859>   LEA       breakpoint(pc),a1
00004EE4 <REDDebugger.ab3@862>   TST.l     (a1)
00004EE6 <REDDebugger.ab3@863>   !SBEQ     {'skipit}
00004EE8 <REDDebugger.ab3@864>   CMP.l     (a1),a0
00004EEA <REDDebugger.ab3@865>   !SBEQ     {'ok}
00004EEC <REDDebugger.ab3@866>   ADDQ.l    #8,a1
00004EEE <REDDebugger.ab3@867>   !SBRA     {'check}
00004EF2 <REDDebugger.ab3@870>   MOVE.l    statego_(pc),a1
00004EF4 <REDDebugger.ab3@871>   TST       (a1)
00004EF6 <REDDebugger.ab3@872>  RTS
00004EFC <REDDebugger.ab3@875>   CMPI.w    #break_simple,4(a1)
00004EFE <REDDebugger.ab3@876>   !SBNE     {'noclear}
00004F04 <REDDebugger.ab3@877>   SUB.w     #1,6(a1) ; Got simple breakpoint
00004F06 <REDDebugger.ab3@878>   !SBEQ     {'clear_em}
00004F08 <REDDebugger.ab3@879>   !SBRA     {'skipit}
00004F0E <REDDebugger.ab3@882>   CMPI.w    #break_permanent,4(a1)
00004F12 <REDDebugger.ab3@883>   BEQ       '_return
00004F18 <REDDebugger.ab3@884>   ADD.w     #1,6(a1)
00004F1A <REDDebugger.ab3@885>   !SBRA     {'skipit}
00004F1C <REDDebugger.ab3@889>   TST.l     (a1)
00004F1E <REDDebugger.ab3@890>   !SBEQ     {'_return}
00004F20 <REDDebugger.ab3@891>   ADDQ.l    #8,a1
00004F24 <REDDebugger.ab3@892>   MOVE.l    (a1),-8(a1)
00004F2A <REDDebugger.ab3@893>   MOVE.l    4(a1),-4(a1)
00004F2C <REDDebugger.ab3@894>   !SBRA     {'clear_em}
00004F2E <REDDebugger.ab3@897>   MOVE.l    a5,-(a7)
00004F32 <REDDebugger.ab3@898>   !d_basic
00004F38 <REDDebugger.ab3@899>   Gosub     stopit
00004F3A <REDDebugger.ab3@900>   MOVE.l    (a7)+,a5
00004F40 <REDDebugger.ab3@901>   ST        donebreakpoint
00004F44 <REDDebugger.ab3@902>   MOVE.l    statego_(pc),a1
00004F46 <REDDebugger.ab3@903>   TST       (a1)
00004F48 <REDDebugger.ab3@904> RTS
00004F4A <REDDebugger.ab3@907> donebreakpoint: Dc.w 0
00004F52 <REDDebugger.ab3@909> breakpoint:     Dc.l 0,0 ; 0
00004F5A <REDDebugger.ab3@910>                 Dc.l 0,0 ; 1
00004F62 <REDDebugger.ab3@911>                 Dc.l 0,0 ; 2
00004F6A <REDDebugger.ab3@912>                 Dc.l 0,0 ; 3
00004F72 <REDDebugger.ab3@913>                 Dc.l 0,0 ; 4
00004F7A <REDDebugger.ab3@914>                 Dc.l 0,0 ; [reserved]
00004F82 <REDDebugger.ab3@915>                 Dc.l 0,0
00004F84 <REDDebugger.ab3@917> breakstore:     Dc.w 0
00004F86 <REDDebugger.ab3@918>                 Dc.w 0
00004F88 <REDDebugger.ab3@919>                 Dc.w 0
00004F8A <REDDebugger.ab3@920>                 Dc.w 0
00004F8C <REDDebugger.ab3@921>                 Dc.w 0
00004F8E <REDDebugger.ab3@922>                 Dc.w 0
00004F90 <REDDebugger.ab3@923>                 Dc.w 0
00004F96 <REDDebugger.ab3@926>   MOVE.l a7,regpos
00004FAC <REDDebugger.ab3@927>   !d_basic : PutReg a0,sa.l
00004FE4 <REDDebugger.ab3@928>   Gosub stopit : add_event{0,Peek.s(sa)}
00004FE6 <REDDebugger.ab3@929> Return
00004FFC <REDDebugger.ab3@933>   !d_basic : PutReg a0,sa
00005034 <REDDebugger.ab3@934>   Gosub stopit : add_event{1,Peek.s(sa)}
00005036 <REDDebugger.ab3@935> Return
0000503A <REDDebugger.ab3@939>   !d_basic
00005040 <REDDebugger.ab3@940>   TST.b   noredraw
00005042 <REDDebugger.ab3@941>   !SBNE   {label}
0000504C <REDDebugger.ab3@942>   If prtcode ; print code out?
00005058 <REDDebugger.ab3@943>     prtbusy.l = -1
00005080 <REDDebugger.ab3@944>     add_event{3,""} ; print me out!
00005090 <REDDebugger.ab3@945>     Wait_ signalset
000050B2 <REDDebugger.ab3@946>     While prtbusy : Delay_ 1 : Wend ; vwait wait till printed!
000050B8 <REDDebugger.ab3@950>   MOVE.l a7,regpos
000050E0 <REDDebugger.ab3@951>   If pfregs = 0 Then PFRegisters Peek.l(MyBufferAddress.l) : pfregs = -1
000050E6 <REDDebugger.ab3@952>   SF noredraw
000050F4 <REDDebugger.ab3@953>   If dstatus = #STOPPED ; stopped?
00005116 <REDDebugger.ab3@954>     If stepcnt = 0 Then Wait_ signalset ; wait blitz dbug prg process
00005124 <REDDebugger.ab3@955>     stepcnt-1
0000514A <REDDebugger.ab3@957>   If (dstatus = #TRACE OR dstatus = #STOPPED) AND blitzcontrol
0000514C <REDDebugger.ab3@958>     MOVEQ #-1,d0
00005152 <REDDebugger.ab3@959>   Else
0000516E <REDDebugger.ab3@960>     If dstatus = #BLITZMODE Then dstatus = #STOPPED : BCHG #1,$bfe001
00005170 <REDDebugger.ab3@961>     MOVEQ #0,d0
00005172 <REDDebugger.ab3@963> Return
00005174 <REDDebugger.ab3@966> noredraw:   Dc.w  0
0000518A <REDDebugger.ab3@970>   !d_basic : PutReg a0,sa
000051BC <REDDebugger.ab3@971>   add_event{2,Peek.s(sa)}
000051C2 <REDDebugger.ab3@972>   ST    noredraw
000051C4 <REDDebugger.ab3@973> Return
000051F0 <REDDebugger.ab3@977>   !d_basic : add_event{4,""}
000051F2 <REDDebugger.ab3@978> Return
000051F6 <REDDebugger.ab3@982>   MOVEM.l d0-d7/a0-a6,-(a7)
000051FE <REDDebugger.ab3@983>   'loop1 : TST.l varhandler : !SBNE {'loop1}
00005204 <REDDebugger.ab3@984>   MOVE.l  a0,varhandler
0000520C <REDDebugger.ab3@985>   'loop2 : TST.l varhandler : !SBNE {'loop2}
00005210 <REDDebugger.ab3@986>   MOVEM.l (a7)+,d0-d7/a0-a6
00005212 <REDDebugger.ab3@987> RTS
00005214 <REDDebugger.ab3@995>   TST.b   d1
00005218 <REDDebugger.ab3@996>   BNE     'setstop
00005220 <REDDebugger.ab3@999>   ADD.w   #1,proccount
00005228 <REDDebugger.ab3@1000>   CMPI.w  #1,proccount ; First procedure?
0000522A <REDDebugger.ab3@1001>   !SBNE   {'exitthis}
00005230 <REDDebugger.ab3@1003>   MOVE.l  statego_(pc),a1 : TST (a1)
00005232 <REDDebugger.ab3@1004>   !SBEQ   {'running}
0000523A <REDDebugger.ab3@1005>   MOVE.w  #0,stopstate
0000523E <REDDebugger.ab3@1006>   !d_basic
00005244 <REDDebugger.ab3@1007>   old_dstatus = dstatus
00005256 <REDDebugger.ab3@1008>   prtcode = 0 : dstatus = 0 : statego = 0
00005258 <REDDebugger.ab3@1011>  RTS
0000525E <REDDebugger.ab3@1014>   TST.w   proccount
00005260 <REDDebugger.ab3@1015>   !SBEQ   {'exitthis}
00005268 <REDDebugger.ab3@1017>   SUB.w   #1,proccount
0000526E <REDDebugger.ab3@1018>   TST.w   proccount   ; Last procedure?
00005270 <REDDebugger.ab3@1019>   !SBNE   {'exitthis} ; Nope - continue running
00005276 <REDDebugger.ab3@1021>   TST.w   stopstate   ; Was original state running?
00005278 <REDDebugger.ab3@1022>   !SBNE   {'exitthis} ; Nope - continue running then
0000527C <REDDebugger.ab3@1024>   !d_basic
0000529E <REDDebugger.ab3@1025>   prtcode = -1 : stepcnt = 0 : dstatus = old_dstatus : statego = -1
000052A0 <REDDebugger.ab3@1026>  RTS
000052A8 <REDDebugger.ab3@1029>   MOVE.w  #-1,stopstate
000052AA <REDDebugger.ab3@1030> RTS
000052AC <REDDebugger.ab3@1033> proccount:      Dc.w 0
000052AE <REDDebugger.ab3@1034> stopstate:      Dc.w 0
000052B2 <REDDebugger.ab3@1035> procreturnval:  Dc.l 0
000052CC <REDDebugger.ab3@1041>   GetReg a0,Peek.l(ad2)+9
000052E2 <REDDebugger.ab3@1042>   MOVE.l d_dadd(pc),a1 : !d_call{3} : SUB.l d_dadd(pc),a1 : SUBQ #1,a1
000052E8 <REDDebugger.ab3@1043>   MOVE.l d_dadd(pc),a0 : MOVE.l a1,-(a0)
000052EA <REDDebugger.ab3@1044> Return
00005314 <REDDebugger.ab3@1050> Statement DoHelp{a$}
00005326 <REDDebugger.ab3@1053>   If arexxport = 0
000053B8 <REDDebugger.ab3@1054>     a.l = RTEZRequest(scrtitle$,"Online help not available because RexxMast"+Chr$(10)+"is not running.","  Ok  ")
000053BE <REDDebugger.ab3@1055>     Statement Return
000053F6 <REDDebugger.ab3@1058>   If pubname$ = ""
0000541E <REDDebugger.ab3@1059>     p$ = "Workbench"
00005424 <REDDebugger.ab3@1060>   Else
00005458 <REDDebugger.ab3@1061>     p$ = pubname$
0000549A <REDDebugger.ab3@1064>   GetPubScreen 1,p$
000054B2 <REDDebugger.ab3@1065>   ShowScreen 1
000054F4 <REDDebugger.ab3@1066>   ReleasePubScreen 1,p$
0000550E <REDDebugger.ab3@1067>   Poke.l Addr Screen(1),0
0000551E <REDDebugger.ab3@1069>   Use Screen 0
0000554C <REDDebugger.ab3@1070>   If FindPort_("DEBUGGERHELP.1")
000055B8 <REDDebugger.ab3@1071>     RXSendCommand "DEBUGGERHELP.1","'link "+a$+"'"
000055BE <REDDebugger.ab3@1072>   Else
0000567E <REDDebugger.ab3@1073>     command$ = "run " + dos_AddPart{default_assign$,"Tools/AB3HelpViewer"} + " -t " + a$
0000575C <REDDebugger.ab3@1074>     command$ + " -d " + dos_AddPart{default_assign$,"Docs"} + " -l REDDebugger -s " + p$
000057A2 <REDDebugger.ab3@1075>     Execute_ command$,0,0
000057BA <REDDebugger.ab3@1077> End Statement
000057D4 <REDDebugger.ab3@1081> Statement NewWindow{win.w}
000057E8 <REDDebugger.ab3@1089>   winstatus(win) = 0
0000580E <REDDebugger.ab3@1091>   If (OSVersion = #AmigaOS4 OR OSVersion = #MorphOS)
00005850 <REDDebugger.ab3@1092>     If (win = #_winMemory1) OR (win = #_winMemory2) OR (win = #_winDisCop) OR (win = #_winCustom) OR (win = #_winSearch)
0000588A <REDDebugger.ab3@1093>        error{"This feature/window is disabled on AmigaOS4/MorphOS.\\nHint: Save preferences if this pops up on startup."}
00005890 <REDDebugger.ab3@1094>        Statement Return
0000589E <REDDebugger.ab3@1098>   If win = #_winMouseables
000058F6 <REDDebugger.ab3@1099>     If ask{"This feature is currently broken.\\nDo you want to open the window anyway?","Yes, please.|Ooops!"}=0
000058FC <REDDebugger.ab3@1100>       Statement Return
0000591A <REDDebugger.ab3@1104>   If win = #_winMemory1 OR win = #_winMemory2
00005920 <REDDebugger.ab3@1105>     typ.w = 1
00005938 <REDDebugger.ab3@1106>     Poke.l ?__more+4,?__memwin
0000593E <REDDebugger.ab3@1107>   Else
00005956 <REDDebugger.ab3@1108>     Poke.l ?__more+4,?__norm
0000596E <REDDebugger.ab3@1109>     Poke.l ?__tl_mh+4,maxheight
00005988 <REDDebugger.ab3@1111>   x.w = wininfo(win)\x
000059A6 <REDDebugger.ab3@1112>   y.w = wininfo(win)\y
000059C4 <REDDebugger.ab3@1113>   w.w = wininfo(win)\w
000059E2 <REDDebugger.ab3@1114>   h.w = wininfo(win)\h
00005A00 <REDDebugger.ab3@1115>   f.l = wininfo(win)\flags
00005A0E <REDDebugger.ab3@1117>   If win = #_winRegisters      ; test for Register window and set the max height of the window to 9 text lines
00005A36 <REDDebugger.ab3@1118>     maxRegHeight.w = prefs\fontsize*9 +WinBorTextTop +WinSizeBorBottom +1   ; max height for register window
00005A4E <REDDebugger.ab3@1119>     Poke.l ?__tl_mh+4,maxRegHeight
00005A5C <REDDebugger.ab3@1120>     If h > maxRegHeight
00005A64 <REDDebugger.ab3@1121>       h = maxRegHeight
00005A82 <REDDebugger.ab3@1122>       wininfo(win)\h = maxRegHeight
00005A90 <REDDebugger.ab3@1126>   If end_init
00005A9E <REDDebugger.ab3@1127>     f+$1000
00005AA4 <REDDebugger.ab3@1128>     old_active_win = active_win
00005AAC <REDDebugger.ab3@1129>     active_win = win
00005AC4 <REDDebugger.ab3@1139>   Poke.l ?__gimmi+4,0
00005AD0 <REDDebugger.ab3@1141>   AddIDCMP #IDCMP_MOUSEMOVE
00005ADE <REDDebugger.ab3@1142>   If win = #_winSource
00005AEA <REDDebugger.ab3@1143>     AddIDCMP #IDCMP_MOUSEMOVE
00005AFA <REDDebugger.ab3@1144>     f = f OR #WFLG_REPORTMOUSE
00005B0A <REDDebugger.ab3@1148>   f = f OR #WFLG_REPORTMOUSE
00005B22 <REDDebugger.ab3@1149>   Poke.l ?__tl_scr+4,&scrtitle$
00005B3A <REDDebugger.ab3@1150>   Poke.l ?__tl_w  +4,w
00005B52 <REDDebugger.ab3@1151>   Poke.l ?__tl_h  +4,h
00005B6A <REDDebugger.ab3@1152>   Poke.l ?__tl_l  +4,x
00005B82 <REDDebugger.ab3@1153>   Poke.l ?__tl_t  +4,y
00005BAA <REDDebugger.ab3@1155>   If wininfo(win)\gadlist<>-1
00005BF0 <REDDebugger.ab3@1156>     Poke.l ?__tl_g+4,Peek.l(Addr GadgetList(wininfo(win)\gadlist))
00005BF6 <REDDebugger.ab3@1157>   Else
00005C0E <REDDebugger.ab3@1158>     Poke.l ?__tl_g+4,0
00005C76 <REDDebugger.ab3@1161>   WindowTags win,f,wininfo(win)\title,?__Taglist
00005C8C <REDDebugger.ab3@1162>   winstatus(win) = -1
00005CB4 <REDDebugger.ab3@1163>   wininfo(win)\w = w,h
00005CD4 <REDDebugger.ab3@1165>   GTSetMenu 0
00005CF0 <REDDebugger.ab3@1166>     WindowFont 1
00005D26 <REDDebugger.ab3@1167>   If (win = #_winSearch) OR (win = #_winCustom) OR (win = #_winArray) OR (win > 12)
00005D42 <REDDebugger.ab3@1168>     WindowFont 0
00005D62 <REDDebugger.ab3@1171>   If win = #_winDisAsm Then InnerCls 2   ; clear/fill win with colour 2
00005D68 <REDDebugger.ab3@1173>   Statement Return
00005D70 <REDDebugger.ab3@1176>             Dc.l  #WA_NewLookMenus  ,   1
00005D78 <REDDebugger.ab3@1177>   __gimmi   Dc.l  #WA_GimmeZeroZero ,   1
00005D80 <REDDebugger.ab3@1178>   __tl_w:   Dc.l  #WA_Width         ,   0
00005D88 <REDDebugger.ab3@1179>   __tl_h:   Dc.l  #WA_Height        ,   0
00005D90 <REDDebugger.ab3@1180>   __tl_l:   Dc.l  #WA_Left          ,   0
00005D98 <REDDebugger.ab3@1181>   __tl_t:   Dc.l  #WA_Top           ,   0
00005DA0 <REDDebugger.ab3@1182>   __tl_g:   Dc.l  #WA_Gadgets       ,   0
00005DA8 <REDDebugger.ab3@1183>             Dc.l  #WA_MenuHelp      ,   1
00005DB0 <REDDebugger.ab3@1184>   __tl_scr: Dc.l  #WA_ScreenTitle   ,   0
00005DB8 <REDDebugger.ab3@1185>   __more:   Dc.l  #TAG_MORE         ,   0
00005DC0 <REDDebugger.ab3@1188>             Dc.l  #WA_MinWidth      ,  160
00005DC8 <REDDebugger.ab3@1189>             Dc.l  #WA_MinHeight     ,   70
00005DD0 <REDDebugger.ab3@1190>             Dc.l  #WA_MaxWidth      , 1920
00005DD8 <REDDebugger.ab3@1191>   __tl_mh:  Dc.l  #WA_MaxHeight     , #maxheight_ever
00005DDC <REDDebugger.ab3@1192>             Dc.l  #TAG_END
00005DE4 <REDDebugger.ab3@1194>   __memwin: Dc.l  #WA_MinWidth      ,  208
00005DEC <REDDebugger.ab3@1195>             Dc.l  #WA_MinHeight     ,   70
00005DF4 <REDDebugger.ab3@1196>             Dc.l  #WA_MaxWidth      , 1920
00005DFC <REDDebugger.ab3@1197>             Dc.l  #WA_MaxHeight     , #maxheight_ever
00005E00 <REDDebugger.ab3@1198>             Dc.l  #TAG_END
00005E12 <REDDebugger.ab3@1199> End Statement
00005E2C <REDDebugger.ab3@1202> Statement Domemtitle{num.w}
00005E3C <REDDebugger.ab3@1205>   win.w = #_winMemory1+num
00005E84 <REDDebugger.ab3@1206>   a$    = wininfo(win)\title
00005EBA <REDDebugger.ab3@1207>   If memlock$(num)
00005F5C <REDDebugger.ab3@1208>     a$+" ("+UCase$(memlock$(num))+")"
00005F78 <REDDebugger.ab3@1210>   If (Peek.l(Addr Window(win)))
00005F8E <REDDebugger.ab3@1211>     Use Window win
00005FC6 <REDDebugger.ab3@1212>     WTitle a$
00005FD8 <REDDebugger.ab3@1214> End Statement
00005FF2 <REDDebugger.ab3@1218> Statement NewMemWindow{win.w}
00006012 <REDDebugger.ab3@1221>   wininfo(win)\flags   = $20002f
00006032 <REDDebugger.ab3@1222>   wininfo(win)\gadlist = -1
0000603C <REDDebugger.ab3@1223>   NewWindow{win}
0000605C <REDDebugger.ab3@1225>   If win = #_winMemory1 Then num.b = 0 Else num = 1
00006068 <REDDebugger.ab3@1226>   Domemtitle{num}
0000606C <REDDebugger.ab3@1227> End Statement
00006086 <REDDebugger.ab3@1232> Statement DelWindow{win.w}
000060CA <REDDebugger.ab3@1235>   If (Peek.l(Addr Window(win))=0) Then Use Window 0 :Statement Return
000060D8 <REDDebugger.ab3@1236>   If win > 22
000060EE <REDDebugger.ab3@1237>     Use Window win
0000613E <REDDebugger.ab3@1238>     wininfo(win)\x = WindowX,WindowY,WindowWidth,WindowHeight
00006152 <REDDebugger.ab3@1239>     winstatus(win) = 0
00006166 <REDDebugger.ab3@1240>     WZCloseWindow win
0000617C <REDDebugger.ab3@1241>     Use Window 0
00006182 <REDDebugger.ab3@1242>   Else
00006198 <REDDebugger.ab3@1243>     Use Window win
000061E8 <REDDebugger.ab3@1244>     wininfo(win)\x = WindowX,WindowY,WindowWidth,WindowHeight
000061FC <REDDebugger.ab3@1245>     winstatus(win) = 0
00006214 <REDDebugger.ab3@1246>     CloseWindow win
0000622A <REDDebugger.ab3@1247>     Use Window 0
0000622E <REDDebugger.ab3@1249> End Statement
00006248 <REDDebugger.ab3@1252> Statement FindStructureWin{evw.l}
00006252 <REDDebugger.ab3@1255>   FirstItem objwins()
00006278 <REDDebugger.ab3@1256>   While objwins()\winnum<>evw
00006282 <REDDebugger.ab3@1257>     NextItem objwins()
00006288 <REDDebugger.ab3@1258>   Wend
0000628C <REDDebugger.ab3@1259> End Statement
000062B6 <REDDebugger.ab3@1262> Statement SaveIt{p$}
000062C0 <REDDebugger.ab3@1265>   If ad2
000062F6 <REDDebugger.ab3@1266>     If dos_Exist{p$} ; added to check if the path exist
0000638A <REDDebugger.ab3@1267>       If WriteFile(0,dos_AddPart{p$,"RED_DBug.prefs"} )
000063AA <REDDebugger.ab3@1268>         WriteMem 0,ad2,configsize
000063C2 <REDDebugger.ab3@1269>         CloseFile 0
00006456 <REDDebugger.ab3@1271>       If WriteFile(0,dos_AddPart{p$,"RED_DBug2.prefs"} )
00006486 <REDDebugger.ab3@1272>         WriteType 0,prefs
0000649E <REDDebugger.ab3@1273>         CloseFile 0
000064A4 <REDDebugger.ab3@1276>   Else
000064DE <REDDebugger.ab3@1277>     error{"Internal Error: Unable to save config because ad2=NULL !!!"}
000064F6 <REDDebugger.ab3@1279> End Statement
00006510 <REDDebugger.ab3@1282> Statement RedrawArray{refreshtype.b}
0000653E <REDDebugger.ab3@1288>   If (Peek.l(Addr Window(#_winArray))=0) Then Statement Return
00006564 <REDDebugger.ab3@1289>   Use Window #_winArray : Use BitMap 1
00006574 <REDDebugger.ab3@1290>   If refreshtype = 1
00006582 <REDDebugger.ab3@1291>     If arrayitemsize > 0
000065A2 <REDDebugger.ab3@1292>       xarraynum = (InnerWidth ASR 3)/(arrayitemsize)
000065AE <REDDebugger.ab3@1293>       xarraynum-2
000065C2 <REDDebugger.ab3@1295>     If xarraynum < 0 Then xarraynum = 0
000065E6 <REDDebugger.ab3@1296>     SetPropInfo #_winArray,#ARR_XGAD,xarraynum,array1,xarrayoff
000065F8 <REDDebugger.ab3@1297>     If xarraynum > array1
00006600 <REDDebugger.ab3@1298>       xarraynum = array1
00006606 <REDDebugger.ab3@1299>       xarrayoff = 0
0000660C <REDDebugger.ab3@1300>     Else
00006638 <REDDebugger.ab3@1301>       If xarrayoff+xarraynum+1 > array1 Then xarrayoff = array1-xarraynum
00006652 <REDDebugger.ab3@1304>     yarraynum = (InnerHeight-8) ASR 3
0000665E <REDDebugger.ab3@1305>     yarraynum-1
00006682 <REDDebugger.ab3@1306>     SetPropInfo #_winArray,#ARR_YGAD,yarraynum,array2,yarrayoff
00006694 <REDDebugger.ab3@1307>     If yarraynum > array2
0000669C <REDDebugger.ab3@1308>       yarraynum = array2
000066A2 <REDDebugger.ab3@1309>       yarrayoff = 0
000066A8 <REDDebugger.ab3@1310>     Else
000066D4 <REDDebugger.ab3@1311>       If yarrayoff+yarraynum+1 > array2 Then yarrayoff = array2-yarraynum
000066F0 <REDDebugger.ab3@1314>     Redraw #_winArray,#ARR_XGAD
0000670C <REDDebugger.ab3@1315>     Redraw #_winArray,#ARR_YGAD
0000671A <REDDebugger.ab3@1319>   w.w  = InnerWidth
00006728 <REDDebugger.ab3@1320>   hi.w = InnerHeight
0000672E <REDDebugger.ab3@1324>   Select arraylabelsize
0000673A <REDDebugger.ab3@1326>     Case 1
00006742 <REDDebugger.ab3@1327>       a.l = 2
00006754 <REDDebugger.ab3@1329>     Case 2
0000675C <REDDebugger.ab3@1330>       a   = 4
0000676E <REDDebugger.ab3@1332>     Case 3
00006776 <REDDebugger.ab3@1333>       a   = 8
00006778 <REDDebugger.ab3@1334>   End Select
0000678A <REDDebugger.ab3@1338>   WLocate 0,0
000067E0 <REDDebugger.ab3@1339>   NPrint String$(" ",arrayitemsize)
0000682C <REDDebugger.ab3@1341>   b$ = String$(" ",arrayitemsize-a)
00006862 <REDDebugger.ab3@1342>   For x.w = xarrayoff To xarrayoff+xarraynum
0000688E <REDDebugger.ab3@1343>     a$ = GetHex$(x,arraylabelsize)
000068F0 <REDDebugger.ab3@1344>     Print b$+a$
000068FE <REDDebugger.ab3@1346>   Next x
00006910 <REDDebugger.ab3@1347>   WLocate 0,8
00006946 <REDDebugger.ab3@1349>   For y.w = yarrayoff To yarrayoff+yarraynum
00006972 <REDDebugger.ab3@1350>     a$ = GetHex$(y,arraylabelsize)
000069D4 <REDDebugger.ab3@1352>     NPrint b$+a$
000069E2 <REDDebugger.ab3@1353>   Next y
000069E8 <REDDebugger.ab3@1356>   Select arraydatasize
000069F4 <REDDebugger.ab3@1358>     Case 1
000069FC <REDDebugger.ab3@1359>       a      = 2
00006A04 <REDDebugger.ab3@1360>       skip.l = 1
00006A16 <REDDebugger.ab3@1362>     Case 2
00006A1E <REDDebugger.ab3@1363>       a      = 4
00006A26 <REDDebugger.ab3@1364>       skip   = 2
00006A38 <REDDebugger.ab3@1366>     Case 3
00006A40 <REDDebugger.ab3@1367>       a      = 8
00006A48 <REDDebugger.ab3@1368>       skip   = 4
00006A4A <REDDebugger.ab3@1369>   End Select
00006A96 <REDDebugger.ab3@1371>   a$ = String$(" ",arrayitemsize-a)
00006AC8 <REDDebugger.ab3@1373>   ad.l = arrayadd+(xarrayoff*skip)+(yarrayoff*(array1+1)*skip)
00006AFE <REDDebugger.ab3@1374>   For y = yarrayoff To yarrayoff+yarraynum
00006B1E <REDDebugger.ab3@1375>     ad2.l = ad : ad+((array1+1)*skip)
00006B44 <REDDebugger.ab3@1377>     WLocate arrayitemsize*8,(y-yarrayoff+1)*8 ; change fontsize
00006B7A <REDDebugger.ab3@1378>     For x = xarrayoff To xarrayoff+xarraynum
00006BDC <REDDebugger.ab3@1379>       Print a$+GetHexAdr$(ad2,arraydatasize)
00006BEA <REDDebugger.ab3@1381>       ad2+skip
00006BF8 <REDDebugger.ab3@1382>     Next x
00006C06 <REDDebugger.ab3@1383>   Next y
00006C18 <REDDebugger.ab3@1386> End Statement
00006C32 <REDDebugger.ab3@1389> Statement RedrawSearchWin{ad.l}
00006C60 <REDDebugger.ab3@1392>   If (Peek.l(Addr Window(#_winSearch))=0) Then Statement Return
00006C76 <REDDebugger.ab3@1393>   Use Window #_winSearch
00006CC0 <REDDebugger.ab3@1395>   WLocate   4,04 : Print "Start address:"
00006D0A <REDDebugger.ab3@1396>   WLocate   4,18 : Print "End address  :"
00006D54 <REDDebugger.ab3@1398>   WLocate   4,38 : Print "Search value :"
00006D9E <REDDebugger.ab3@1399>   WLocate   4,52 : Print "Search type  :"
00006DB0 <REDDebugger.ab3@1400>   WLocate 190,52
00006E08 <REDDebugger.ab3@1401>   ad+(searchtype*7)-7 : Print Peek.s(ad)
00006E0C <REDDebugger.ab3@1402> End Statement
00006E22 <REDDebugger.ab3@1405> Statement RedrawCustomWin{}
00006E50 <REDDebugger.ab3@1407>   If (Peek.l(Addr Window(#_winCustom))=0) Then Statement Return
00006E66 <REDDebugger.ab3@1408>   Use Window #_winCustom
00006EB0 <REDDebugger.ab3@1410>   WLocate   4,04 : Print "Address$:"
00006EFA <REDDebugger.ab3@1411>   WLocate   4,18 : Print "Name    :"
00006EFC <REDDebugger.ab3@1412> End Statement
00006F12 <REDDebugger.ab3@1415> Statement UpdateDisCop{}
00006F40 <REDDebugger.ab3@1418>   If (Peek.l(Addr Window(#_winDisCop))=0) Then Statement Return
00006F66 <REDDebugger.ab3@1419>   Use Window #_winDisCop : Use BitMap 1
00006F88 <REDDebugger.ab3@1420>   w.w  = InnerWidth : If w > 320 Then w = 320
00006F96 <REDDebugger.ab3@1421>   hi.w = InnerHeight
00006FA8 <REDDebugger.ab3@1425>   WLocate 0,0
00006FAE <REDDebugger.ab3@1426>   ad.l = discop_ad
00006FF4 <REDDebugger.ab3@1427>   For h.w = 1 To (hi/WinFontHeight)
00006FFE <REDDebugger.ab3@1428>     If ad
00007060 <REDDebugger.ab3@1429>       NPrint Hex$(ad)+" "+GetCopIns$(ad)
0000706E <REDDebugger.ab3@1430>       ad+4
0000707C <REDDebugger.ab3@1432>   Next h
00007080 <REDDebugger.ab3@1435> End Statement
0000709A <REDDebugger.ab3@1438> Statement UpdateDisAsm{@clear.l}
000070BA <REDDebugger.ab3@1444>   If winstatus(#_winDisAsm) = 0 Then Statement Return
000070E8 <REDDebugger.ab3@1445>   If (Peek.l(Addr Window(#_winDisAsm)) = 0) Then Statement Return
000070F6 <REDDebugger.ab3@1447>   ad.l = Peek.l(MyBufferAddress)   ; replaced ASM code with BASIC  tomsmart1
00007100 <REDDebugger.ab3@1448>   If ad
0000711A <REDDebugger.ab3@1449>     pc.l = Peek.l(ad+64)-2
00007120 <REDDebugger.ab3@1452>   ad = disasm_ad
0000713A <REDDebugger.ab3@1453>   If ad < 4096 Then ad = 4096
00007150 <REDDebugger.ab3@1455>   Use Window #_winDisAsm
00007170 <REDDebugger.ab3@1456>   If tokenise = 1 Then bitm.w = 3 Else bitm = 1
00007180 <REDDebugger.ab3@1457>   Use BitMap bitm
00007196 <REDDebugger.ab3@1458>   inw.l   = InnerWidth  -1
000071AC <REDDebugger.ab3@1459>   inh.l   = InnerHeight -1
000071BA <REDDebugger.ab3@1460>   fonth.w = WinFontHeight
000071DE <REDDebugger.ab3@1462>   If clear = 1 Then InnerCls 2  ; clear/fill win with colour 2
000071EC <REDDebugger.ab3@1463>   WColour 1,2  ; set background colour
000071FE <REDDebugger.ab3@1464>   WLocate 0,1
00007236 <REDDebugger.ab3@1465>   For h.l = 0 To (inh/fonth)-1
0000725C <REDDebugger.ab3@1467>     If (ad < ProgramStart) OR (ad > (ProgramStart+ProgramSize) )
00007262 <REDDebugger.ab3@1468>       Statement Return
00007288 <REDDebugger.ab3@1470>     If (pc < ProgramStart) OR (pc > (ProgramStart+ProgramSize) )
0000728E <REDDebugger.ab3@1471>       Statement Return
000072B0 <REDDebugger.ab3@1473>     If ((ad-2) < ProgramStart) AND asmstep
000072B6 <REDDebugger.ab3@1474>       Statement Return
000072F8 <REDDebugger.ab3@1477>     outtxtStr.s = "$" + Hex$(ad)
00007306 <REDDebugger.ab3@1478>     If pc = ad
0000734C <REDDebugger.ab3@1479>       outtxtStr + "**>"
00007352 <REDDebugger.ab3@1480>     Else
00007398 <REDDebugger.ab3@1481>       outtxtStr + "   "
000073B2 <REDDebugger.ab3@1484>     If Peek.w(ad) = $4e41
000073C0 <REDDebugger.ab3@1485>       ad+2
000073CE <REDDebugger.ab3@1486>       ad2.l  = breakpoint_adr-8
000073D4 <REDDebugger.ab3@1487>       flag.w = 0
000073E8 <REDDebugger.ab3@1488>       While flag = 0
000073F6 <REDDebugger.ab3@1489>         ad2+8
00007404 <REDDebugger.ab3@1490>         break.l = Peek.l(ad2)
0000741C <REDDebugger.ab3@1491>         If break = ad Then flag = -1
00007434 <REDDebugger.ab3@1492>         If break = 0  Then flag = 1
0000743A <REDDebugger.ab3@1493>       Wend
0000744C <REDDebugger.ab3@1494>       If flag = -1
00007456 <REDDebugger.ab3@1495>         If asmstep
00007464 <REDDebugger.ab3@1496>           bt1.l = ad2-breakpoint_adr
00007472 <REDDebugger.ab3@1497>           bt1   = bt1+breakstore
00007480 <REDDebugger.ab3@1498>           ad-2
0000749E <REDDebugger.ab3@1499>           Poke.w ad,Peek.w(bt1)
000074B2 <REDDebugger.ab3@1501>         btype.w = Peek.w(ad2+4)
000074C0 <REDDebugger.ab3@1503>         If btype = #break_simple
0000753E <REDDebugger.ab3@1504>           outtxtStr + "["+Hexw$(Peek.w(ad2+6))+"]" ;: FInverse Off : ;Countdown
00007584 <REDDebugger.ab3@1505>           outtxtStr + " "
0000758A <REDDebugger.ab3@1506>         Else
00007598 <REDDebugger.ab3@1507>           If btype = #break_permanent
000075DE <REDDebugger.ab3@1508>             outtxtStr + "[*]" ;: FInverse Off :
00007624 <REDDebugger.ab3@1509>             outtxtStr + "    "
0000762A <REDDebugger.ab3@1510>           Else
000076A8 <REDDebugger.ab3@1511>             outtxtStr + "[="+Hexw$(Peek.w(ad2+6))+"]" ;Counter
000076AE <REDDebugger.ab3@1515>       Else
000076F4 <REDDebugger.ab3@1517>         outtxtStr + ">>>" ;: FInverse Off :
0000773A <REDDebugger.ab3@1518>         outtxtStr + "    "
0000775A <REDDebugger.ab3@1520>       If asmstep AND flag = -1
00007780 <REDDebugger.ab3@1521>         a$        = DisAssemble$(ad)
000077BC <REDDebugger.ab3@1522>         disStr(h) = a$
0000780E <REDDebugger.ab3@1523>         outtxtStr + a$
0000781C <REDDebugger.ab3@1524>         Poke.w ad,$4e41
00007836 <REDDebugger.ab3@1525>         ad+InstrSize
0000783C <REDDebugger.ab3@1526>       Else
00007882 <REDDebugger.ab3@1532>         outtxtStr + "Basic Token                     " ; it was the basic token
00007890 <REDDebugger.ab3@1533>         WColour 3,2   ;set draw colour to 3 (token colour)
0000789E <REDDebugger.ab3@1534>         ad+8
000078A4 <REDDebugger.ab3@1536>     Else
000078CA <REDDebugger.ab3@1537>       a$        = DisAssemble$(ad)
00007906 <REDDebugger.ab3@1538>       disStr(h) = a$
0000796A <REDDebugger.ab3@1539> 
00007984 <REDDebugger.ab3@1540>       ad+InstrSize
000079C2 <REDDebugger.ab3@1543>     outtxtleng.l = TextFit(outtxtStr,inw)    ; calc the chars we can print
000079D4 <REDDebugger.ab3@1544>     If outtxtleng>0                          ; test if we have space to print the string
000079F4 <REDDebugger.ab3@1545>       If FLen(outtxtStr)>outtxtleng          ; test is we have space to print the complete string
00007A44 <REDDebugger.ab3@1546>         outtxtStr=Left$(outtxtStr,outtxtleng); no , cut it down to the space we have
00007A88 <REDDebugger.ab3@1548>       NPrint outtxtStr
00007A8E <REDDebugger.ab3@1549>     Else
00007AA6 <REDDebugger.ab3@1550>       h= (inh/fonth)-1                       ; no can't print jump to the last to exit the loop
00007AB4 <REDDebugger.ab3@1552>     WColour 1,2  ; set to draw to colour 1 and background to 2
00007AC4 <REDDebugger.ab3@1553>   Next h
00007AD2 <REDDebugger.ab3@1554>   WColour 1,0  ; set colours back to defaults
00007AE4 <REDDebugger.ab3@1555> End Statement
00007AFA <REDDebugger.ab3@1558> Statement UpdateVarWindow{}
00007B28 <REDDebugger.ab3@1561>   If (Peek.l(Addr Window(#_winVariables) ) = 0) Then Statement Return
00007B3E <REDDebugger.ab3@1563>   Use Window #_winVariables
00007B4C <REDDebugger.ab3@1564>   fonth.w = WinFontHeight
00007B62 <REDDebugger.ab3@1565>   inw.l = InnerWidth              -1
00007B86 <REDDebugger.ab3@1566>   inh.l = InnerHeight-(fonth + 2) -1  ; get and calc the height, minus the 1 textline and the border
00007B96 <REDDebugger.ab3@1567>   Use BitMap 1
00007BD8 <REDDebugger.ab3@1568>   xpos.w = TextLength_(RastPort,"1234567890123456789",19) ; get the position to start with the print value
00007BE8 <REDDebugger.ab3@1569>   inw - xpos  ; to get the width of the window we can use to print the value
00007C0E <REDDebugger.ab3@1571>   If (inh > fonth) AND (inw > 0)  ; test if we have the height and the width to print the Values
00007C18 <REDDebugger.ab3@1572>     ResetList varinfo()
00007C28 <REDDebugger.ab3@1573>     mq.q = 0 : mf.f = 0
00007C30 <REDDebugger.ab3@1574>     count.l = 0
00007C42 <REDDebugger.ab3@1576>     While NextItem(varinfo())
00007C52 <REDDebugger.ab3@1577>       ad.l = varinfo()\address
00007C5C <REDDebugger.ab3@1578>       If ad
00007C6A <REDDebugger.ab3@1579>         count+1
00007C80 <REDDebugger.ab3@1580>         f.b = varinfo()\form
00007C98 <REDDebugger.ab3@1581>         Select varinfo()\typ
00007CA8 <REDDebugger.ab3@1583>           Case 1 ; BYTE
00007CB4 <REDDebugger.ab3@1584>             Select f
00007CC4 <REDDebugger.ab3@1586>               Case 0
00007D12 <REDDebugger.ab3@1587>                 a$ = Str$(Peek.b(ad)) + "  " ; added space to clear possible old value  tomsmart1 2016 02 05
00007D28 <REDDebugger.ab3@1589>               Case 1
00007D6E <REDDebugger.ab3@1590>                 a$ = "$"+GetHexAdr$(ad,1)
00007D84 <REDDebugger.ab3@1592>               Case 2
00007DCE <REDDebugger.ab3@1593>                 a$ = "%"+Binb$(Peek.b(ad))
00007DD0 <REDDebugger.ab3@1595>             End Select
00007DE6 <REDDebugger.ab3@1597>           Case 2 ; WORD
00007DF2 <REDDebugger.ab3@1598>             Select f
00007E02 <REDDebugger.ab3@1600>               Case 0
00007E4E <REDDebugger.ab3@1601>                 a$ = Str$(Peek.w(ad)) + "    "   ; added space to clear possible old value  tomsmart1 2016 02 05
00007E64 <REDDebugger.ab3@1603>               Case 1
00007EAA <REDDebugger.ab3@1604>                 a$ = "$"+GetHexAdr$(ad,2)
00007EC0 <REDDebugger.ab3@1606>               Case 2
00007F08 <REDDebugger.ab3@1607>                 a$ = "%"+Binw$(Peek.w(ad))
00007F0A <REDDebugger.ab3@1609>             End Select
00007F20 <REDDebugger.ab3@1611>           Case 3 ; LONGWORD
00007F2C <REDDebugger.ab3@1612>             Select f
00007F3C <REDDebugger.ab3@1614>               Case 0
00007F88 <REDDebugger.ab3@1615>                 a$ = Str$(Peek.l(ad)) + "         "  ; added space to clear possible old value  tomsmart1 2016 02 05
00007F9E <REDDebugger.ab3@1617>               Case 1
00007FE4 <REDDebugger.ab3@1618>                 a$ = "$"+GetHexAdr$(ad,3)
00007FFA <REDDebugger.ab3@1620>               Case 2
00008042 <REDDebugger.ab3@1621>                 a$ = "%"+Bin$(Peek.l(ad))
00008044 <REDDebugger.ab3@1623>             End Select
0000805A <REDDebugger.ab3@1625>           Case 4 ; STRING trace output
00008080 <REDDebugger.ab3@1626>             ssize.l    = Peek.l(Peek.l(ad)-4)
000080A6 <REDDebugger.ab3@1627>             smaxsize.l = Peek.l(Peek.l(ad)-8)
000080B6 <REDDebugger.ab3@1628>             If f = 1
0000818C <REDDebugger.ab3@1629>               a$ = "'" + Peek.s(Peek.l(ad)) +"' ["+Str$(ssize)+"/"+Str$(smaxsize)+"]"
00008192 <REDDebugger.ab3@1630>             Else
000081F8 <REDDebugger.ab3@1631>               a$ = "'" + Peek.s(Peek.l(ad)) + "'"
00008206 <REDDebugger.ab3@1633>             If smaxsize > ssize                   ; added tomsmart1
0000823A <REDDebugger.ab3@1634>               For times.l=1 To (smaxsize-ssize+3) ; to get the space to overwrite old Strings and sizeinfo
00008280 <REDDebugger.ab3@1635>                 a$ + " " ; added Space to overwrite/clear
00008290 <REDDebugger.ab3@1636>               Next
000082A6 <REDDebugger.ab3@1639>           Case 5 ; QUICK
000082C6 <REDDebugger.ab3@1640>             Poke.l &mq,Peek.l(ad)
000082FA <REDDebugger.ab3@1641>             a$ = Str$(mq)
00008310 <REDDebugger.ab3@1643>           Case 6 ; FLOAT
00008328 <REDDebugger.ab3@1644>             If winstatus(#fpuwin)
00008336 <REDDebugger.ab3@1645>               i = Peek.l(ad)
0000833A <REDDebugger.ab3@1646>               Dc.l $f2276800 ;fmove.x fp0,-(a7)
00008340 <REDDebugger.ab3@1647>               fmove.s i@(a4),fp0
00008346 <REDDebugger.ab3@1648>               JSR fpuffp
0000834A <REDDebugger.ab3@1649>               Dc.l $f21f4800
0000837E <REDDebugger.ab3@1651>               a$ = Str$(ffp)
00008384 <REDDebugger.ab3@1652>             Else
000083A4 <REDDebugger.ab3@1653>               Poke.l &mf,Peek.l(ad)
000083D8 <REDDebugger.ab3@1654>               a$ = Str$(mf)
000083DA <REDDebugger.ab3@1657>         End Select
000083F2 <REDDebugger.ab3@1659>         If (count*fonth) < inh           ; test if the position is in the window
00008430 <REDDebugger.ab3@1660>           outtxtleng.l = TextFit(a$,inw) ; calc the chars we can print
00008442 <REDDebugger.ab3@1661>           If outtxtleng >0               ; test if we have space to print the string
00008464 <REDDebugger.ab3@1662>             WLocate xpos,(count*fonth)+2 ; set the position to print the value
00008484 <REDDebugger.ab3@1663>             If FLen(a$)>outtxtleng       ; test is we have space to print the complete string
000084D4 <REDDebugger.ab3@1664>               a$=Left$(a$,outtxtleng)    ; no , cut it down to the space we have
00008518 <REDDebugger.ab3@1666>             NPrint a$
0000851E <REDDebugger.ab3@1667>           Else
00008528 <REDDebugger.ab3@1668>             LastItem varinfo()           ; no can't print jump to the last entry in the list to exit the loop
0000852E <REDDebugger.ab3@1670>         Else
00008538 <REDDebugger.ab3@1671>           LastItem varinfo()             ; no jump to the last entry in the list to exit the loop
0000853E <REDDebugger.ab3@1674>     Wend
00008550 <REDDebugger.ab3@1677> End Statement
00008566 <REDDebugger.ab3@1680> Statement RedrawVarWindow{}
00008594 <REDDebugger.ab3@1683>   If (Peek.l(Addr Window(#_winVariables)) = 0) Then Statement Return
000085AA <REDDebugger.ab3@1684>   Use Window #_winVariables
000085C0 <REDDebugger.ab3@1686>   inw.l   = InnerWidth  -1  ; -1 to get the right size to calculate
000085D6 <REDDebugger.ab3@1687>   inh.l   = InnerHeight -1  ;           "
000085E4 <REDDebugger.ab3@1688>   fonth.w = WinFontHeight
000085F4 <REDDebugger.ab3@1690>   Use BitMap 1
00008602 <REDDebugger.ab3@1691>   InnerCls
00008644 <REDDebugger.ab3@1692>   xpos.l = TextLength_(RastPort,"1234567890123456789",19) ; get the position to start with the print of the value
0000865C <REDDebugger.ab3@1695>   If  inh > fonth + 1 ; test if we have the height to print the status line
00008684 <REDDebugger.ab3@1696>     a$ = "Variable"
000086C2 <REDDebugger.ab3@1697>     outtxtleng.l = TextFit(a$,inw)
000086D4 <REDDebugger.ab3@1698>     WLocate 0,0
000086E6 <REDDebugger.ab3@1699>     If outtxtleng > 0           ; test if we have space width to print the string
00008706 <REDDebugger.ab3@1700>       If FLen(a$)>outtxtleng    ; test is we have space to print the complete string
00008756 <REDDebugger.ab3@1701>         a$=Left$(a$,outtxtleng) ; no , cut it down to the space width we have
0000879A <REDDebugger.ab3@1703>       Print a$
000087AC <REDDebugger.ab3@1704>       WLocate xpos,0
000087D4 <REDDebugger.ab3@1705>       a$ = "Value"
00008818 <REDDebugger.ab3@1706>       outtxtleng = TextFit(a$,inw-xpos)
0000882A <REDDebugger.ab3@1707>       If outtxtleng > 0           ; test if we have space width to print the string
0000884A <REDDebugger.ab3@1708>         If FLen(a$)>outtxtleng    ; test is we have space to print the complete string
0000889A <REDDebugger.ab3@1709>           a$=Left$(a$,outtxtleng) ; no , cut it down to the space width we have
000088DE <REDDebugger.ab3@1711>         Print a$
000088E4 <REDDebugger.ab3@1713>     Else
000088EA <REDDebugger.ab3@1714>       Statement Return
0000894E <REDDebugger.ab3@1718>     Wline WLeftOff, WTopOff + fonth, WLeftOff + inw, WTopOff + fonth, 1
00008966 <REDDebugger.ab3@1721>     WLocate 0,fonth+2
0000897C <REDDebugger.ab3@1722>     inh - (fonth+2)               ; reduce the innerheight, with the 1 textline and the borderline
00008984 <REDDebugger.ab3@1723>     count.l = 0
00008998 <REDDebugger.ab3@1724>     If inw < xpos Then xpos= inw  ; for the case the window are smaller then the value position
000089A2 <REDDebugger.ab3@1725>     ResetList varinfo()
000089B4 <REDDebugger.ab3@1727>     While NextItem(varinfo())
000089C2 <REDDebugger.ab3@1728>       count+1
000089DA <REDDebugger.ab3@1729>       If (count*fonth)<inh        ; test if we have space height to print
00008A5C <REDDebugger.ab3@1730>         a$ = "."+Mid$(objtype$,varinfo()\typ,1)   ; get type to print
00008B28 <REDDebugger.ab3@1731>         If a$ = ".s" AND Right$(varinfo()\name,1) = "$" Then a$ = ""  ; test if we have a String with $
00008B84 <REDDebugger.ab3@1732>         a$ = varinfo()\name+a$    ; generate the complette string with var name and type
00008BC2 <REDDebugger.ab3@1733>         outtxtleng = TextFit(a$,xpos)
00008BE2 <REDDebugger.ab3@1734>         If FLen(a$)>outtxtleng    ; test is we have space width to print the complete string
00008C32 <REDDebugger.ab3@1735>           a$=Left$(a$,outtxtleng) ; no , cut it down to the space we have
00008C76 <REDDebugger.ab3@1737>         NPrint a$
00008C7C <REDDebugger.ab3@1738>       Else
00008C86 <REDDebugger.ab3@1739>         LastItem varinfo()        ; no , jump to last entry to exit the loop
00008C8C <REDDebugger.ab3@1741>     Wend
00008C9E <REDDebugger.ab3@1744> End Statement
00008CB8 <REDDebugger.ab3@1747> Function.l GetStructVal{num.w}
00008CCC <REDDebugger.ab3@1750>   ad.l  = objwins()\typepointer
00008CE0 <REDDebugger.ab3@1751>   ads.l = objwins()\mem_type
00008D0A <REDDebugger.ab3@1752>   While Peek.b(ads) <> 0 AND num <> 0
00008D30 <REDDebugger.ab3@1753>     ad+Peek.w(ads+2)
00008D3E <REDDebugger.ab3@1754>     ads+4
00008D4A <REDDebugger.ab3@1755>     num-1
00008D50 <REDDebugger.ab3@1756>   Wend
00008D78 <REDDebugger.ab3@1758>   If Peek.w(ads) = 0 Then Function Return -1
00008D84 <REDDebugger.ab3@1760>   Select Peek.w(ads)
00008D90 <REDDebugger.ab3@1762>     Case 1
00008DA2 <REDDebugger.ab3@1763>       ad = Peek.b(ad)
00008DB4 <REDDebugger.ab3@1765>     Case 2
00008DC4 <REDDebugger.ab3@1766>       ad = Peek.w(ad)
00008DD6 <REDDebugger.ab3@1768>     Case 3
00008DE4 <REDDebugger.ab3@1769>       ad = Peek.l(ad)
00008DF6 <REDDebugger.ab3@1771>     Case 4
00008E04 <REDDebugger.ab3@1772>       ad = Peek.l(ad)
00008E06 <REDDebugger.ab3@1773>   End Select
00008E10 <REDDebugger.ab3@1774>   Function Return ad
00008E16 <REDDebugger.ab3@1775> End Function
00008E2C <REDDebugger.ab3@1779> Statement RefreshTypeWindow{}
00008E6A <REDDebugger.ab3@1786>   If (Peek.l(Addr Window(objwins()\winnum)) = 0) Then Statement Return
00008E8E <REDDebugger.ab3@1788>   Use Window objwins()\winnum
00008EA2 <REDDebugger.ab3@1789>   ad.l = objwins()\typepointer
00008EB6 <REDDebugger.ab3@1793>   typewidth.w = objwins()\typewidth
00008EC8 <REDDebugger.ab3@1794>   WLocate typewidth,0
00008ED8 <REDDebugger.ab3@1795>   inw.l = InnerWidth
00008EE8 <REDDebugger.ab3@1796>   inh.l = InnerHeight
00008EF8 <REDDebugger.ab3@1797>   Use BitMap 1
00008F40 <REDDebugger.ab3@1799>   WBox typewidth,WTopOff+1,inw-typewidth,inh AND %1111111111111000,0
00008F6A <REDDebugger.ab3@1800>   If ad OR objwins()\is_bbobject=0
00008FB2 <REDDebugger.ab3@1802>     WLocate typewidth,0 : NPrint Hex$(ad) ; change for fontsize
00008FC6 <REDDebugger.ab3@1803>     ads.l  = objwins()\mem_type
00008FCE <REDDebugger.ab3@1804>     defy.l = 10
00008FE8 <REDDebugger.ab3@1805>     While Peek.w(ads) <> 0
00008FFA <REDDebugger.ab3@1806>       WLocate typewidth,defy
00009008 <REDDebugger.ab3@1807>       defy+8
00009016 <REDDebugger.ab3@1808>       a.w = Peek.w(ads)
00009024 <REDDebugger.ab3@1809>       If a < 4
0000905E <REDDebugger.ab3@1811>         NPrint GetHexAdr$(ad,a)
00009064 <REDDebugger.ab3@1812>       Else
0000906A <REDDebugger.ab3@1813>         Select a
00009076 <REDDebugger.ab3@1815>           Case 4
00009112 <REDDebugger.ab3@1816>             If Peek.l(ad) <> 0 Then NPrint  PeekMax$(Peek.l(ad),80) Else NPrint  ""
00009124 <REDDebugger.ab3@1819>           Case 5 ; QUICK
00009144 <REDDebugger.ab3@1820>             Poke.l &mq,Peek.l(ad)
00009184 <REDDebugger.ab3@1822>             NPrint Str$(mq)
00009196 <REDDebugger.ab3@1824>           Case 6 ; FLOAT
000091B6 <REDDebugger.ab3@1825>             Poke.l &mf,Peek.l(ad)
000091F6 <REDDebugger.ab3@1827>             NPrint Str$(mf)
000091F8 <REDDebugger.ab3@1828>         End Select
0000921E <REDDebugger.ab3@1830>       ad+Peek.w(ads+2)
0000922C <REDDebugger.ab3@1831>       ads+4
00009232 <REDDebugger.ab3@1832>     Wend
00009238 <REDDebugger.ab3@1833>   Else
00009270 <REDDebugger.ab3@1834>     Print "No object found"
00009274 <REDDebugger.ab3@1839> End Statement
0000928E <REDDebugger.ab3@1842> Function.l FindBreakPoint{ad.l}
00009294 <REDDebugger.ab3@1845>   ad2.l  = breakpoint_adr
0000929C <REDDebugger.ab3@1846>   flag.l = 0
000092CC <REDDebugger.ab3@1847>   While Peek.l(ad2) <> 0 AND flag = 0
000092E6 <REDDebugger.ab3@1848>     If Peek.l(ad2) = ad
000092F2 <REDDebugger.ab3@1849>       flag = -1
000092F8 <REDDebugger.ab3@1850>     Else
00009306 <REDDebugger.ab3@1851>       ad2+8
0000930C <REDDebugger.ab3@1853>   Wend
00009326 <REDDebugger.ab3@1854>   If flag = 0 Then ad2 = 0
00009330 <REDDebugger.ab3@1855>   Function Return ad2
00009336 <REDDebugger.ab3@1856> End Function
00009350 <REDDebugger.ab3@1859> Statement RedrawMouseables{n.w}
0000937E <REDDebugger.ab3@1862>   If Peek.l(Addr Window(#_winMouseables))=0 Then Statement Return
000093A4 <REDDebugger.ab3@1863>   Use Window #_winMouseables : Use BitMap 1
000093B2 <REDDebugger.ab3@1864>   w.w  = InnerWidth
000093C0 <REDDebugger.ab3@1865>   hi.w = InnerHeight
000093D0 <REDDebugger.ab3@1866>   h.w  = hi ASR 3
000093E6 <REDDebugger.ab3@1868>   If n = True
0000940A <REDDebugger.ab3@1869>     SetPropInfo #_winMouseables,#MSE_SGAD,h,num_mouseables,mouseables_off
00009426 <REDDebugger.ab3@1870>     Redraw #_winMouseables,#MSE_SGAD
00009434 <REDDebugger.ab3@1874>   InnerCls
00009446 <REDDebugger.ab3@1875>   WLocate 0,0
0000944C <REDDebugger.ab3@1877>   y.w  = 0
00009452 <REDDebugger.ab3@1878>   ad.l = mouseables
0000945C <REDDebugger.ab3@1879>   If mouseables_off
0000948A <REDDebugger.ab3@1880>     For loop.w = 1 To mouseables_off
000094A2 <REDDebugger.ab3@1881>       If ad Then ad = Peek.l(ad)
000094B0 <REDDebugger.ab3@1882>     Next loop
000094C2 <REDDebugger.ab3@1885>   If ad <> 0
000094E4 <REDDebugger.ab3@1886>     While y < h AND y < num_mouseables
00009502 <REDDebugger.ab3@1887>       If ad Then ad2.l = Peek.l(ad+4)
00009532 <REDDebugger.ab3@1888>       If ad2 Then a$ = ExtractLabel(ad2)
00009576 <REDDebugger.ab3@1889>       NPrint a$
00009584 <REDDebugger.ab3@1890>       y+1
0000959C <REDDebugger.ab3@1891>       If ad Then ad = Peek.l(ad)
000095A2 <REDDebugger.ab3@1892>     Wend
000095B4 <REDDebugger.ab3@1895> End Statement
000095CA <REDDebugger.ab3@1898> Statement GetCustomMenus{}
0000965E <REDDebugger.ab3@1901>   If ReadFile(0,dos_AddPart{my_path$,"REDDebugger.menus"} ) ; change path
00009694 <REDDebugger.ab3@1902>     GTMenuTitle 0,4,"Custom"
000096A8 <REDDebugger.ab3@1903>     FileInput 0
000096B0 <REDDebugger.ab3@1904>     n.l = 0
000096D8 <REDDebugger.ab3@1906>       a$ = Edit$(256)
00009710 <REDDebugger.ab3@1907>       If a$ <> ""
0000973C <REDDebugger.ab3@1908>         D_InitParse a$
0000975E <REDDebugger.ab3@1909>         b$   = D_NextArg$
00009780 <REDDebugger.ab3@1910>         typ$ = D_NextArg$
000097A2 <REDDebugger.ab3@1911>         s$   = D_NextArg$
000097CC <REDDebugger.ab3@1912>         customcomm$(n) = D_NextArg$
000097F6 <REDDebugger.ab3@1913>         customcomm$(n) = D_NextArg$
00009862 <REDDebugger.ab3@1914>         If s$ = Chr$(126) Then s$ = ""
000098A6 <REDDebugger.ab3@1915>         If b$ <> Chr$(126)
00009914 <REDDebugger.ab3@1916>           GTMenuItem 0,0,4,n,b$,s$
0000991A <REDDebugger.ab3@1917>         Else
0000993A <REDDebugger.ab3@1918>           GTMenuItem 0,0,4,n
00009948 <REDDebugger.ab3@1920>         n+1
0000997A <REDDebugger.ab3@1922>     Until Eof(0) OR n = #MAXCUSTOMCOMMANDS
00009980 <REDDebugger.ab3@1923>     PopInput
00009998 <REDDebugger.ab3@1924>     CloseFile 0
000099AA <REDDebugger.ab3@1926> End Statement
000099C0 <REDDebugger.ab3@1929> Statement InitRegsWin{}
00009A04 <REDDebugger.ab3@1932>   If winstatus(#_winRegisters) AND (Peek.l(Addr Window(#_winRegisters) ) >< 0)
00009A1A <REDDebugger.ab3@1933>     Use Window #_winRegisters
00009A28 <REDDebugger.ab3@1934>     InnerCls
00009A40 <REDDebugger.ab3@1935>     *rp.RastPort = RastPort(#_winRegisters)
00009A56 <REDDebugger.ab3@1936>     inw.l   = InnerWidth  -1
00009A6C <REDDebugger.ab3@1937>     inh.l   = InnerHeight -1
00009A7A <REDDebugger.ab3@1938>     fonth.w = WinFontHeight
00009A88 <REDDebugger.ab3@1939>     iy.w    = WTopOff
00009A96 <REDDebugger.ab3@1940>     ix.w    = WLeftOff
00009AD2 <REDDebugger.ab3@1941>     textlen.w=TextLength_(*rp," ",1) ; this works only for nonproportional fonts !
00009AE4 <REDDebugger.ab3@1942>     maxcharperline.l = inw/textlen
00009B0A <REDDebugger.ab3@1943>     If (inh > fonth) AND (maxcharperline >= 4) ; test if we have the heigth and weidth to print something
00009B18 <REDDebugger.ab3@1944>       OutTextPen *rp,1
00009B28 <REDDebugger.ab3@1945>       y.l = iy+1
00009B52 <REDDebugger.ab3@1946>       For h.l = 0 To 7
00009B72 <REDDebugger.ab3@1947>         If inh >= (fonth*(h+1))     ; test if we have the height to print the line
00009BE4 <REDDebugger.ab3@1949>           OutText ix           ,y,*rp,"d"+Str$(h)+"=$"
00009BF6 <REDDebugger.ab3@1950>           If maxcharperline >= (4+8)
00009C08 <REDDebugger.ab3@1953>             If maxcharperline >= (20+4)
00009C88 <REDDebugger.ab3@1954>               OutText ix+20*textlen,y,*rp,"a"+Str$(h)+"=$"
00009C9A <REDDebugger.ab3@1955>               If maxcharperline >= (24+8)
00009CAA <REDDebugger.ab3@1960>           y + fonth
00009CB0 <REDDebugger.ab3@1961>         Else
00009CB8 <REDDebugger.ab3@1962>           h = 7
00009CC8 <REDDebugger.ab3@1964>       Next h
00009CE2 <REDDebugger.ab3@1965>       If inh >= (fonth*9)     ; test if we have the height to print the line
00009D1A <REDDebugger.ab3@1967>         OutText ix           ,y,*rp,"sr=$"
00009D2C <REDDebugger.ab3@1968>         If maxcharperline >= (4+4)
00009D3E <REDDebugger.ab3@1970>           If maxcharperline >= (13+5)
00009D84 <REDDebugger.ab3@1971>             OutText ix+13*textlen,y,*rp,"-----"
00009D96 <REDDebugger.ab3@1973>             If maxcharperline >= (19+5)
00009DDC <REDDebugger.ab3@1974>               OutText ix+19*textlen,y,*rp,"BPC=$"
00009DE0 <REDDebugger.ab3@1986> End Statement
00009DF6 <REDDebugger.ab3@1990> Statement RedrawRegs{}
00009E3A <REDDebugger.ab3@1994>   If winstatus(#_winRegisters) AND (Peek.l(Addr Window(#_winRegisters) ) >< 0)
00009E48 <REDDebugger.ab3@1995>     ad.l = Peek.l(MyBufferAddress)
00009E52 <REDDebugger.ab3@1996>     If ad
00009E68 <REDDebugger.ab3@1997>       Use Window #_winRegisters
00009E80 <REDDebugger.ab3@1998>       *rp.RastPort = RastPort(#_winRegisters)
00009E96 <REDDebugger.ab3@1999>       inw.l   = InnerWidth  -1
00009EAC <REDDebugger.ab3@2000>       inh.l   = InnerHeight -1
00009EBA <REDDebugger.ab3@2001>       fonth.w = WinFontHeight
00009EC8 <REDDebugger.ab3@2003>       iy.w    = WTopOff
00009ED6 <REDDebugger.ab3@2004>       ix.w    = WLeftOff
00009F12 <REDDebugger.ab3@2005>       textlen.w = TextLength_(*rp," ",1)  ; this works only for nonproportional fonts !
00009F24 <REDDebugger.ab3@2006>       maxcharperline.l = inw/textlen
00009F50 <REDDebugger.ab3@2007>       If (inh > fonth+1) AND (maxcharperline >= (4+8) ) ; test if we have the heigth and weidth to print something
00009F60 <REDDebugger.ab3@2008>         y.l = iy+1
00009F8A <REDDebugger.ab3@2009>         For h.l = 0 To 7
00009FAA <REDDebugger.ab3@2010>           If inh >= (fonth*(h+1))     ; test if we have the height to print the line
00009FB8 <REDDebugger.ab3@2012>             dreg.l = Peek.l(ad)         ; get address of the first data register
0000A006 <REDDebugger.ab3@2013>             OutText ix + 4*textlen,y,*rp,Hex$(dreg)
0000A018 <REDDebugger.ab3@2014>             If maxcharperline >= (13+4)
0000A028 <REDDebugger.ab3@2015>               D_CheckNMoveA ad,&regdStr
0000A07A <REDDebugger.ab3@2016>               OutText ix + 13*textlen,y,*rp,regdStr
0000A08C <REDDebugger.ab3@2018>               If maxcharperline >= (24+8)
0000A0A0 <REDDebugger.ab3@2020>                 areg.l = Peek.l(ad+32)  ; get address of the first address register
0000A0EE <REDDebugger.ab3@2021>                 OutText ix+24*textlen,y,*rp,Hex$(areg)
0000A100 <REDDebugger.ab3@2023>                 If OSVersion = #AmigaOS3        ; added to prevent Hits  with AmigaOS4 and maybe MorphOS
0000A112 <REDDebugger.ab3@2024>                   If maxcharperline >= (33+46)
0000A124 <REDDebugger.ab3@2026>                     If areg > #lowestaddr
0000A138 <REDDebugger.ab3@2029>                         D_HexWord areg,&regaStr,6
0000A152 <REDDebugger.ab3@2031>                         D_CheckNMoveA areg,&regaStr+31,3
0000A1A4 <REDDebugger.ab3@2032>                       OutText ix + 33*textlen,y,*rp,regaStr
0000A1B2 <REDDebugger.ab3@2041>             ad + 4     ; go to next register 4 bytes = 1Long
0000A1C2 <REDDebugger.ab3@2042>             y + fonth  ; vertical step for
0000A1C8 <REDDebugger.ab3@2043>           Else
0000A1D0 <REDDebugger.ab3@2044>             h = 7      ; we have not the height to print the line we have to end the loop
0000A1E0 <REDDebugger.ab3@2046>         Next h
0000A1FA <REDDebugger.ab3@2058>         If inh >= (fonth*9)     ; test if we have the height to print the line
0000A214 <REDDebugger.ab3@2059>           mysr.w = Peek.w(ad+32+4)
0000A262 <REDDebugger.ab3@2060>           OutText ix + 4*textlen,y,*rp,Hexw$(mysr)
0000A274 <REDDebugger.ab3@2061>           If maxcharperline >= (13+5)
0000A284 <REDDebugger.ab3@2062>             D_GetSR &srStr,mysr
0000A2D6 <REDDebugger.ab3@2063>             OutText ix + 13*textlen,y,*rp,srStr
0000A2E8 <REDDebugger.ab3@2064>             If maxcharperline >= (24+8)
0000A2FC <REDDebugger.ab3@2066>               areg = Peek.l(ad+32) ; Get program counter
0000A350 <REDDebugger.ab3@2067>               OutText ix + 24*textlen,y,*rp,Hex$(areg-2)
0000A358 <REDDebugger.ab3@2075>   fpuneedupdate = 6
0000A35C <REDDebugger.ab3@2076> End Statement
0000A376 <REDDebugger.ab3@2079> Statement DrawMem{number.b}
0000A39E <REDDebugger.ab3@2082>   If Peek.l(Addr Window(#_winMemory1+number) )
0000A3B4 <REDDebugger.ab3@2083>     inw.l   = InnerWidth  -1
0000A3CA <REDDebugger.ab3@2084>     inh.l   = InnerHeight -1
0000A3D8 <REDDebugger.ab3@2085>     fonth.w = WinFontHeight
0000A3E6 <REDDebugger.ab3@2086>     iy.w    = WTopOff
0000A3F4 <REDDebugger.ab3@2087>     ix.w    = WLeftOff
0000A416 <REDDebugger.ab3@2089>     *rp.RastPort = RastPort(#_winMemory1+number)
0000A464 <REDDebugger.ab3@2090>     w.l  = (inw/TextLength_(*rp,"$1",1) ) ; calc the max char
0000A476 <REDDebugger.ab3@2091>     If w >= (10 + 7)  ;address + word hexvalue + space + two ASCII chars
0000A484 <REDDebugger.ab3@2092>       w-10  ; - the size of the address '$xxxxxxxx '
0000A4C8 <REDDebugger.ab3@2093>       a$ = String$(" ",w)
0000A4DA <REDDebugger.ab3@2094>       w/7  ; calc how many values to show in one line for (word hexvalue + space + two ASCII chars)
0000A4F0 <REDDebugger.ab3@2095>       ad.l = mempointer(number)
0000A4FA <REDDebugger.ab3@2096>       If ad
0000A540 <REDDebugger.ab3@2097>         WTitle "$" + Hex$(ad)
0000A55E <REDDebugger.ab3@2098>         ad2.l = &a$ + (w*5) + 1
0000A56C <REDDebugger.ab3@2099>         OutTextPen *rp,1
0000A57C <REDDebugger.ab3@2100>         y.l = iy +1
0000A5B4 <REDDebugger.ab3@2101>         For h.l = 0 To (inh/fonth)-1
0000A5C8 <REDDebugger.ab3@2102>           D_HexWord ad,&a$,w
0000A5DA <REDDebugger.ab3@2103>           D_CheckNMoveWord ad,ad2,w
0000A65C <REDDebugger.ab3@2104>           OutText ix,y,*rp,"$" + Hex$(ad) + " " + a$
0000A6AC <REDDebugger.ab3@2105>           memStr(h) = "$" + Hex$(Peek.l(ad) )
0000A6BC <REDDebugger.ab3@2106>           y + fonth
0000A6D2 <REDDebugger.ab3@2107>           ad + (w ASL 1)
0000A6E2 <REDDebugger.ab3@2108>         Next h
0000A6F4 <REDDebugger.ab3@2112> End Statement
0000A70A <REDDebugger.ab3@2115> Statement RedrawMem{}
0000A772 <REDDebugger.ab3@2117>   If winstatus(#_winMemory1) AND (dowin = 0 OR dowin = -1) AND (Peek.l(Addr Window(#_winMemory1)) >< 0)
0000A788 <REDDebugger.ab3@2118>     Use Window #_winMemory1
0000A78E <REDDebugger.ab3@2119>     num.b = 0
0000A79A <REDDebugger.ab3@2120>     DrawMem{num}
0000A802 <REDDebugger.ab3@2123>   If winstatus(#_winMemory2) AND (dowin = 1 OR dowin = -1) AND (Peek.l(Addr Window(#_winMemory2)) >< 0)
0000A818 <REDDebugger.ab3@2124>     Use Window #_winMemory2
0000A81E <REDDebugger.ab3@2125>     num = 1
0000A82A <REDDebugger.ab3@2126>     DrawMem{num}
0000A834 <REDDebugger.ab3@2129>   dowin = -1
0000A838 <REDDebugger.ab3@2130> End Statement
0000A844 <REDDebugger.ab3@2136>   AddIDCMP #IDCMP_MENUHELP
0000A866 <REDDebugger.ab3@2138>     If (Maximum Window) < 25 OR (Maximum GadgetList) < 25
0000A8A0 <REDDebugger.ab3@2139>       error{"Object Maximums too small\\nIncrease Window and  Gadgetlist Objectsize >25"}
0000A8A6 <REDDebugger.ab3@2140>       End
0000A93E <REDDebugger.ab3@2143>   my_path$ = dos_GetProgDir{dos_AddPart{default_assign$,"Debug"} }
0000A962 <REDDebugger.ab3@2146>   Dim GTags.TagItem(4) ; -- Tags for getting the size gadget image
0000A9A2 <REDDebugger.ab3@2147>   If Used Screen < 0 Then WbToScreen 0
0000A9D0 <REDDebugger.ab3@2148>   *wbscreen.Screen = Peek.l(Addr Screen(Used Screen))
0000A9E2 <REDDebugger.ab3@2149>   If *wbscreen <> 0
0000A9FA <REDDebugger.ab3@2150>     ScreenBarHeight   = *wbscreen\BarHeight + 1
0000AA28 <REDDebugger.ab3@2151>     ScreenFontNameStr = Peek.s(*wbscreen\Font\ta_Name)
0000AA3C <REDDebugger.ab3@2152>     ScreenFontYSize   = *wbscreen\Font\ta_YSize
0000AA4E <REDDebugger.ab3@2153>     WinBorTop         = *wbscreen\WBorTop
0000AA62 <REDDebugger.ab3@2154>     WinBorTextTop     = WinBorTop + ScreenFontYSize + 1
0000AA74 <REDDebugger.ab3@2155>     WinBorLeft        = *wbscreen\WBorLeft
0000AA86 <REDDebugger.ab3@2156>     WinBorRight       = *wbscreen\WBorRight
0000AA98 <REDDebugger.ab3@2157>     WinBorBottom      = *wbscreen\WBorBottom
0000AAAC <REDDebugger.ab3@2160>     *drawinfo.DrawInfo = GetScreenDrawInfo_(*wbscreen)
0000AAB6 <REDDebugger.ab3@2161>     If *drawinfo
0000AACE <REDDebugger.ab3@2162>       If (*wbscreen\Flags & #SCREENHIRES)
0000AAD6 <REDDebugger.ab3@2163>         sis.l=#SYSISIZE_HIRES
0000AADC <REDDebugger.ab3@2164>       Else
0000AAE4 <REDDebugger.ab3@2165>         sis  =#SYSISIZE_MEDRES
0000AB04 <REDDebugger.ab3@2167>       GTags(0)\ti_Tag = #SYSIA_DrawInfo,*drawinfo
0000AB26 <REDDebugger.ab3@2168>       GTags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
0000AB46 <REDDebugger.ab3@2169>       GTags(2)\ti_Tag = #SYSIA_Size,sis
0000AB5C <REDDebugger.ab3@2170>       GTags(3)\ti_Tag = #TAG_DONE
0000ABA4 <REDDebugger.ab3@2171>       *img.Image = NewObjectA_(0,"sysiclass",&GTags(0))
0000ABAE <REDDebugger.ab3@2172>       If *img
0000ABBE <REDDebugger.ab3@2173>         WinSizeBorRight  = *img\Width
0000ABCE <REDDebugger.ab3@2174>         WinSizeBorBottom = *img\Height
0000ABDE <REDDebugger.ab3@2175>         DisposeObject_ *img
0000ABF6 <REDDebugger.ab3@2177>       FreeScreenDrawInfo_ *wbscreen,*drawinfo
0000AC24 <REDDebugger.ab3@2182>   If FindPort_("REXX")
0000AC4C <REDDebugger.ab3@2183>     arexxport = RXCreatePort("DEBUGGER.PRIVATE")
0000AC52 <REDDebugger.ab3@2184>   Else
0000AC5A <REDDebugger.ab3@2185>     arexxport = 0
0000AC5C <REDDebugger.ab3@2187> Return
0000AC62 <REDDebugger.ab3@2191>   ClearProcessPtrs
0000AC8A <REDDebugger.ab3@2192>   debug_pathname$      = ""          ; added rest to defaults  tomsmart1 2016 02 08
0000AC92 <REDDebugger.ab3@2193>   debug_pathname_Ptr.l = 0
0000ACBA <REDDebugger.ab3@2194>   debug_filename$      = ""
0000ACC2 <REDDebugger.ab3@2195>   debug_filename_Ptr.l = 0
0000ACC8 <REDDebugger.ab3@2196>   num_mouseables       = 0
0000ACD0 <REDDebugger.ab3@2197>   mouseables           = 0
0000ACD8 <REDDebugger.ab3@2198>   *TokenBase_Pointer.l = 0
0000ACDE <REDDebugger.ab3@2199>   CLR.l programsize
0000ACE4 <REDDebugger.ab3@2200>   CLR.l programstart
0000ACEA <REDDebugger.ab3@2201>   CLR.l trap15addr
0000ACF0 <REDDebugger.ab3@2202> 
0000ACF6 <REDDebugger.ab3@2203>   CLR.l comdata
0000AD0A <REDDebugger.ab3@2205>   If ted_OpenLib{0}
0000AD14 <REDDebugger.ab3@2206>     *ComData_Pointer = TEDGetJumpTable{}
0000AD26 <REDDebugger.ab3@2207>     If *ComData_Pointer <> 0            ; added a check if we get the pointer  tomsmart1 2012 07 12
0000AD2A <REDDebugger.ab3@2208>       GetD0 *ComData_Pointer
0000AD30 <REDDebugger.ab3@2209>       MOVE.l d0,comdata                 ; store the pointer form the basic variable to the comdata table  tomsmart1
0000AD6E <REDDebugger.ab3@2211>       !ComData_GetL{comData_Magic,D0}   ; get the idenifier
0000AD72 <REDDebugger.ab3@2212>       magic.l = PutD0
0000AD84 <REDDebugger.ab3@2213>       If magic = #MagicIdentifier_Long  ; Replaced "~::~" with a constant and changed flow  tomsmart1 2012 07 12
0000ADC8 <REDDebugger.ab3@2214> 
0000ADCC <REDDebugger.ab3@2215>         ComDataVersion.l = PutD0                     ;
0000ADDE <REDDebugger.ab3@2216>         If ComDataVersion = #ComDataVersionID        ;
0000AE0C <REDDebugger.ab3@2217>           !ComData_LEA{comLong_NewDebug,A0}
0000AE12 <REDDebugger.ab3@2218>           CMP.l #"newd",(A0)
0000AE16 <REDDebugger.ab3@2219>           BNE 'l1
0000AE58 <REDDebugger.ab3@2220>           !ComData_GetL{comPtr_Trap15,trap15addr}
0000AE60 <REDDebugger.ab3@2221>           MOVE.b #1,newdebug
0000AE9E <REDDebugger.ab3@2224>           !ComData_GetL{comPtr_DirectBuffer,A0}
0000AEA4 <REDDebugger.ab3@2225>           MOVE.l #direktbuffer,(a0)
0000AEE6 <REDDebugger.ab3@2229>           !ComData_GetL{comPtr_TokenBase,D0}     : *TokenBase_Pointer = PutD0 ; set token base pointer
0000AF24 <REDDebugger.ab3@2231> 
0000AF2A <REDDebugger.ab3@2232>           MOVE.l a0,programsize                    ;
0000AF68 <REDDebugger.ab3@2233>           !ComData_GetL{comPtr_DestBufferStart,A0}
0000AF6E <REDDebugger.ab3@2234>           MOVE.l a0,programstart
0000AF7E <REDDebugger.ab3@2236>           ProgramStart.l=Peek.l(?programstart)
0000AF8E <REDDebugger.ab3@2237>           ProgramSize .l=Peek.l(?programsize)
0000AFD0 <REDDebugger.ab3@2239>           !ComData_GetL{comPtr_LabelList    ,d0} : mouseables = PutD0
0000B018 <REDDebugger.ab3@2240>           !ComData_GetW{comWord_LabelCounter,d0} : num_mouseables = PutD0
0000B082 <REDDebugger.ab3@2241>           !ComData_GetL{comPtr_SourceName   ,d0} : debug_filename_Ptr = PutD0 : debug_filename$ = Peek.s(debug_filename_Ptr)
0000B0EC <REDDebugger.ab3@2242>           !ComData_GetL{comPtr_CurrentDir   ,d0} : debug_pathname_Ptr = PutD0 : debug_pathname$ = Peek.s(debug_pathname_Ptr)
0000B16C <REDDebugger.ab3@2243>           debug_pathspec$ = dos_AddPart{debug_pathname$,debug_filename$}
0000B196 <REDDebugger.ab3@2244>           AddProcessPtr "f",&debug_filename$
0000B1C0 <REDDebugger.ab3@2245>           AddProcessPtr "d",&debug_pathname$
0000B1EA <REDDebugger.ab3@2246>           AddProcessPtr "F",&debug_pathspec$
0000B1F0 <REDDebugger.ab3@2247>         Else ; comdata version id
0000B22A <REDDebugger.ab3@2248>           error{"comdata structure version does not match!"}
0000B230 <REDDebugger.ab3@2250>       Else ;Magicidenifer
0000B26A <REDDebugger.ab3@2251>         error{"Invalid comdata structure!"}
0000B270 <REDDebugger.ab3@2253>     Else ; *ComData_Pointer
0000B2AA <REDDebugger.ab3@2254>       error{"No comdata structure available!"}
0000B2B0 <REDDebugger.ab3@2256>   Else ; ted_OpenLib
0000B2EA <REDDebugger.ab3@2257>     error{"No ted.library,Old Debugger!?"}
0000B2F4 <REDDebugger.ab3@2260>   MyBufferAddress = ?mybuffer
0000B2FA <REDDebugger.ab3@2261>   Gosub openwindow
0000B30C <REDDebugger.ab3@2263>   FillMem ?breakpoint,5*8
0000B318 <REDDebugger.ab3@2265>     d_sethandler{&procstatus}
0000B326 <REDDebugger.ab3@2268>   SetupLESDebug token_addr,tokenise
0000B32C <REDDebugger.ab3@2269>   RedrawMem{}
0000B332 <REDDebugger.ab3@2272>   exitflag = 0
0000B33C <REDDebugger.ab3@2273>   end_init = -1
0000B348 <REDDebugger.ab3@2277>     d_sethandler{&procstatus}
0000B34E <REDDebugger.ab3@2278>     Gosub getevent
0000B35A <REDDebugger.ab3@2279>     gad.l   = GadgetHit
0000B37C <REDDebugger.ab3@2280>     i$      = Inkey$
0000B388 <REDDebugger.ab3@2281>     evq     = EventQualifier
0000B394 <REDDebugger.ab3@2282>     evw     = EventWindow
0000B3A4 <REDDebugger.ab3@2283>     kbshift = evq AND %11
0000B3B6 <REDDebugger.ab3@2285>     If ev = 256
0000B3F4 <REDDebugger.ab3@2286>       On MenuHit+1 Gosub domenu0,domenu1,domenu2,domenu3,domenu4
0000B40C <REDDebugger.ab3@2289>     If ev = 8 Then Gosub MousePress
0000B41E <REDDebugger.ab3@2290>     If ev = 1024 ; Rawkey for gadgets
0000B424 <REDDebugger.ab3@2291>       flag = 0
0000B42E <REDDebugger.ab3@2292>       ec.l = EventCode
0000B434 <REDDebugger.ab3@2294>       Select ec
0000B442 <REDDebugger.ab3@2296>         Case $21
0000B448 <REDDebugger.ab3@2297>           gosubstatus = 0
0000B44E <REDDebugger.ab3@2298>           procstatus  = 0
0000B454 <REDDebugger.ab3@2299>           flag        = 2
0000B45C <REDDebugger.ab3@2300>           skip.l      = 0
0000B462 <REDDebugger.ab3@2301>           FlushEvents
0000B476 <REDDebugger.ab3@2303>         Case $22 ; key d
0000B47C <REDDebugger.ab3@2304>           flag        = 2
0000B484 <REDDebugger.ab3@2305>           skip        = 1
0000B48A <REDDebugger.ab3@2306>           gosubstatus = 1
0000B490 <REDDebugger.ab3@2307>           procstatus  = 1
0000B496 <REDDebugger.ab3@2308>           FlushEvents
0000B4AA <REDDebugger.ab3@2310>         Case $17
0000B4B0 <REDDebugger.ab3@2311>           flag = 3
0000B4C4 <REDDebugger.ab3@2313>         Case $14
0000B4CA <REDDebugger.ab3@2314>           flag = 4
0000B4DE <REDDebugger.ab3@2316>         Case $13
0000B4E4 <REDDebugger.ab3@2317>           flag = 5
0000B4F8 <REDDebugger.ab3@2319>         Case $38
0000B4FE <REDDebugger.ab3@2320>           flag = 6
0000B512 <REDDebugger.ab3@2322>         Case $39
0000B518 <REDDebugger.ab3@2323>           flag = 7
0000B52C <REDDebugger.ab3@2325>         Case $32
0000B532 <REDDebugger.ab3@2326>           flag = 8
0000B546 <REDDebugger.ab3@2328>         Case $12
0000B54C <REDDebugger.ab3@2329>           flag = 9
0000B560 <REDDebugger.ab3@2331>         Case $34
0000B566 <REDDebugger.ab3@2332>           flag = 10
0000B568 <REDDebugger.ab3@2333>       End Select
0000B576 <REDDebugger.ab3@2334>       If flag
0000B592 <REDDebugger.ab3@2335>         gad = flag : ev = 64 : evw = #_winControl
0000B598 <REDDebugger.ab3@2340>     Select ev
0000B5A6 <REDDebugger.ab3@2342>       Case 2 ; newsize
0000B5BA <REDDebugger.ab3@2345>       Case 4 ; refresh
0000B5C0 <REDDebugger.ab3@2346>         Gosub CorruptWindow
0000B5D4 <REDDebugger.ab3@2348>       Case 32
0000B5F2 <REDDebugger.ab3@2349>         If (#gadgetdown BitTst evw) Then Gosub GadgetDown
0000B606 <REDDebugger.ab3@2351>       Case 64 ; gadget up
0000B61E <REDDebugger.ab3@2352>         If evw = #_winControl Then Gosub SourceGadgets
0000B636 <REDDebugger.ab3@2353>         If evw = #_winSearch  Then Gosub SearchGadgets
0000B64E <REDDebugger.ab3@2354>         If evw = #_winCustom  Then Gosub CustomGadgets
0000B662 <REDDebugger.ab3@2356>       Case 512 ;**CLOSE WINDOW**
0000B66C <REDDebugger.ab3@2357>         flag = -1
0000B672 <REDDebugger.ab3@2358>         Gosub RemoveWindow
0000B686 <REDDebugger.ab3@2360>       Case 1024 ;**RAWKEY CHECK ON WINDOW**
0000B68C <REDDebugger.ab3@2361>         Gosub CheckKeyboard
0000B6A0 <REDDebugger.ab3@2363>       Case #IDCMP_ACTIVEWINDOW
0000B6B6 <REDDebugger.ab3@2364>         Use Window evw
0000B6BC <REDDebugger.ab3@2365>         old_active_win = active_win
0000B6C4 <REDDebugger.ab3@2366>         active_win     = evw
0000B6D8 <REDDebugger.ab3@2368>       Case #IDCMP_IDCMPUPDATE
0000B6EE <REDDebugger.ab3@2369>         Use Window evw
0000B716 <REDDebugger.ab3@2370>         Select WZGadName
0000B73A <REDDebugger.ab3@2372>           Case "fpr00"
0000B748 <REDDebugger.ab3@2373>             temp.l = 0 : Gosub setfpu
0000B772 <REDDebugger.ab3@2375>           Case "fpr01"
0000B780 <REDDebugger.ab3@2376>             temp = 1 : Gosub setfpu
0000B7AA <REDDebugger.ab3@2378>           Case "fpr02"
0000B7B8 <REDDebugger.ab3@2379>             temp = 2 : Gosub setfpu
0000B7E2 <REDDebugger.ab3@2381>           Case "fpr03"
0000B7F0 <REDDebugger.ab3@2382>             temp = 3 : Gosub setfpu
0000B81A <REDDebugger.ab3@2384>           Case "fpr04"
0000B828 <REDDebugger.ab3@2385>             temp = 4 : Gosub setfpu
0000B852 <REDDebugger.ab3@2387>           Case "fpr05"
0000B860 <REDDebugger.ab3@2388>             temp = 5 : Gosub setfpu
0000B88A <REDDebugger.ab3@2390>           Case "fpr06"
0000B898 <REDDebugger.ab3@2391>             temp = 6 : Gosub setfpu
0000B8C2 <REDDebugger.ab3@2393>           Case "fpr07"
0000B8D0 <REDDebugger.ab3@2394>             temp = 7 : Gosub setfpu
0000B8DE <REDDebugger.ab3@2395>         End Select
0000B8F2 <REDDebugger.ab3@2397>       Case #IDCMP_MENUHELP
0000B8F8 <REDDebugger.ab3@2398>         Gosub MenuHelp
0000B8FA <REDDebugger.ab3@2400>     End Select
0000B904 <REDDebugger.ab3@2401>   Until exitflag
0000B90A <REDDebugger.ab3@2402>   Gosub FreeStuff
0000B90C <REDDebugger.ab3@2403> Return
0000B916 <REDDebugger.ab3@2407>   If pb.l
0000B944 <REDDebugger.ab3@2408>     pb = 0 : i = Peek.l(buffmem+cb.l) : mc.l = -1 : Gosub prtcode
0000B946 <REDDebugger.ab3@2410> Return
0000B954 <REDDebugger.ab3@2414>   temp2.l = Peek.l(MyBufferAddress)
0000B968 <REDDebugger.ab3@2415>   temp2   = Peek.l(temp2+64)
0000B9CC <REDDebugger.ab3@2416>   If Peek.w(temp2-2) = $4e41 AND Peek.w(temp2-2+Peek.w(temp2+6)) = $4e41
0000B9D4 <REDDebugger.ab3@2417>     temp2 = 0
0000B9DA <REDDebugger.ab3@2418>   Else
0000B9E2 <REDDebugger.ab3@2419>     temp2 = 1
0000B9E4 <REDDebugger.ab3@2421> Return
0000B9FC <REDDebugger.ab3@2425>   If pb = 0 Then bb.l = cb
0000BA26 <REDDebugger.ab3@2426>   bb-4 AND #buffand : i = Peek.l(buffmem+bb)
0000BA38 <REDDebugger.ab3@2427>   If i = 0
0000BA4C <REDDebugger.ab3@2428>     If pb = 0 Then Return
0000BA62 <REDDebugger.ab3@2429>     bb+4 AND #buffand
0000BA8A <REDDebugger.ab3@2430>     t$ = "At end of buffer"
0000BA90 <REDDebugger.ab3@2431>     Goto wprint
0000BAA0 <REDDebugger.ab3@2433>   If syntax_.l Then Gosub getsyntax
0000BAB8 <REDDebugger.ab3@2434>   pb = -1 : mc = -1
0000BABE <REDDebugger.ab3@2435> Goto prtcode
0000BAD4 <REDDebugger.ab3@2439>   bb+4 AND #buffand
0000BB14 <REDDebugger.ab3@2440>   If (bb+4 AND #buffand) = Peek.w(?bufferput) Then pb = 0
0000BB28 <REDDebugger.ab3@2441>   i = Peek.l(buffmem+bb)
0000BB38 <REDDebugger.ab3@2442>   If syntax_ Then Gosub getsyntax
0000BB44 <REDDebugger.ab3@2443>   mc = -1
0000BB4A <REDDebugger.ab3@2444> Goto prtcode
0000BB5E <REDDebugger.ab3@2454>   If i = 0 Then Return
0000BB64 <REDDebugger.ab3@2455>   Gosub sourceallow
0000BB70 <REDDebugger.ab3@2456>   If temp2 Then Return
0000BB9A <REDDebugger.ab3@2457>   il.l = Peek.l(i) : io.l = Peek.w(i+4)-9
0000BBA8 <REDDebugger.ab3@2458>   il = getad {i}
0000BBC6 <REDDebugger.ab3@2459>   If mc.l Then cil.l = il : cio.l = io : mc = 0
0000BBCC <REDDebugger.ab3@2461>   Gosub prtcode2
0000BBD2 <REDDebugger.ab3@2463>   ali = i
0000BBD4 <REDDebugger.ab3@2464> Return
0000BBDA <REDDebugger.ab3@2468>   bitm = 3
0000BBF6 <REDDebugger.ab3@2469>   If (Peek.l(Addr Window(#_winSource)))
0000BC0C <REDDebugger.ab3@2471>   Use Window #_winSource
0000BC24 <REDDebugger.ab3@2472>   *rp.RastPort = RastPort(#_winSource)
0000BC3C <REDDebugger.ab3@2473>   *win.Window  = Peek.l(Addr Window(#_winSource))
0000BC46 <REDDebugger.ab3@2474>   If *rp
0000BCB0 <REDDebugger.ab3@2475>     rp_SetClipExt{*rp,*win\BorderLeft,*win\BorderTop,*win\Width-*win\BorderRight-1,*win\Height-*win\BorderBottom-1}
0000BCD0 <REDDebugger.ab3@2478>   If tokenise = 1 Then bitm = 3 Else bitm = 1
0000BCE0 <REDDebugger.ab3@2479>   Use BitMap bitm : ;BitmapOutput 1
0000BCEE <REDDebugger.ab3@2480>   w.w  = WindowWidth
0000BCFC <REDDebugger.ab3@2481>   hi.w = InnerHeight
0000BD04 <REDDebugger.ab3@2485>   ypc.l = 0
0000BD10 <REDDebugger.ab3@2486>   y.l = ym.l : i2.l = il
0000BD50 <REDDebugger.ab3@2487>   While y <= ih.l-WinFontHeight AND i2 <> 0
0000BD56 <REDDebugger.ab3@2488>     Gosub prti2:
0000BD64 <REDDebugger.ab3@2489>      i2 = Peek.l(i2)
0000BDC8 <REDDebugger.ab3@2490>     srcStr(y/WinFontHeight) = t$ ; add line to sourcearray for clickvar
0000BDE8 <REDDebugger.ab3@2491>     y+WinFontHeight
0000BDEE <REDDebugger.ab3@2492>   Wend
0000BDFC <REDDebugger.ab3@2494>   If (y < ih)
0000BE5E <REDDebugger.ab3@2495>     WBox *win\BorderLeft,y+*win\BorderTop,*win\Width-*win\BorderRight-1,ih+*win\BorderTop,2
0000BE92 <REDDebugger.ab3@2498>   y = ym-WinFontHeight : i2 = Peek.l(il+4)
0000BEBC <REDDebugger.ab3@2499>   While y >= 0 AND i2 <> 0
0000BEC2 <REDDebugger.ab3@2500>     Gosub prti2:
0000BF26 <REDDebugger.ab3@2501>     srcStr(y/WinFontHeight) = t$
0000BF46 <REDDebugger.ab3@2502>     y-WinFontHeight
0000BF5A <REDDebugger.ab3@2504>     i2 = Peek.l(i2+4)
0000BF60 <REDDebugger.ab3@2505>   Wend
0000BF72 <REDDebugger.ab3@2507>   If (y > 0)
0000BFD2 <REDDebugger.ab3@2508>     WBox *win\BorderLeft,*win\BorderTop,*win\Width-*win\BorderRight-1,y+*win\BorderTop-1,2
0000BFDC <REDDebugger.ab3@2515>   If *rp
0000BFE6 <REDDebugger.ab3@2516>     rp_RemClipExt{*rp}
0000BFEE <REDDebugger.ab3@2519>   prtbusy = 0
0000BFF0 <REDDebugger.ab3@2520> Return
0000BFFE <REDDebugger.ab3@2524>   If i2 = cil
0000C006 <REDDebugger.ab3@2525>     n.w = cio
0000C00C <REDDebugger.ab3@2526>     ypc = y
0000C02C <REDDebugger.ab3@2527>     If pb Then m.w = 0 Else m = -1
0000C032 <REDDebugger.ab3@2528>   Else
0000C03C <REDDebugger.ab3@2529>     n = -1
0000C04A <REDDebugger.ab3@2531>   FLocate 0,0 ; y/8   ; this is necessary, otherweise FPrintDetoke doesnt find the correct line
0000C058 <REDDebugger.ab3@2532>   ret.l = getad2 {i2}
0000C078 <REDDebugger.ab3@2533>   FPrintDetoke ret+9,n,m,0 ; source_char_offset
0000C07C <REDDebugger.ab3@2534>   *lineptr.l = PutD0
0000C082 <REDDebugger.ab3@2536>   Gosub sysprintdetoke
0000C084 <REDDebugger.ab3@2537> Return
0000C0AC <REDDebugger.ab3@2541>   alog$           = ""
0000C0B4 <REDDebugger.ab3@2542>   tog.l           = 0
0000C0CE <REDDebugger.ab3@2543>   *win\RPort\cp_x = *win\BorderLeft
0000C0EE <REDDebugger.ab3@2544>   x.l             = -source_char_offset * *win\RPort\TxWidth
0000C100 <REDDebugger.ab3@2545>   WLocate x,y
0000C128 <REDDebugger.ab3@2546>   t$              = Peek.s(*lineptr)
0000C1A6 <REDDebugger.ab3@2553>   t$              = Replace$(t$,"End\\c0\\c0If","EndIf")
0000C1D2 <REDDebugger.ab3@2554>   InitArgParse t$
0000C1F8 <REDDebugger.ab3@2555>   a$        = NextArgChar$($c0)
0000C200 <REDDebugger.ab3@2556>   drawoff.l = 0 ; source_char_offset
0000C206 <REDDebugger.ab3@2557>   hldone.l  = False
0000C234 <REDDebugger.ab3@2560>   If i2 = cil AND drawoff >= cio AND hldone = False
0000C23E <REDDebugger.ab3@2561>     If tog
0000C24C <REDDebugger.ab3@2562>       WColour 3,0
0000C26E <REDDebugger.ab3@2563>       WindowFont 2,#FSF_BOLD
0000C274 <REDDebugger.ab3@2564>     Else
0000C282 <REDDebugger.ab3@2565>       WColour 1,0
0000C2A4 <REDDebugger.ab3@2566>       WindowFont 2,#FSF_BOLD
0000C2FA <REDDebugger.ab3@2568>     If Instr(a$,":")    Then hldone = True
0000C350 <REDDebugger.ab3@2569>     If Instr(a$,"Then") Then hldone = True
0000C356 <REDDebugger.ab3@2570>   Else
0000C360 <REDDebugger.ab3@2571>     If tog
0000C36E <REDDebugger.ab3@2572>       WColour 3,2
0000C390 <REDDebugger.ab3@2573>       WindowFont 2,#FSF_BOLD
0000C396 <REDDebugger.ab3@2574>     Else
0000C3A4 <REDDebugger.ab3@2575>       WColour 1,2
0000C3C0 <REDDebugger.ab3@2576>       WindowFont 1
0000C43E <REDDebugger.ab3@2580>   a$ = Replace$(a$,"==> ","")
0000C4BC <REDDebugger.ab3@2581>   a$ = Replace$(a$,"=> " ,"")
0000C4E0 <REDDebugger.ab3@2582>   drawoff + FLen(a$)
0000C518 <REDDebugger.ab3@2583>   x + FLen(a$) * *win\RPort\TxWidth
0000C568 <REDDebugger.ab3@2584>   If Instr(a$,";")
0000C5BA <REDDebugger.ab3@2585>     xpos.l = Instr(a$,";")-1
0000C61A <REDDebugger.ab3@2586>     Print Left$(a$,xpos)
0000C63C <REDDebugger.ab3@2587>     WindowFont 1,#FSF_ITALIC
0000C64A <REDDebugger.ab3@2588>     WColour 0,2
0000C6C6 <REDDebugger.ab3@2589>     Print Right$(a$,FLen(a$)-xpos)
0000C6CC <REDDebugger.ab3@2590>   Else
0000C710 <REDDebugger.ab3@2591>     Print a$
0000C71A <REDDebugger.ab3@2593>   If logcon.l
0000C78A <REDDebugger.ab3@2594>     If (i2 = cil) AND (i2 <> lasti2.l) Then alog$ = alog$+a$
0000C7B0 <REDDebugger.ab3@2597>   a$ = NextArgChar$($c0)
0000C7F8 <REDDebugger.ab3@2598>   If a$ <> "" Then tog = NOT tog : Goto _more
0000C876 <REDDebugger.ab3@2600>   t$ = Replace$(t$,"\\c0","")
0000C884 <REDDebugger.ab3@2601>   WColour 1,0
0000C8A0 <REDDebugger.ab3@2602>   WindowFont 1
0000C8B8 <REDDebugger.ab3@2603>   x + *win\BorderLeft
0000C95A <REDDebugger.ab3@2604>   If x < *win\Width-*win\BorderRight Then WBox x,y+*win\BorderTop,*win\Width-*win\BorderRight-1,y+*win\BorderTop-1+WinFontHeight,2
0000CB2C <REDDebugger.ab3@2605>   If alog$ Then !cout{alog$} : lasti2 = i2
0000CB2E <REDDebugger.ab3@2607> Return
0000CB58 <REDDebugger.ab3@2611>   If (Peek.l(Addr Window(#_winSearch)) = 0) Then Return
0000CB6E <REDDebugger.ab3@2613>   Use Window #_winSearch
0000CB74 <REDDebugger.ab3@2614>   Select gad
0000CB82 <REDDebugger.ab3@2616>     Case 2
0000CBDE <REDDebugger.ab3@2617>       SetString 2,1,"$"+Hex$(mempointer(0))
0000CBFA <REDDebugger.ab3@2618>       Redraw #_winSearch,1
0000CC0E <REDDebugger.ab3@2620>     Case 3
0000CC6A <REDDebugger.ab3@2621>       SetString 2,1,"$"+Hex$(mempointer(1))
0000CC86 <REDDebugger.ab3@2622>       Redraw #_winSearch,1
0000CC9A <REDDebugger.ab3@2624>     Case 5
0000CCF6 <REDDebugger.ab3@2625>       SetString 2,4,"$"+Hex$(mempointer(0))
0000CD12 <REDDebugger.ab3@2626>       Redraw #_winSearch,4
0000CD26 <REDDebugger.ab3@2628>     Case 6
0000CD82 <REDDebugger.ab3@2629>       SetString 2,4,"$"+Hex$(mempointer(1))
0000CD9E <REDDebugger.ab3@2630>       Redraw #_winSearch,4
0000CDB2 <REDDebugger.ab3@2632>     Case 8
0000CDD6 <REDDebugger.ab3@2633>       searchtype+1 : If searchtype = 7 Then searchtype = 1
0000CDE8 <REDDebugger.ab3@2634>       WLocate 190,52
0000CE42 <REDDebugger.ab3@2635>       ad = (?variabletypes+(searchtype*7)-7) : Print Peek.s(ad)
0000CE56 <REDDebugger.ab3@2637>     Case 10
0000CE5C <REDDebugger.ab3@2638>       Gosub SearchMemory
0000CE5E <REDDebugger.ab3@2639>   End Select
0000CE60 <REDDebugger.ab3@2640> Return
0000CE76 <REDDebugger.ab3@2644>   Use Window evw
0000CE80 <REDDebugger.ab3@2645>   *arrowgad = EventiAddress
0000CEA6 <REDDebugger.ab3@2646>   If evw >= #_winObject0 AND evw <= #_winObject9
0000CEB0 <REDDebugger.ab3@2647>     FindStructureWin{evw}
0000CEC2 <REDDebugger.ab3@2650>     Delay_ 1
0000CEC8 <REDDebugger.ab3@2651>     Select gad
0000CED6 <REDDebugger.ab3@2653>       Case #SRC_SGAD
0000CEF2 <REDDebugger.ab3@2654>         source_char_offset = GetPropCurrent(#_winSource,1)
0000CF02 <REDDebugger.ab3@2656>         If ali Then Gosub prtcode2
0000CF16 <REDDebugger.ab3@2658>       Case #SRC_LGAD
0000CF24 <REDDebugger.ab3@2659>         If source_char_offset > 0
0000CF30 <REDDebugger.ab3@2660>           source_char_offset-1
0000CF5A <REDDebugger.ab3@2661>           MoveProp #_winSource,#SRC_SGAD,source_char_offset,#_winSource
0000CF6A <REDDebugger.ab3@2662>           If ali Then Gosub prtcode2
0000CF7E <REDDebugger.ab3@2665>       Case #SRC_RGAD
0000CF98 <REDDebugger.ab3@2666>         If source_char_offset < (250-cw.l)
0000CFA6 <REDDebugger.ab3@2667>           source_char_offset+1
0000CFD0 <REDDebugger.ab3@2668>           MoveProp #_winSource,#SRC_SGAD,source_char_offset,#_winSource
0000CFE0 <REDDebugger.ab3@2669>           If ali Then Gosub prtcode2
0000CFF4 <REDDebugger.ab3@2672>       Case #MSE_SGAD
0000D010 <REDDebugger.ab3@2673>         num = GetPropCurrent(#_winMouseables,#MSE_SGAD)
0000D01E <REDDebugger.ab3@2674>         If num <> mouseables_off
0000D024 <REDDebugger.ab3@2675>           mouseables_off = num
0000D02C <REDDebugger.ab3@2676>           RedrawMouseables{False}
0000D040 <REDDebugger.ab3@2679>       Case #MSE_UGAD
0000D04E <REDDebugger.ab3@2680>         If mouseables_off > 0
0000D05A <REDDebugger.ab3@2681>           mouseables_off-1
0000D084 <REDDebugger.ab3@2682>           MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
0000D08C <REDDebugger.ab3@2683>           RedrawMouseables{False}
0000D0A0 <REDDebugger.ab3@2686>       Case #MSE_DGAD
0000D0B8 <REDDebugger.ab3@2687>         h.l = (InnerHeight ASR 3)
0000D0D2 <REDDebugger.ab3@2688>         If mouseables_off < (num_mouseables-h)
0000D0E0 <REDDebugger.ab3@2689>           mouseables_off+1
0000D10A <REDDebugger.ab3@2690>           MoveProp #_winMouseables,#MSE_SGAD,mouseables_off,#_winMouseables
0000D112 <REDDebugger.ab3@2691>           RedrawMouseables{False}
0000D126 <REDDebugger.ab3@2694>       Case #OBJ_SGAD
0000D13E <REDDebugger.ab3@2695>         If objwins()\is_bbobject
0000D15A <REDDebugger.ab3@2696>           a = GetPropCurrent(evw,#OBJ_SGAD)
0000D176 <REDDebugger.ab3@2697>           If a <> objwins()\tracenum
0000D18A <REDDebugger.ab3@2698>             objwins()\tracenum = a
0000D190 <REDDebugger.ab3@2699>             Gosub RefType
0000D1A4 <REDDebugger.ab3@2703>       Case #OBJ_UGAD
0000D1BC <REDDebugger.ab3@2704>         If objwins()\is_bbobject
0000D1D6 <REDDebugger.ab3@2705>           If objwins()\tracenum > 0
0000D1FA <REDDebugger.ab3@2706>             objwins()\tracenum-1
0000D200 <REDDebugger.ab3@2707>             Gosub RefType2
0000D212 <REDDebugger.ab3@2708>             Delay_ 2
0000D226 <REDDebugger.ab3@2712>       Case #OBJ_DGAD
0000D23E <REDDebugger.ab3@2713>         If objwins()\is_bbobject
0000D26A <REDDebugger.ab3@2714>           If objwins()\tracenum < (objwins()\maxobject-1)
0000D290 <REDDebugger.ab3@2715>             objwins()\tracenum+1
0000D296 <REDDebugger.ab3@2716>             Gosub RefType2
0000D2A8 <REDDebugger.ab3@2717>             Delay_ 2
0000D2BC <REDDebugger.ab3@2721>       Case #ARR_YGAD
0000D2D8 <REDDebugger.ab3@2722>         n = GetPropCurrent(#_winArray,#ARR_YGAD)
0000D2E6 <REDDebugger.ab3@2723>         If n <> yarrayoff
0000D2EC <REDDebugger.ab3@2724>           yarrayoff = n
0000D2F6 <REDDebugger.ab3@2725>           RedrawArray{2}
0000D30A <REDDebugger.ab3@2728>       Case #ARR_XGAD
0000D326 <REDDebugger.ab3@2729>         n = GetPropCurrent(#_winArray,#ARR_XGAD)
0000D334 <REDDebugger.ab3@2730>         If n <> xarrayoff
0000D33A <REDDebugger.ab3@2731>           xarrayoff = n
0000D344 <REDDebugger.ab3@2732>           RedrawArray{2}
0000D358 <REDDebugger.ab3@2735>       Case #ARR_UGAD ; up
0000D366 <REDDebugger.ab3@2736>         If yarrayoff > 0
0000D372 <REDDebugger.ab3@2737>           yarrayoff-1
0000D37C <REDDebugger.ab3@2738>           RedrawArray{1}
0000D390 <REDDebugger.ab3@2741>       Case #ARR_DGAD ; down
0000D3AA <REDDebugger.ab3@2742>         If yarrayoff < array2-yarraynum
0000D3B8 <REDDebugger.ab3@2743>           yarrayoff+1
0000D3C2 <REDDebugger.ab3@2744>           RedrawArray{1}
0000D3D6 <REDDebugger.ab3@2747>       Case #ARR_LGAD ; left
0000D3E4 <REDDebugger.ab3@2748>         If xarrayoff > 0
0000D3F0 <REDDebugger.ab3@2749>           xarrayoff-1
0000D3FA <REDDebugger.ab3@2750>           RedrawArray{1}
0000D40E <REDDebugger.ab3@2753>       Case #ARR_RGAD ; right
0000D428 <REDDebugger.ab3@2754>         If xarrayoff < array1-xarraynum
0000D436 <REDDebugger.ab3@2755>           xarrayoff+1
0000D440 <REDDebugger.ab3@2756>           RedrawArray{1}
0000D442 <REDDebugger.ab3@2759>     End Select
0000D462 <REDDebugger.ab3@2760>   Until (*arrowgad\Flags AND #GFLG_SELECTED) = 0
0000D46A <REDDebugger.ab3@2761>   ev = 0
0000D46C <REDDebugger.ab3@2762> Return
0000D4A2 <REDDebugger.ab3@2766>   MoveProp evw,#OBJ_SGAD,objwins()\tracenum,evw
0000D4B6 <REDDebugger.ab3@2768>   a = objwins()\tracenum
0000D4F2 <REDDebugger.ab3@2769>   objwins()\typepointer = objwins()\objbaseadr+(a*objwins()\type_sizeof)
0000D5C6 <REDDebugger.ab3@2770>   WTitle "Newtype: "+objwins()\t+" #"+Str$(a)+"/"+Str$(objwins()\maxobject-1)
0000D5CC <REDDebugger.ab3@2771>   RefreshTypeWindow{}
0000D5CE <REDDebugger.ab3@2772> Return
0000D5D4 <REDDebugger.ab3@2776>   Select gad
0000D5E2 <REDDebugger.ab3@2778>     Case 1 ;**STOP**
0000D5FC <REDDebugger.ab3@2780>         If dstatus <> #STOPPED Then !d_call{1}
0000D604 <REDDebugger.ab3@2781>         stepcnt = 0
0000D618 <REDDebugger.ab3@2784>     Case 2 ;**STEP**
0000D622 <REDDebugger.ab3@2786>       If asmstep
0000D62A <REDDebugger.ab3@2787>         CacheClearU_
0000D638 <REDDebugger.ab3@2788>         ad    = Peek.l(MyBufferAddress)
0000D64C <REDDebugger.ab3@2789>         pc.l  = Peek.l(ad+64)
0000D65A <REDDebugger.ab3@2790>         st1.l = FindBreakPoint{pc}
0000D664 <REDDebugger.ab3@2792>         If st1
0000D672 <REDDebugger.ab3@2793>           bd1.l = st1-breakpoint_adr
0000D68A <REDDebugger.ab3@2794>           temp  = Peek.w (bd1+?breakstore)
0000D69E <REDDebugger.ab3@2795>           Poke.w pc-2,temp
0000D6BE <REDDebugger.ab3@2797>         If Peek.w (pc-2) = $4e41
0000D6CC <REDDebugger.ab3@2798>           pc = pc+10
0000D6D2 <REDDebugger.ab3@2799>         Else
0000D6EC <REDDebugger.ab3@2800>           Poke.l ad+64,pc-10
0000D6FA <REDDebugger.ab3@2803>         pc-2
0000D720 <REDDebugger.ab3@2804>         temp$     = DisAssemble$(pc)
0000D73A <REDDebugger.ab3@2805>         ad        = pc+InstrSize
0000D74A <REDDebugger.ab3@2806>         temp      = Peek.w (pc)
0000D752 <REDDebugger.ab3@2807>         adtemp2.l = 0
0000D75A <REDDebugger.ab3@2808>         adtemp.l  =  0
0000D784 <REDDebugger.ab3@2810>         If temp = $4eb9 Then ad = Peek.l (pc+2)  ; jsr $xxx
0000D7AE <REDDebugger.ab3@2811>         If skip AND temp = $4eb9 Then ad = pc+6  ; skip jsr
0000D7D4 <REDDebugger.ab3@2812>         If temp >= $6000 AND temp <= $6f00       ; bcc bra bsr
0000D7EE <REDDebugger.ab3@2813>           If (temp AND $ff) = $ff                ; 32bit
0000D818 <REDDebugger.ab3@2814>             ad      = pc+Peek.l(pc+2)+2
0000D826 <REDDebugger.ab3@2815>             adtemp2 = pc+6
0000D82C <REDDebugger.ab3@2816>           Else
0000D840 <REDDebugger.ab3@2817>             If temp AND %00000000 11111111
0000D86E <REDDebugger.ab3@2818>               ad      = pc+Peek.b(pc+1)+2        ; 8 bit
0000D87C <REDDebugger.ab3@2819>               adtemp2 = pc+2
0000D882 <REDDebugger.ab3@2820>             Else
0000D8AE <REDDebugger.ab3@2821>               ad      = pc+Peek.w(pc+2)+2        ; 16 bit
0000D8BC <REDDebugger.ab3@2822>               adtemp2 = pc+4
0000D8EE <REDDebugger.ab3@2826>         If skip AND temp = $6100 Then ad = pc+4 : adtemp2 = 0 ; skip bsr
0000D930 <REDDebugger.ab3@2827>         If temp = $4e75 Then ad = Peek.l(MyBufferAddress) : ad = Peek.l (ad+60) : ad = Peek.l(ad) ; rts
0000D956 <REDDebugger.ab3@2828>         If temp = $4ef9 Then ad = Peek.l(pc+2)
0000D966 <REDDebugger.ab3@2829>         temp1.l = temp AND %11110000 11111000 ; dbxx
0000D978 <REDDebugger.ab3@2830>         If temp1 = %01010000 11001000
0000D982 <REDDebugger.ab3@2831>           If skip
0000D990 <REDDebugger.ab3@2832>             ad = pc+4
0000D996 <REDDebugger.ab3@2833>           Else
0000D9D0 <REDDebugger.ab3@2834>             ad = pc+Peek.w(pc+2)+2 : adtemp2 = pc+4
0000D9E4 <REDDebugger.ab3@2837>         brk1.l = FindBreakPoint{ad+2}
0000D9EE <REDDebugger.ab3@2838>         If brk1
0000DA02 <REDDebugger.ab3@2839>           brk2.l = Peek.l(brk1+4)
0000DA18 <REDDebugger.ab3@2840>           Poke.l brk1+4,$00010000
0000DA1E <REDDebugger.ab3@2841>           Goto _nobreak
0000DA2E <REDDebugger.ab3@2843>         temp = Peek.w (ad)
0000DA3C <REDDebugger.ab3@2844>         Poke.w ad,$4e41
0000DA42 <REDDebugger.ab3@2845>         adtemp = ad
0000DA48 <REDDebugger.ab3@2846>         typ.w  = #break_simple
0000DA4E <REDDebugger.ab3@2847>         Gosub addbreakpoint_quiet
0000DA58 <REDDebugger.ab3@2850>         If adtemp2
0000DA5E <REDDebugger.ab3@2851>           ad    = adtemp2
0000DA6E <REDDebugger.ab3@2852>           temp1 = Peek.w (adtemp2)
0000DA7C <REDDebugger.ab3@2853>           Poke.w adtemp2,$4e41
0000DA82 <REDDebugger.ab3@2854>           typ.w = #break_simple
0000DA88 <REDDebugger.ab3@2855>           Gosub addbreakpoint_quiet
0000DACE <REDDebugger.ab3@2857>         cil = 0 : pb = 0 : Gosub refwindow : ali = 0 : lt$ = ""
0000DAD6 <REDDebugger.ab3@2859>         Forbid_
0000DADE <REDDebugger.ab3@2860>          CacheClearU_
0000DAF0 <REDDebugger.ab3@2861>          prtcode = 0 : dstatus = #RUNNING : statego = 0
0000DAF8 <REDDebugger.ab3@2862>         Permit_
0000DB10 <REDDebugger.ab3@2864>         Signal_ task,signalset
0000DB18 <REDDebugger.ab3@2866>         CacheClearU_
0000DB2A <REDDebugger.ab3@2867>          Delay_(2)
0000DB34 <REDDebugger.ab3@2868>         If adtemp
0000DB48 <REDDebugger.ab3@2869>           ad = FindBreakPoint{adtemp+2}
0000DB58 <REDDebugger.ab3@2870>           If ad Then Gosub deletebreakpoint
0000DB66 <REDDebugger.ab3@2871>           Poke.w adtemp,temp
0000DB70 <REDDebugger.ab3@2873>         If adtemp2
0000DB84 <REDDebugger.ab3@2874>           ad = FindBreakPoint{adtemp2+2}
0000DB94 <REDDebugger.ab3@2875>           If ad Then Gosub deletebreakpoint
0000DBA2 <REDDebugger.ab3@2876>           Poke.w adtemp2,temp1
0000DBAC <REDDebugger.ab3@2878>         If st1
0000DBD0 <REDDebugger.ab3@2879>           Poke.w (Peek.l (st1)-2),$4e41
0000DBDA <REDDebugger.ab3@2881>         If brk1
0000DBEE <REDDebugger.ab3@2882>           Poke.l brk1+4,brk2
0000DBF6 <REDDebugger.ab3@2884>         CacheClearU_
0000DBFC <REDDebugger.ab3@2885>         Goto _nostep
0000DC0A <REDDebugger.ab3@2887>       If dstatus = #STOPPED
0000DC10 <REDDebugger.ab3@2888>         flag = 0
0000DC2C <REDDebugger.ab3@2889>         If gosubstatus OR skip = 1
0000DC3A <REDDebugger.ab3@2890>           ad   = Peek.l(MyBufferAddress)
0000DC4E <REDDebugger.ab3@2891>           pc.l = Peek.l(ad+64)
0000DC6E <REDDebugger.ab3@2892>           If Peek.w(pc+8) = $4EB9         ; JSR
0000DC98 <REDDebugger.ab3@2893>             If Peek.l(pc+8+6) = $3f3c6753 ; MOVE.w #$6753,-(a7)
0000DCC4 <REDDebugger.ab3@2894>               ad    = pc+Peek.w(pc+6)-2   ; calc next instruction addr
0000DCCA <REDDebugger.ab3@2895>               typ.w = #break_simple
0000DCD0 <REDDebugger.ab3@2896>               Gosub addbreakpoint_quiet
0000DCD8 <REDDebugger.ab3@2897>               CacheClearU_
0000DCF8 <REDDebugger.ab3@2899>               If flag AND (dstatus OR skip)
0000DD3E <REDDebugger.ab3@2900>                 cil = 0 : pb = 0 : Gosub refwindow : ali = 0 : lt$ = ""
0000DD46 <REDDebugger.ab3@2901>                 Forbid_
0000DD58 <REDDebugger.ab3@2902>                  prtcode = 0 : dstatus = #RUNNING : statego = 0
0000DD60 <REDDebugger.ab3@2903>                 Permit_
0000DD66 <REDDebugger.ab3@2904>               Else
0000DD6C <REDDebugger.ab3@2905>                 flag = 0
0000DD7C <REDDebugger.ab3@2910>         If flag = 0
0000DD90 <REDDebugger.ab3@2911>           If (evq AND %1000)
0000DDEC <REDDebugger.ab3@2912>             stepnumber = RTEZGetLongRange(scrtitle$,"# commands to step:",0,1000,stepnumber)
0000DDF6 <REDDebugger.ab3@2913>             If stepnumber
0000DE04 <REDDebugger.ab3@2914>               stepcnt+stepnumber
0000DE0A <REDDebugger.ab3@2915>               flag = 1
0000DE10 <REDDebugger.ab3@2917>           Else
0000DE1E <REDDebugger.ab3@2918>             stepcnt+1
0000DE24 <REDDebugger.ab3@2919>             flag = 1
0000DE32 <REDDebugger.ab3@2921>             If autoeval
0000DE38 <REDDebugger.ab3@2922>               evalrequest = #_autoevalresult
0000DE6A <REDDebugger.ab3@2923>               d_eval{autoeval$,#NOSIGNAL}
0000DE90 <REDDebugger.ab3@2927>         If flag Then Signal_ task,signalset
0000DEA4 <REDDebugger.ab3@2932>     Case 3 ;**SKIP**
0000DEB2 <REDDebugger.ab3@2933>       If dstatus = #STOPPED
0000DECC <REDDebugger.ab3@2934>         !d_call{8} : stepcnt+1
0000DEE4 <REDDebugger.ab3@2935>         Signal_ task,signalset
0000DEF8 <REDDebugger.ab3@2938>     Case 4 ;**TRACE**
0000DF00 <REDDebugger.ab3@2939>       Forbid_
0000DF10 <REDDebugger.ab3@2940>        dstatus = #TRACE : statego = -1
0000DF18 <REDDebugger.ab3@2941>       Permit_
0000DF30 <REDDebugger.ab3@2942>       Signal_ task,signalset
0000DF44 <REDDebugger.ab3@2944>     Case 5 ;**RUN**
0000DF4E <REDDebugger.ab3@2945>       If dstatus
0000DF94 <REDDebugger.ab3@2946>         cil = 0 : pb = 0 : Gosub refwindow : ali = 0 : lt$ = ""
0000DF9C <REDDebugger.ab3@2947>         Forbid_
0000DFAE <REDDebugger.ab3@2948>          prtcode = 0 : dstatus = #RUNNING : statego = 0
0000DFB6 <REDDebugger.ab3@2949>         Permit_
0000DFCE <REDDebugger.ab3@2950>         Signal_ task,signalset
0000DFE2 <REDDebugger.ab3@2953>     Case 6 ;**<<**
0000DFF6 <REDDebugger.ab3@2954>       If dstatus = #STOPPED Then Gosub backward
0000E00A <REDDebugger.ab3@2956>     Case 7 ;**>>**
0000E032 <REDDebugger.ab3@2957>       If dstatus = #STOPPED AND pb <> 0 Then Gosub forward
0000E046 <REDDebugger.ab3@2959>     Case 8 ;**execute**
0000E0D6 <REDDebugger.ab3@2960>       ex$ = RTEZGetString(scrtitle$,"Execute...",128,ex$)
0000E0DC <REDDebugger.ab3@2961>       Gosub storefpuregs
0000E136 <REDDebugger.ab3@2962>       If ex$ Then d_exec{ex$}
0000E148 <REDDebugger.ab3@2963>       Delay_(2)
0000E14E <REDDebugger.ab3@2964>       Gosub restorefpuregs
0000E162 <REDDebugger.ab3@2966>     Case 9 ;**evaluate**
0000E1F2 <REDDebugger.ab3@2967>       ev$ = RTEZGetString(scrtitle$,"Evaluate...",128,ev$)
0000E1F8 <REDDebugger.ab3@2968>       Gosub storefpuregs
0000E256 <REDDebugger.ab3@2969>       If ev$ Then d_eval{ev$,#SIGNAL}
0000E268 <REDDebugger.ab3@2970>       Delay_(2)
0000E26E <REDDebugger.ab3@2971>       Gosub restorefpuregs
0000E282 <REDDebugger.ab3@2973>     Case 10 ;**BLITZ GADGET**
0000E290 <REDDebugger.ab3@2975>         If dstatus = #STOPPED
0000E2A0 <REDDebugger.ab3@2976>           If pmode <> 0
0000E2B8 <REDDebugger.ab3@2977>             Disable #_winControl,10
0000E2BE <REDDebugger.ab3@2978>             execrequest = #_viewblitz
0000E2E0 <REDDebugger.ab3@2979>             d_exec{"Mousewait"}
0000E2E6 <REDDebugger.ab3@2980>             dstatus = #BLITZMODE
0000E2EC <REDDebugger.ab3@2981>           Else
0000E352 <REDDebugger.ab3@2982>             reply = RTEZRequest(scrtitle$,"   Not in BLITZ mode   ","_Abort")
0000E366 <REDDebugger.ab3@2987>     Case 11 ;**REGISTER WINDOW**
0000E380 <REDDebugger.ab3@2988>       If winstatus(#_winRegisters) = 0
0000E38A <REDDebugger.ab3@2989>         NewWindow{#_winRegisters}
0000E390 <REDDebugger.ab3@2990>         InitRegsWin{}
0000E396 <REDDebugger.ab3@2991>         RedrawRegs{}
0000E39C <REDDebugger.ab3@2992>       Else
0000E3A6 <REDDebugger.ab3@2993>         DelWindow{#_winRegisters}
0000E3BA <REDDebugger.ab3@2996>     Case 12 ;**MEM WINDOW 1**
0000E3D4 <REDDebugger.ab3@2997>       If winstatus(#_winMemory1) = 0
0000E3DE <REDDebugger.ab3@2998>         NewMemWindow{#_winMemory1}
0000E3E4 <REDDebugger.ab3@2999>         dowin = 0
0000E3EA <REDDebugger.ab3@3000>         RedrawMem{}
0000E3F0 <REDDebugger.ab3@3001>       Else
0000E3FA <REDDebugger.ab3@3002>         DelWindow{#_winMemory1}
0000E40E <REDDebugger.ab3@3005>     Case 13 ;**MEM WINDOW 2**
0000E428 <REDDebugger.ab3@3006>       If winstatus(#_winMemory2) = 0
0000E432 <REDDebugger.ab3@3007>         NewMemWindow{#_winMemory2}
0000E438 <REDDebugger.ab3@3008>         dowin = 1
0000E43E <REDDebugger.ab3@3009>         RedrawMem{}
0000E444 <REDDebugger.ab3@3010>       Else
0000E44E <REDDebugger.ab3@3011>         DelWindow{#_winMemory2}
0000E462 <REDDebugger.ab3@3014>     Case 14 ;**VARIABLE WINDOW**
0000E47C <REDDebugger.ab3@3015>       If winstatus(#_winVariables) = 0
0000E486 <REDDebugger.ab3@3016>         NewWindow{#_winVariables}
0000E48C <REDDebugger.ab3@3017>         RedrawVarWindow{}
0000E492 <REDDebugger.ab3@3018>         UpdateVarWindow{}
0000E498 <REDDebugger.ab3@3019>       Else
0000E4A2 <REDDebugger.ab3@3020>         DelWindow{#_winVariables}
0000E4B6 <REDDebugger.ab3@3023>     Case 15 ;**DISASM WINDOW**
0000E4D0 <REDDebugger.ab3@3024>       If winstatus(#_winDisAsm) = 0
0000E4DA <REDDebugger.ab3@3025>         NewWindow{#_winDisAsm}
0000E4E8 <REDDebugger.ab3@3026>         UpdateDisAsm{}
0000E4EE <REDDebugger.ab3@3027>       Else
0000E4F8 <REDDebugger.ab3@3028>         DelWindow{#_winDisAsm}
0000E50C <REDDebugger.ab3@3031>     Case 16 ;**COPPER WINDOW**
0000E526 <REDDebugger.ab3@3032>       If winstatus(#_winDisCop) = 0
0000E530 <REDDebugger.ab3@3033>         NewWindow{#_winDisCop}
0000E536 <REDDebugger.ab3@3034>         UpdateDisCop{}
0000E53C <REDDebugger.ab3@3035>       Else
0000E546 <REDDebugger.ab3@3036>         DelWindow{#_winDisCop}
0000E55A <REDDebugger.ab3@3039>     Case 17
0000E576 <REDDebugger.ab3@3040>       gosubstatus = GadgetStatus(#_winControl,17)
0000E58A <REDDebugger.ab3@3042>     Case 18
0000E5A6 <REDDebugger.ab3@3043>       procstatus = GadgetStatus(#_winControl,18)
0000E5AE <REDDebugger.ab3@3044>       MOVE.w  #0,proccount
0000E5C2 <REDDebugger.ab3@3046>     Case 19
0000E5DE <REDDebugger.ab3@3047>       blitzcontrol = GadgetStatus(#_winControl,19)
0000E5E0 <REDDebugger.ab3@3049>   End Select
0000E5E2 <REDDebugger.ab3@3052> Return
0000E616 <REDDebugger.ab3@3056>   a$ = StringText$(3,0)
0000E64A <REDDebugger.ab3@3057>   b$ = StringText$(3,1)
0000E698 <REDDebugger.ab3@3058>   If a$ = "" AND gad = 0 Then Return
0000E6E6 <REDDebugger.ab3@3059>   If b$ = "" AND gad = 1 Then Return
0000E72C <REDDebugger.ab3@3060>   ad = Vallong("$"+a$)
0000E778 <REDDebugger.ab3@3061>   b$ = UCase$(b$)
0000E78A <REDDebugger.ab3@3063>   If gad = 0
0000E79E <REDDebugger.ab3@3064>     If (ad AND 1)
0000E7C6 <REDDebugger.ab3@3065>       a$ = "<ILLEGAL>"
0000E7CC <REDDebugger.ab3@3066>     Else
0000E7EC <REDDebugger.ab3@3067>       If ad > $dff000 Then ad-$dff000
0000E812 <REDDebugger.ab3@3068>       b$ = GetCustomReg(ad)
0000E838 <REDDebugger.ab3@3069>       a$ = Hexw$(ad)
0000E898 <REDDebugger.ab3@3070>       If b$ = "" Then b$ = "<UNKNOWN>"
0000E89E <REDDebugger.ab3@3072>   Else
0000E8D2 <REDDebugger.ab3@3073>     ad = GetCustomRegAdr(b$)
0000E8E6 <REDDebugger.ab3@3074>     If ad = -1
0000E90E <REDDebugger.ab3@3075>       a$ = "<UNKNOWN>"
0000E914 <REDDebugger.ab3@3076>     Else
0000E93A <REDDebugger.ab3@3077>       a$ = Hexw$(ad)
0000E97C <REDDebugger.ab3@3080>   SetString 3,0,a$
0000E998 <REDDebugger.ab3@3081>   Redraw #_winCustom,0
0000E9DA <REDDebugger.ab3@3082>   SetString 3,1,b$
0000E9F6 <REDDebugger.ab3@3083>   Redraw #_winCustom,1
0000E9F8 <REDDebugger.ab3@3084> Return
0000E9FE <REDDebugger.ab3@3090>   Gosub GetVariableNameAndType    ; moved code to subroutine  tomsmart1 2016 02 14
0000EA36 <REDDebugger.ab3@3091>   If na$ <> ""                    ; check if we get a name
0000EA58 <REDDebugger.ab3@3092>     If nt > 0 AND nt < 7          ; check variable type
0000EA68 <REDDebugger.ab3@3093>       If nt = 4
0000EACE <REDDebugger.ab3@3094>         nf = RTEZRequest(varfollow$,"Show string length and maxlen?:","_No|_Yes|_Cancel")
0000EAD4 <REDDebugger.ab3@3096>     Else
0000EADA <REDDebugger.ab3@3097>       nf = 1
0000EAFC <REDDebugger.ab3@3099>     If nt <> 0 AND nf <> 0
0000EB06 <REDDebugger.ab3@3100>       AddLast varinfo()
0000EB44 <REDDebugger.ab3@3101>       varinfo()\name    = na$
0000EB56 <REDDebugger.ab3@3102>       varinfo()\address = 0
0000EB6C <REDDebugger.ab3@3103>       varinfo()\typ     = nt
0000EB86 <REDDebugger.ab3@3104>       varinfo()\form    = nf-1
0000EBCA <REDDebugger.ab3@3106>         d_eval{"&"+na$,#SIGNAL}
0000EBD0 <REDDebugger.ab3@3107>         evalrequest = #_variablelocate
0000EBD2 <REDDebugger.ab3@3111> Return
0000EBD8 <REDDebugger.ab3@3116>   flag = 0
0000EC42 <REDDebugger.ab3@3117>   b$   = UCase$(Left$(n$,1))
0000EC48 <REDDebugger.ab3@3118>   num = 0
0000ECAA <REDDebugger.ab3@3119>   If Mid$(n$,3,1) = "="
0000ED18 <REDDebugger.ab3@3120>     If b$ = "D" OR b$ = "A"
0000ED70 <REDDebugger.ab3@3121>       num = Vallong(Mid$(n$,2,1))
0000EDB8 <REDDebugger.ab3@3122>       If b$ = "A" AND num = 7
0000EDC2 <REDDebugger.ab3@3123>         num  = -1
0000EDC8 <REDDebugger.ab3@3124>         flag = 1
0000EE2E <REDDebugger.ab3@3125>         reply = RTEZRequest(scrtitle$,"Cannot modify register a7","_Abort")
0000EE4C <REDDebugger.ab3@3127>       If num >= 0 AND num < 8
0000EE9E <REDDebugger.ab3@3128>         a$ = Mid$(n$,4)
0000EFA8 <REDDebugger.ab3@3129>         If Len(a$) = 6 AND Left$(a$,1) = Chr$(34) AND Right$(a$,1) = Chr$(34)
0000F000 <REDDebugger.ab3@3130>           si = Cvl(Mid$(a$,2,4))
0000F006 <REDDebugger.ab3@3131>         Else
0000F03A <REDDebugger.ab3@3132>           si = Vallong(a$)
0000F080 <REDDebugger.ab3@3134>         If b$ = "A" Then num+8
0000F08A <REDDebugger.ab3@3135>         flag = -1
0000F09A <REDDebugger.ab3@3139>   If flag = 0
0000F100 <REDDebugger.ab3@3140>     reply = RTEZRequest(scrtitle$,"Malformed argument string","_Abort")
0000F102 <REDDebugger.ab3@3142> Return
0000F12C <REDDebugger.ab3@3147>   If (Peek.l(Addr Window(evw)) = 0) Then Return
0000F142 <REDDebugger.ab3@3148>   Use Window evw
0000F16E <REDDebugger.ab3@3149>   wx = WMouseX-ix : wy = WMouseY-iy
0000F17C <REDDebugger.ab3@3150>   wfonth.w = WinFontHeight
0000F182 <REDDebugger.ab3@3151>   Gosub checkclicks
0000F194 <REDDebugger.ab3@3153>   If evw = #_winSource
0000F1BA <REDDebugger.ab3@3157>   If (evw = #_winDisAsm) AND (disasm_ad > 4096)
0000F1FC <REDDebugger.ab3@3158>     xwidth.l = TextLength_(RastPort,"$12345678",9)
0000F240 <REDDebugger.ab3@3159>     If (wx > xwidth) AND (wy >= 0) AND (wy < InnerHeight)
0000F250 <REDDebugger.ab3@3160>       wy/wfonth
0000F256 <REDDebugger.ab3@3161>       ad = disasm_ad
0000F26A <REDDebugger.ab3@3162>       While wy > 0
0000F2C2 <REDDebugger.ab3@3163>         If Peek.w(ad) = $4e41 AND Peek.w(ad+Peek.w(ad+8)) = $4e41
0000F2D0 <REDDebugger.ab3@3164>           ad+10
0000F2D6 <REDDebugger.ab3@3165>         Else
0000F2EA <REDDebugger.ab3@3166>           ad2 = FindBreakPoint{ad+2}
0000F2F4 <REDDebugger.ab3@3167>           If ad2
0000F320 <REDDebugger.ab3@3168>             Poke.w ad,Peek.w((ad2-breakpoint_adr)+?breakstore)
0000F346 <REDDebugger.ab3@3170>           a$ = DisAssemble$(ad)
0000F350 <REDDebugger.ab3@3171>           If ad2
0000F35E <REDDebugger.ab3@3172>             Poke.w ad,$4e41
0000F378 <REDDebugger.ab3@3174>           ad+InstrSize
0000F384 <REDDebugger.ab3@3176>         wy-1
0000F38A <REDDebugger.ab3@3177>       Wend
0000F444 <REDDebugger.ab3@3178>       If (Peek.w(ad) = $4e41 OR asmstep) AND (WMouseX < xwidth+TextLength_(RastPort,"12345678",8) AND WMouseX > xwidth) ; only add breakpoint in range
0000F44A <REDDebugger.ab3@3179>         flag = 0
0000F45E <REDDebugger.ab3@3180>         ad2 = FindBreakPoint{ad+2}
0000F468 <REDDebugger.ab3@3181>         If ad2
0000F4CE <REDDebugger.ab3@3182>           a = RTEZRequest(scrtitle$,"Change or delete breakpoint?","C_hange|_Delete|_Cancel")
0000F4E6 <REDDebugger.ab3@3183>           If a <> 1 Then flag = -1
0000F4F4 <REDDebugger.ab3@3184>           If a = 2
0000F4FA <REDDebugger.ab3@3185>             ad = ad2
0000F500 <REDDebugger.ab3@3186>             Gosub deletebreakpoint
0000F510 <REDDebugger.ab3@3190>         If flag = 0
0000F516 <REDDebugger.ab3@3191>           Gosub addbreakpoint
0000F51C <REDDebugger.ab3@3196>     flag = 1
0000F53E <REDDebugger.ab3@3199>   If evw = #_winRegisters AND dstatus = #STOPPED
0000F57E <REDDebugger.ab3@3200>     If (wx > 0) AND (wy > 0) AND (wy < InnerHeight)
0000F5C0 <REDDebugger.ab3@3201>       xwidth = TextLength_(RastPort," ",1)
0000F5D2 <REDDebugger.ab3@3202>       wx / xwidth  ; calc char position
0000F5E2 <REDDebugger.ab3@3203>       wy / wfonth  ; calc line position
0000F5F0 <REDDebugger.ab3@3204>       If (wy < 8)
0000F5F6 <REDDebugger.ab3@3205>         flag = 0
0000F5FC <REDDebugger.ab3@3206>         num  = wy
0000F638 <REDDebugger.ab3@3208>         If (wx < 12) Then flag = 1 : a$ = "d"
0000F684 <REDDebugger.ab3@3210>         If (wx > 19) AND (wx < 32) Then flag = 2 : a$ = "a"
0000F692 <REDDebugger.ab3@3211>         If flag
0000F6A0 <REDDebugger.ab3@3213>             ad = Peek.l(MyBufferAddress)
0000F6CA <REDDebugger.ab3@3214>             ad+(num ASL 2)+(flag-1)*32
0000F6D8 <REDDebugger.ab3@3215>             si = Peek.l(ad)
0000F6EC <REDDebugger.ab3@3216>             If EventQualifier AND 3
0000F714 <REDDebugger.ab3@3217>               n$ = ""
0000F738 <REDDebugger.ab3@3218>               If winstatus(#_winMemory2) = 0 Then NewMemWindow{#_winMemory2}
0000F74C <REDDebugger.ab3@3219>               mempointer(1) = si
0000F752 <REDDebugger.ab3@3220>               RedrawMem{}
0000F758 <REDDebugger.ab3@3221>               Goto _novalue
0000F83C <REDDebugger.ab3@3223>             n$ = RTEZGetString("Register value",Peek.s(?setregvalue),20,a$+Str$(num)+"=$"+Hex$(si))
0000F868 <REDDebugger.ab3@3226>             If n$
0000F86E <REDDebugger.ab3@3227>               Gosub ParseRegs
0000F882 <REDDebugger.ab3@3228>               If flag = -1
0000F8A0 <REDDebugger.ab3@3229>                 ad = Peek.l(MyBufferAddress)+(num ASL 2)
0000F8AE <REDDebugger.ab3@3230>                 Poke.l ad,si
0000F8B4 <REDDebugger.ab3@3231>                 RedrawRegs{}
0000F8DE <REDDebugger.ab3@3238>       If (wy = 8) AND (wx > 18) AND (wx < 32)
0000F8EC <REDDebugger.ab3@3240>         ad = Peek.l(MyBufferAddress)
0000F900 <REDDebugger.ab3@3241>         si = Peek.l(ad+64)
0000F9A4 <REDDebugger.ab3@3242>         n$ = RTEZGetString("Programcounter value",Peek.s(?setregvalue),20,"$"+Hex$(si-2))
0000F9D0 <REDDebugger.ab3@3243>         If n$
0000FA20 <REDDebugger.ab3@3244>           Poke.l ad+64,Vallong(n$)+2
0000FA26 <REDDebugger.ab3@3245>           RedrawRegs{}
0000FA34 <REDDebugger.ab3@3246>           UpdateDisAsm{}
0000FA5A <REDDebugger.ab3@3253>   If (evw >= #_winObject0) AND (evw <= #_winObject9)
0000FA6A <REDDebugger.ab3@3254>     y   = wy-8
0000FA74 <REDDebugger.ab3@3255>     x.l = wx
0000FA7E <REDDebugger.ab3@3256>     FindStructureWin{evw.l}
0000FAC2 <REDDebugger.ab3@3257>     If objwins()\is_bbobject = 0 AND y >= 0 AND x >= typewidth-4
0000FAD8 <REDDebugger.ab3@3258>       ad = GetStructVal{y ASR 3}
0000FAEC <REDDebugger.ab3@3259>       If ad <> -1
0000FB6C <REDDebugger.ab3@3260>         reply = RTEZRequest(scrtitle$,"Move to location $"+Hex$(ad),"_Okay|_Cancel")
0000FB7A <REDDebugger.ab3@3261>         If reply = 1
0000FB8E <REDDebugger.ab3@3262>           objwins()\typepointer = ad
0000FB94 <REDDebugger.ab3@3263>           RefreshTypeWindow{}
0000FBA6 <REDDebugger.ab3@3269>   If (evw = #_winMouseables)
0000FBC2 <REDDebugger.ab3@3270>     If num_mouseables AND evalrequest = 0
0000FBD2 <REDDebugger.ab3@3271>       wy = wy ASR 3
0000FC3E <REDDebugger.ab3@3272>       If wx >= 0 AND wx < InnerWidth AND wy >= 0 AND wy < (InnerHeight ASR 3)
0000FC4E <REDDebugger.ab3@3273>         wy+mouseables_off
0000FC5C <REDDebugger.ab3@3274>         If wy < num_mouseables
0000FC62 <REDDebugger.ab3@3275>           ad = mouseables
0000FC6C <REDDebugger.ab3@3276>           While wy
0000FC7A <REDDebugger.ab3@3277>             ad = Peek.l(ad)
0000FC86 <REDDebugger.ab3@3278>             wy-1
0000FC8C <REDDebugger.ab3@3279>           Wend
0000FCBE <REDDebugger.ab3@3280>           a$ = ExtractLabel(Peek.l(ad+4))
0000FCCC <REDDebugger.ab3@3281>           If old_active_win <> #_winMouseables
0000FCE4 <REDDebugger.ab3@3282>             Activate old_active_win
0000FCEA <REDDebugger.ab3@3283>             evalrequest   = #_mouseable_eval
0000FCF0 <REDDebugger.ab3@3284>             evalrequestex = old_active_win
0000FD34 <REDDebugger.ab3@3285>             d_eval{"?"+a$,#SIGNAL}
0000FD36 <REDDebugger.ab3@3291> Return
0000FD3C <REDDebugger.ab3@3296>   num = 1
0000FD4A <REDDebugger.ab3@3297>   If kbshift
0000FD60 <REDDebugger.ab3@3298>     Use Window evw
0000FD76 <REDDebugger.ab3@3299>     num = InnerHeight ASR 6
0000FD7E <REDDebugger.ab3@3302>   Select EventCode
0000FD8C <REDDebugger.ab3@3304>     Case $23 ; f
0000FDAE <REDDebugger.ab3@3305>       d_exec{"dbl_flip {}"}
0000FDC2 <REDDebugger.ab3@3307>     Case $19 ; p
0000FDD4 <REDDebugger.ab3@3308>       If evw = #_winDisAsm
0000FDE2 <REDDebugger.ab3@3309>         ad        = Peek.l(MyBufferAddress)
0000FDF6 <REDDebugger.ab3@3310>         ad.l      = Peek.l(ad+64)
0000FE04 <REDDebugger.ab3@3311>         disasm_ad = ad - 2
0000FE12 <REDDebugger.ab3@3312>         UpdateDisAsm{}
0000FE26 <REDDebugger.ab3@3315>     Case $35 ; b
0000FE4C <REDDebugger.ab3@3316>       If evw = #_winSource OR evw=#_winDisAsm
0000FE56 <REDDebugger.ab3@3317>         If ali
0000FE7E <REDDebugger.ab3@3318>           t$   = "Move To Breakpoint"
0000FE88 <REDDebugger.ab3@3319>           flag = -1
0000FE8E <REDDebugger.ab3@3320>           Gosub SelectBP
0000FE98 <REDDebugger.ab3@3321>           If bp
0000FE9E <REDDebugger.ab3@3322>             ad = breakpoint_adr
0000FEAA <REDDebugger.ab3@3323>             bp-1
0000FEC2 <REDDebugger.ab3@3324>             ad+(bp ASL 3)
0000FED4 <REDDebugger.ab3@3325>             If evw = #_winSource
0000FEF4 <REDDebugger.ab3@3326>               il = Peek.l(Peek.l(ad))
0000FEFA <REDDebugger.ab3@3327>               Gosub prtcode2
0000FF00 <REDDebugger.ab3@3328>             Else
0000FF14 <REDDebugger.ab3@3329>               disasm_ad = Peek.l(ad)-2
0000FF22 <REDDebugger.ab3@3330>               UpdateDisAsm{}
0000FF36 <REDDebugger.ab3@3336>     Case $40 ; <SPACE>
0000FF4E <REDDebugger.ab3@3337>       If evw = #_winMemory1 Then dowin=0
0000FF66 <REDDebugger.ab3@3338>       If evw = #_winMemory2 Then dowin=1
0000FF7A <REDDebugger.ab3@3339>       If dowin <> -1
0000FF82 <REDDebugger.ab3@3340>         winnum=evw
0000FF92 <REDDebugger.ab3@3341>         x = 0 : y = 0
0000FF98 <REDDebugger.ab3@3342>         Gosub MemEdit
0000FFAC <REDDebugger.ab3@3345>     Case $28 ; L
00010002 <REDDebugger.ab3@3346>       If evw = #_winMemory1 Then dowin = 0 : a$ = memlock$(0)
00010058 <REDDebugger.ab3@3347>       If evw = #_winMemory2 Then dowin = 1 : a$ = memlock$(1)
000100A4 <REDDebugger.ab3@3348>       If evw = #_winDisAsm  Then dowin = 2 : a$ = disasmlock$
000100B8 <REDDebugger.ab3@3349>       If dowin <> -1
000100BE <REDDebugger.ab3@3350>         flag = 0
00010142 <REDDebugger.ab3@3351>         a$ = RTEZGetString("Lock window","Enter expression to lock onto:",80,a$)
00010178 <REDDebugger.ab3@3352>         ConvToPostFix a$,&evalbuffer$
000101A2 <REDDebugger.ab3@3353>         ad = PFEvaluate(Peek.s(&evalbuffer$))
000101B0 <REDDebugger.ab3@3354>         If PFErrorType
0001020A <REDDebugger.ab3@3355>           reply = RTEZRequest("Lock window","Malformed argument","_Okay")
00010210 <REDDebugger.ab3@3356>         Else
00010222 <REDDebugger.ab3@3357>           If evw <> #_winDisAsm
00010270 <REDDebugger.ab3@3358>             If a$ <> "" Then mempointer(dowin) = ad
000102B0 <REDDebugger.ab3@3359>             memlock$(dowin) = a$
000102E6 <REDDebugger.ab3@3360>             memlockpf$(dowin) = Peek.s(&evalbuffer$)
000102F2 <REDDebugger.ab3@3361>             Domemtitle{dowin}
000102F8 <REDDebugger.ab3@3362>             RedrawMem{}
000102FE <REDDebugger.ab3@3363>           Else
0001033C <REDDebugger.ab3@3364>             If a$ <> "" Then disasm_ad = ad
00010370 <REDDebugger.ab3@3365>             disasmlock$   = a$
0001039A <REDDebugger.ab3@3366>             disasmlockpf$ = Peek.s(&evalbuffer$)
000103D2 <REDDebugger.ab3@3367>             Poke$ ?disasmlockstr,a$
000103EE <REDDebugger.ab3@3368>             If (Peek.l(Addr Window(#_winDisAsm)))
00010404 <REDDebugger.ab3@3369>               Use Window #_winDisAsm
0001042C <REDDebugger.ab3@3370>               t$ = "Disassembly"
000104DA <REDDebugger.ab3@3371>               If disasmlock$ <> "" Then t$+" ("+disasmlock$+")"
00010512 <REDDebugger.ab3@3372>               WTitle t$
00010520 <REDDebugger.ab3@3373>               UpdateDisAsm{}
00010534 <REDDebugger.ab3@3379>     Case $42 ; TAB
00010552 <REDDebugger.ab3@3380>       If evw < 0 Then evw =- 1
00010560 <REDDebugger.ab3@3382>         evw+1
00010580 <REDDebugger.ab3@3383>         If evw = #_winBackdrop Then evw+1
000105A6 <REDDebugger.ab3@3384>         If evw > (Maximum Window-1) Then evw = 0
000105CE <REDDebugger.ab3@3385>       Until Peek.l(Addr Window(evw)) <> 0
000105E6 <REDDebugger.ab3@3386>       Activate evw
00010606 <REDDebugger.ab3@3387>       WindowToFront_ Peek.l(Addr Window(evw))
0001061A <REDDebugger.ab3@3389>     Case $4c ; UP cursor
00010620 <REDDebugger.ab3@3390>       FlushEvents
00010626 <REDDebugger.ab3@3391>       Select evw
00010634 <REDDebugger.ab3@3393>         Case #_winSource
0001063A <REDDebugger.ab3@3394>           flag = 0
00010644 <REDDebugger.ab3@3396>           If ali
0001066E <REDDebugger.ab3@3397>             For h = 1 To num
00010686 <REDDebugger.ab3@3398>               If Peek.l(il+4)
000106A6 <REDDebugger.ab3@3399>                 il3.l = Peek.l(il+4) : aflag.l = -1
000106C6 <REDDebugger.ab3@3400>                 If Peek.l(il3) = il Then il = il3
000106D6 <REDDebugger.ab3@3402>             Next h
000106E6 <REDDebugger.ab3@3403>             If aflag Then Gosub prtcode2
000106FA <REDDebugger.ab3@3406>         Case #_winMemory1
00010710 <REDDebugger.ab3@3407>           flag = -1 : dowin = 0 : Gosub Movemem
00010724 <REDDebugger.ab3@3409>         Case #_winMemory2
0001073A <REDDebugger.ab3@3410>           flag = -1 : dowin = 1 : Gosub Movemem
0001074E <REDDebugger.ab3@3412>         Case #_winDisAsm
00010778 <REDDebugger.ab3@3414>           For h = 1 To num
00010780 <REDDebugger.ab3@3415>             offset.l = 0
0001078E <REDDebugger.ab3@3417>               offset+2
000107F0 <REDDebugger.ab3@3418>             Until (DisAssemble$(disasm_ad-offset) <> "?????" AND InstrSize = offset) OR offset = 8
0001080A <REDDebugger.ab3@3419>             If offset = 8 Then offset = 2
00010818 <REDDebugger.ab3@3420>             disasm_ad-offset
00010828 <REDDebugger.ab3@3421>           Next h
00010836 <REDDebugger.ab3@3422>           UpdateDisAsm{}
0001084A <REDDebugger.ab3@3424>         Case #_winDisCop
00010862 <REDDebugger.ab3@3425>           discop_ad-(num ASL 2)
00010868 <REDDebugger.ab3@3426>           UpdateDisCop{}
0001086A <REDDebugger.ab3@3428>       End Select
0001087E <REDDebugger.ab3@3430>     Case $4d ; DOWN cursor
00010884 <REDDebugger.ab3@3431>       FlushEvents
0001088A <REDDebugger.ab3@3432>       Select evw
00010898 <REDDebugger.ab3@3434>         Case #_winSource
0001089E <REDDebugger.ab3@3435>           flag = 0
000108A8 <REDDebugger.ab3@3437>           If ali
000108D2 <REDDebugger.ab3@3438>             For h = 1 To num
000108E4 <REDDebugger.ab3@3439>               If Peek.l(il)
000108FE <REDDebugger.ab3@3440>                 il3.l = Peek.l(il) : aflag = -1
00010922 <REDDebugger.ab3@3441>                 If Peek.l(il3) <> 0 Then il = il3
00010932 <REDDebugger.ab3@3443>             Next h
00010942 <REDDebugger.ab3@3444>             If aflag Gosub prtcode2
00010956 <REDDebugger.ab3@3447>         Case #_winMemory1
00010968 <REDDebugger.ab3@3448>           flag = 1 : dowin = 0 : Gosub Movemem
0001097C <REDDebugger.ab3@3450>         Case #_winMemory2
0001098E <REDDebugger.ab3@3451>           flag = 1 : dowin = 1 : Gosub Movemem
000109A2 <REDDebugger.ab3@3453>         Case #_winDisAsm
000109CC <REDDebugger.ab3@3455>           For h = 1 To num
000109E6 <REDDebugger.ab3@3456>             If Peek.w(disasm_ad) = $4e41
000109F4 <REDDebugger.ab3@3457>               disasm_ad+10
000109FA <REDDebugger.ab3@3458>             Else
00010A20 <REDDebugger.ab3@3459>               a$ = DisAssemble$(disasm_ad)
00010A58 <REDDebugger.ab3@3460>               If a$ <> "?????"
00010A72 <REDDebugger.ab3@3461>                 disasm_ad+InstrSize
00010A78 <REDDebugger.ab3@3462>               Else
00010A86 <REDDebugger.ab3@3463>                 disasm_ad+2
00010A96 <REDDebugger.ab3@3466>           Next h
00010AA4 <REDDebugger.ab3@3467>           UpdateDisAsm{}
00010AB8 <REDDebugger.ab3@3469>         Case #_winDisCop
00010AD0 <REDDebugger.ab3@3470>           discop_ad+(num ASL 2)
00010AD6 <REDDebugger.ab3@3471>           UpdateDisCop{}
00010AD8 <REDDebugger.ab3@3472>       End Select
00010AEC <REDDebugger.ab3@3474>     Case $4F ; Left cursor
00010B1A <REDDebugger.ab3@3475>       If evw = #_winMemory1 Then jump = 1 : flag = -1 : dowin = 0 : Gosub _doMovemem
00010B48 <REDDebugger.ab3@3476>       If evw = #_winMemory2 Then jump = 1 : flag = -1 : dowin = 1 : Gosub _doMovemem
00010B5C <REDDebugger.ab3@3478>     Case $4E ; Right cursor
00010B86 <REDDebugger.ab3@3479>       If evw = #_winMemory1 Then jump = 1 : flag = 1 : dowin = 0 : Gosub _doMovemem
00010BB0 <REDDebugger.ab3@3480>       If evw = #_winMemory2 Then jump = 1 : flag = 1 : dowin = 1 : Gosub _doMovemem
00010BC4 <REDDebugger.ab3@3482>     Case $45 ; ESCape
00010BCA <REDDebugger.ab3@3486>         d_quit{}
00010BDE <REDDebugger.ab3@3489>     Case $37 ; m
00010BE4 <REDDebugger.ab3@3490>       Select evw
00010BF2 <REDDebugger.ab3@3492>         Case #_winMemory1
00010BFA <REDDebugger.ab3@3493>           cur.l = 0
00010C08 <REDDebugger.ab3@3494>           If kbshift
00010C3C <REDDebugger.ab3@3495>             lt$ = lasteval$
00010C42 <REDDebugger.ab3@3497>           Gosub goto_MemWindow
00010C56 <REDDebugger.ab3@3499>         Case #_winMemory2
00010C5E <REDDebugger.ab3@3500>           cur = 1
00010C6C <REDDebugger.ab3@3501>           If kbshift
00010CA0 <REDDebugger.ab3@3502>             lt$ = lasteval$
00010CA6 <REDDebugger.ab3@3504>           Gosub goto_MemWindow
00010CBA <REDDebugger.ab3@3506>         Case #_winDisAsm
00010CC0 <REDDebugger.ab3@3507>           evalrequest = #_disasmaddress
00010CD4 <REDDebugger.ab3@3508>           If evq AND $8
00010D16 <REDDebugger.ab3@3509> 
00010D1C <REDDebugger.ab3@3510>             MOVE.l programstart,a0
00010D1E <REDDebugger.ab3@3511>             MOVE.l a0,a1
00010D24 <REDDebugger.ab3@3512>             ADD.l programsize,a1
00010D28 <REDDebugger.ab3@3515>             CMP.w #$4e41,(a0)+
00010D2C <REDDebugger.ab3@3516>             BNE _pg3
00010D2E <REDDebugger.ab3@3517>             MOVE.l (a0),d1
00010D34 <REDDebugger.ab3@3518>             AND.l #$80000000,d1
00010D38 <REDDebugger.ab3@3519>             BEQ _noe
00010D3A <REDDebugger.ab3@3520>             MOVE.l (a0),d1
00010D40 <REDDebugger.ab3@3521>             AND.l #$7fffffff,d1
00010D44 <REDDebugger.ab3@3522>             ADD.l startcode@(a5),d1
00010D46 <REDDebugger.ab3@3523>             MOVE.l d1,a3
00010D4A <REDDebugger.ab3@3524>             MOVE.l temp45@(a5),a2
00010D4E <REDDebugger.ab3@3525>             LEA 9(a2),a2
00010D52 <REDDebugger.ab3@3526>             LEA 9(a3),a3
00010D54 <REDDebugger.ab3@3527>             MOVEQ #0,d0
00010D58 <REDDebugger.ab3@3528>             MOVE.b -1(a2),d0
00010D5A <REDDebugger.ab3@3529>             ADDQ.l #4,a0
00010D5C <REDDebugger.ab3@3532>              CMPM.b (a2)+,(a3)+
00010D60 <REDDebugger.ab3@3533>              BNE _pg3
00010D64 <REDDebugger.ab3@3534>             DBF d0,_l1
00010D68 <REDDebugger.ab3@3536>            BRA _pg4
00010D6A <REDDebugger.ab3@3539>             CMP.l (a0)+,d0
00010D6E <REDDebugger.ab3@3540>             BEQ _pg4
00010D70 <REDDebugger.ab3@3543>             CMP.l a0,a1
00010D74 <REDDebugger.ab3@3544>             BGT _pg2
00010D78 <REDDebugger.ab3@3545>            BRA _pg5
00010D7A <REDDebugger.ab3@3548>             MOVE.l a0,d0
00010D7C <REDDebugger.ab3@3549>             SUBQ.l #6,d0
00010D80 <REDDebugger.ab3@3550>             disasm_ad = PutD0
00010D8E <REDDebugger.ab3@3551>             UpdateDisAsm{}
00010D94 <REDDebugger.ab3@3554>           Else
00010D9A <REDDebugger.ab3@3555>             Gosub goto_disassemble
00010DAE <REDDebugger.ab3@3558>         Case #_winDisCop
00010DB4 <REDDebugger.ab3@3559>           evalrequest = #_discopaddress
00010DBA <REDDebugger.ab3@3560>           Gosub goto_disassemble
00010DC0 <REDDebugger.ab3@3562>         Default
00010DE6 <REDDebugger.ab3@3563>           If evw >= #_winObject0 AND evw <= #_winObject9
00010DEC <REDDebugger.ab3@3564>             Gosub goto_objectwin
00010DEE <REDDebugger.ab3@3567>       End Select
00010E02 <REDDebugger.ab3@3569>     Case #RK_HELP ; help key
00010E22 <REDDebugger.ab3@3570>       If wininfo(evw)\helplink
00010E5E <REDDebugger.ab3@3571>         a$ = Peek.s(wininfo(evw)\helplink)
00010E8C <REDDebugger.ab3@3572>         DoHelp{a$}
00010E8E <REDDebugger.ab3@3574>   End Select
00010E90 <REDDebugger.ab3@3575> Return
00010EA0 <REDDebugger.ab3@3580>   If kbshift = 0
00010EEC <REDDebugger.ab3@3581>     strg$ = "$"+Hex$(mempointer(cur))
00010F20 <REDDebugger.ab3@3582>     lt$   = strg$
00010FA4 <REDDebugger.ab3@3583>     strg$ = RTEZGetString("Memory location","Enter address to jump to:",40,strg$)
00010FAA <REDDebugger.ab3@3584>   Else
00010FDE <REDDebugger.ab3@3585>     strg$ = lt$
0001100A <REDDebugger.ab3@3587>   If strg$
00011010 <REDDebugger.ab3@3588>     evalrequest   = #_memwindow
00011018 <REDDebugger.ab3@3589>     evalrequestex = cur
0001104E <REDDebugger.ab3@3591>     ConvToPostFix strg$,&evalbuffer$
00011082 <REDDebugger.ab3@3592>     mempointer(cur) = PFEvaluate(Peek.s(&evalbuffer$))
00011088 <REDDebugger.ab3@3593>     RedrawMem{}
0001108E <REDDebugger.ab3@3594>   Else
00011094 <REDDebugger.ab3@3595>     evalrequest = 0
00011096 <REDDebugger.ab3@3597> Return
000110A6 <REDDebugger.ab3@3601>   If kbshift = 0
000110E8 <REDDebugger.ab3@3602>     strg$ = "$"+Hex$(disasm_ad)
0001111C <REDDebugger.ab3@3603>     lt$   = strg$
000111A0 <REDDebugger.ab3@3604>     strg$ = RTEZGetString("Set location","Enter base address:",40,strg$)
000111A6 <REDDebugger.ab3@3605>   Else
000111DA <REDDebugger.ab3@3606>     strg$ = lt$
00011206 <REDDebugger.ab3@3608>   If strg$
00011216 <REDDebugger.ab3@3609>     If evalrequest <> #_discopaddress
0001124C <REDDebugger.ab3@3610>     ConvToPostFix strg$,&evalbuffer$
00011276 <REDDebugger.ab3@3611>     disasm_ad=PFEvaluate(Peek.s(&evalbuffer$))
00011284 <REDDebugger.ab3@3612>    UpdateDisAsm{}
0001128A <REDDebugger.ab3@3613>    Else
000112BC <REDDebugger.ab3@3614>     d_eval{strg$,#SIGNAL}
000112C2 <REDDebugger.ab3@3616>   Else
000112C8 <REDDebugger.ab3@3617>     evalrequest = 0
000112CA <REDDebugger.ab3@3619> Return
000112D4 <REDDebugger.ab3@3623>   FindStructureWin{evw}
000112EE <REDDebugger.ab3@3624>   If objwins()\is_bbobject = 0
000112F4 <REDDebugger.ab3@3625>     evalrequest = #_structaddress
000112FE <REDDebugger.ab3@3626>     PushItem objwins()
00011304 <REDDebugger.ab3@3627>     Gosub goto_disassemble
00011306 <REDDebugger.ab3@3628>     Return
00011322 <REDDebugger.ab3@3630>   If objwins()\maxobject = 1 Then Return
00011332 <REDDebugger.ab3@3631>   If kbshift = 0
000113B6 <REDDebugger.ab3@3632>     strg$ = RTEZGetString("Object number","Enter object number:",40,strg$)
000113BC <REDDebugger.ab3@3633>   Else
000113F0 <REDDebugger.ab3@3634>     strg$ = lt$
00011424 <REDDebugger.ab3@3636>   a.w = Vallong(strg$)
00011450 <REDDebugger.ab3@3637>   If a < 0 OR a >= objwins()\maxobject
000114B6 <REDDebugger.ab3@3638>     reply=RTEZRequest(scrtitle$,"Object value out of range!","  _Ok  ")
000114B8 <REDDebugger.ab3@3639>     Return
000114CC <REDDebugger.ab3@3641>   objwins()\tracenum    = a
00011508 <REDDebugger.ab3@3642>   objwins()\typepointer = objwins()\objbaseadr+(a*objwins()\type_sizeof)
00011534 <REDDebugger.ab3@3643>   If (Peek.l(Addr Window(objwins()\winnum)))
00011558 <REDDebugger.ab3@3645>     Use Window objwins()\winnum
00011638 <REDDebugger.ab3@3646>     WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)
0001167E <REDDebugger.ab3@3648>     MoveProp objwins()\winnum,#OBJ_SGAD,a,objwins()\winnum
00011684 <REDDebugger.ab3@3650>     RefreshTypeWindow{}
00011686 <REDDebugger.ab3@3652> Return
0001169C <REDDebugger.ab3@3656>   If ItemHit < 5
000116A4 <REDDebugger.ab3@3657>     Select ItemHit
000116B0 <REDDebugger.ab3@3659>       Case 0
000116BA <REDDebugger.ab3@3660>         ad = ?help_sr
000116CC <REDDebugger.ab3@3662>       Case 1
000116D6 <REDDebugger.ab3@3663>         ad = ?help_debug
000116E8 <REDDebugger.ab3@3665>       Case 3
000116F2 <REDDebugger.ab3@3666>         ad = ?help_keyboard
000116F4 <REDDebugger.ab3@3668>     End Select
00011776 <REDDebugger.ab3@3669>     reply = RTEZRequest(scrtitle$,Peek.s(ad),"_Okay",2,1,4)
0001177C <REDDebugger.ab3@3670>   Else
00011784 <REDDebugger.ab3@3671>     Select ItemHit
00011790 <REDDebugger.ab3@3673>       Case 5
00011796 <REDDebugger.ab3@3674>         Gosub Savewindows
000117A8 <REDDebugger.ab3@3676>       Case 6
000117AE <REDDebugger.ab3@3677>         Gosub doscreenmode
000117C0 <REDDebugger.ab3@3679>       Case 7
000117C6 <REDDebugger.ab3@3680>         Gosub dowindowheight
000117D8 <REDDebugger.ab3@3682>       Case 8  ; select font
00011832 <REDDebugger.ab3@3683>         aslfo_SetRequesterTitle {"Please select Source-Font:","",""} ; changed to asl font requester  tomsmart1 2016 03 01
0001186A <REDDebugger.ab3@3684>         aslfo_SetInitialFont{prefs\fontname,prefs\fontsize}
00011880 <REDDebugger.ab3@3685>         If aslfo_Request{False}  ; only nonproportionalfonts are allowed
000118B0 <REDDebugger.ab3@3686>           prefs\fontname = aslfo_GetFontName{}
000118BE <REDDebugger.ab3@3687>           prefs\fontsize = aslfo_GetFontSize{}
000118FC <REDDebugger.ab3@3688>           message{"Choose Menu Save configuration or quit and restart debugger","Save prefs and restart debugger"}
0001190E <REDDebugger.ab3@3718>       Case 9
00011930 <REDDebugger.ab3@3719>         syntax_ = GTMenuChecked(0,0,9)
00011936 <REDDebugger.ab3@3720>         Gosub newsize
0001193C <REDDebugger.ab3@3721>         Gosub refwindow
0001194E <REDDebugger.ab3@3723>       Case 10
00011970 <REDDebugger.ab3@3724>         logcon = GTMenuChecked(0,0,10)
00011982 <REDDebugger.ab3@3726>       Case 11
00011988 <REDDebugger.ab3@3730>           d_quit{}
0001199A <REDDebugger.ab3@3733>       Case 12
00011A1E <REDDebugger.ab3@3734>         reply = RTEZRequest(scrtitle$,Peek.s(?hardquit),"_Quit|_Cancel",2,1,4)
00011A2E <REDDebugger.ab3@3735>         If reply Then exitflag = 1
00011A30 <REDDebugger.ab3@3737>     End Select
00011A32 <REDDebugger.ab3@3739> Return
00011A6B <REDDebugger.ab3@3742> hardquit: Dc.b "Perform hard Quit?",10,"Warning: Debug process will not",10,"exit.",0
00011A6C <REDDebugger.ab3@3743>           Even
00011A82 <REDDebugger.ab3@3747>   If ItemHit < 9
00011A8A <REDDebugger.ab3@3748>     evw = #_winControl
00011A92 <REDDebugger.ab3@3749>     ev  = 64
00011AA4 <REDDebugger.ab3@3750>     gad = ItemHit+11
00011ACC <REDDebugger.ab3@3751>     i$  = ""
00011B12 <REDDebugger.ab3@3752>     If gad = 17 Then Toggle #_winControl,17 : Redraw #_winControl,17
00011B58 <REDDebugger.ab3@3753>     If gad = 18 Then Toggle #_winControl,18 : Redraw #_winControl,18
00011B9E <REDDebugger.ab3@3754>     If gad = 19 Then Toggle #_winControl,19 : Redraw #_winControl,19
00011BA4 <REDDebugger.ab3@3755>   Else
00011BAC <REDDebugger.ab3@3756>     Select ItemHit
00011BB8 <REDDebugger.ab3@3758>       Case 10
00011BD2 <REDDebugger.ab3@3759>         If winstatus(#_winSearch) = 0
00011BDC <REDDebugger.ab3@3760>           NewWindow{#_winSearch}
00011BE8 <REDDebugger.ab3@3761>           RedrawSearchWin{?variabletypes}
00011BEE <REDDebugger.ab3@3762>         Else
00011BF8 <REDDebugger.ab3@3763>           DelWindow{#_winSearch}
00011C0A <REDDebugger.ab3@3766>       Case 11
00011C68 <REDDebugger.ab3@3767>         array$ = RTEZGetString("Arrays","Enter array name:",80)
00011CA0 <REDDebugger.ab3@3768>         If array$ <> ""
00011CEC <REDDebugger.ab3@3769>           a   = Instr(array$,"(")
00011D38 <REDDebugger.ab3@3770>           b.l = Instr(array$,",")
00011D84 <REDDebugger.ab3@3771>           c.l = Instr(array$,")")
00011D96 <REDDebugger.ab3@3772>           If b = 0
00011D9E <REDDebugger.ab3@3773>             array1 = 0
00011E00 <REDDebugger.ab3@3774>             array2 = Vallong(Mid$(array$,a+1,c-1))
00011E06 <REDDebugger.ab3@3775>           Else
00011E70 <REDDebugger.ab3@3776>             array1 = Vallong(Mid$(array$,a+1,b-a-1))
00011ED6 <REDDebugger.ab3@3777>             array2 = Vallong(Mid$(array$,b+1,c-b-1))
00011F2E <REDDebugger.ab3@3779>           array$ = Left$(array$,a-1)
00011F88 <REDDebugger.ab3@3780>           nt = RTEZRequest("Arrays","Enter variable type:","_b|_w|_l|_Cancel")
00011F98 <REDDebugger.ab3@3781>           If nt <> 0
00011FAA <REDDebugger.ab3@3782>             If array1 <> 0
00012000 <REDDebugger.ab3@3783>               d_eval{"&"+array$+"(0,0)",#SIGNAL}
00012006 <REDDebugger.ab3@3784>             Else
0001205C <REDDebugger.ab3@3785>               d_eval{"&"+array$+"(0)",#SIGNAL}
000120AA <REDDebugger.ab3@3787>             arrayitemsize = (2^nt)+1
000120B4 <REDDebugger.ab3@3788>             arraydatasize = nt
000120C2 <REDDebugger.ab3@3790>             If array1 > array2
000120C8 <REDDebugger.ab3@3791>               si = array1
000120CE <REDDebugger.ab3@3792>             Else
000120D4 <REDDebugger.ab3@3793>               si = array2
000120FA <REDDebugger.ab3@3795>             a$ = Hex$(si)
0001210C <REDDebugger.ab3@3796>             If si > 255
0001211E <REDDebugger.ab3@3797>               If si > 65535
00012124 <REDDebugger.ab3@3798>                 arraylabelsize = 4
0001212A <REDDebugger.ab3@3799>               Else
00012130 <REDDebugger.ab3@3800>                 arraylabelsize = 2
00012136 <REDDebugger.ab3@3802>             Else
0001213C <REDDebugger.ab3@3803>               arraylabelsize = 1
00012144 <REDDebugger.ab3@3805>             pos.l = 1
000121A4 <REDDebugger.ab3@3806>             While Mid$(a$,pos,1) = "0"
000121B2 <REDDebugger.ab3@3807>               pos+1
000121B8 <REDDebugger.ab3@3808>             Wend
000121CE <REDDebugger.ab3@3809>             pos = (9-pos)+1
000121E8 <REDDebugger.ab3@3810>             If pos > arrayitemsize Then arrayitemsize = pos
000121EE <REDDebugger.ab3@3811>             evalrequest = #_arrayfind
00012200 <REDDebugger.ab3@3815>       Case 12
00012208 <REDDebugger.ab3@3816>         is_bb.l = 0
0001220E <REDDebugger.ab3@3817>         Gosub NewTypeWindow
00012220 <REDDebugger.ab3@3819>       Case 13
0001223A <REDDebugger.ab3@3820>         If winstatus(#_winCustom) = 0
00012244 <REDDebugger.ab3@3821>           NewWindow{#_winCustom}
0001224A <REDDebugger.ab3@3822>           RedrawCustomWin{}
00012250 <REDDebugger.ab3@3823>         Else
0001225A <REDDebugger.ab3@3824>           DelWindow{#_winCustom}
0001226C <REDDebugger.ab3@3827>       Case 14
00012286 <REDDebugger.ab3@3828>         If winstatus(#_winMouseables) = 0
00012290 <REDDebugger.ab3@3829>           NewWindow{#_winMouseables}
00012298 <REDDebugger.ab3@3830>           RedrawMouseables{True}
0001229E <REDDebugger.ab3@3831>         Else
000122A8 <REDDebugger.ab3@3832>           DelWindow{#_winMouseables}
000122BA <REDDebugger.ab3@3835>       Case 15
000122D4 <REDDebugger.ab3@3836>         If winstatus(#fpuwin) = 0
00012334 <REDDebugger.ab3@3837>           If wininfo(#fpuwin)\w = 0 Then wininfo(#fpuwin)\w = 539 : wininfo(#fpuwin)\h = 36
00012354 <REDDebugger.ab3@3838>           wininfo(#fpuwin)\gadlist = -1
0001242C <REDDebugger.ab3@3839>           WZWindow #fpuwin,?wzdat,20,wininfo(#fpuwin)\x,wininfo(#fpuwin)\y,wininfo(#fpuwin)\w,(wininfo(#fpuwin)\h*WinFontHeight)/8,1
00012442 <REDDebugger.ab3@3840>           winstatus(#fpuwin) = -1
00012448 <REDDebugger.ab3@3841>         Else
00012452 <REDDebugger.ab3@3842>           DelWindow{#fpuwin}
00012470 <REDDebugger.ab3@3844>         If winstatus(#_winVariables) Then UpdateVarWindow{}  ; only the values are print
00012476 <REDDebugger.ab3@3845>         RedrawRegs{}
00012488 <REDDebugger.ab3@3847>       Case 16
00012492 <REDDebugger.ab3@3848>         asmstep = NOT asmstep
000124A4 <REDDebugger.ab3@3850>       Case 17
000124B8 <REDDebugger.ab3@3851>         If watch0 = False
0001250A <REDDebugger.ab3@3852>           If ask{"This feature bangs the address 0!","Go ahead!|Oopps!"}
0001251C <REDDebugger.ab3@3853>             Poke $0,$beaddeef
0001252C <REDDebugger.ab3@3854>             addr0.l  = Peek.l (0)
00012536 <REDDebugger.ab3@3855>             watch0.l = NOT watch0
0001253C <REDDebugger.ab3@3857>         Else
00012542 <REDDebugger.ab3@3858>           watch0 = False
00012544 <REDDebugger.ab3@3860>     End Select
00012546 <REDDebugger.ab3@3862> Return
00012568 <REDDebugger.ab3@3865> Statement newwizardwin{h.l,num.l,ad.l}
000125C2 <REDDebugger.ab3@3868>   If wininfo(h)\w = 0 Then wininfo(h)\w = 539 : wininfo(h)\h = 36
000125E0 <REDDebugger.ab3@3869>   wininfo(h)\gadlist = -1
0001267C <REDDebugger.ab3@3870>   WZWindow h,ad,20,wininfo(h)\x,wininfo(h)\y,wininfo(h)\w,wininfo(h)\h,num
00012692 <REDDebugger.ab3@3871>   winstatus(#fpuwin) = -1
00012696 <REDDebugger.ab3@3872> End Statement
000126B6 <REDDebugger.ab3@3876>   If objectbusy = 0 AND dstatus = #STOPPED
000126C0 <REDDebugger.ab3@3877>     mytype  = ItemHit
000126E0 <REDDebugger.ab3@3878>     address = Peek.l(?MyTypes+(mytype ASL 2))
000126EC <REDDebugger.ab3@3879>     is_bb   = -1
000126F2 <REDDebugger.ab3@3880>     Gosub NewTypeWindow
000126F4 <REDDebugger.ab3@3882> Return
000126FC <REDDebugger.ab3@3886>   Select ItemHit
00012708 <REDDebugger.ab3@3888>     Case 0 ;add trace
0001270E <REDDebugger.ab3@3889>       Gosub GetNewVariable
00012728 <REDDebugger.ab3@3890>       If winstatus(#_winVariables) = 0
00012732 <REDDebugger.ab3@3891>         NewWindow{#_winVariables}
00012744 <REDDebugger.ab3@3894>     Case 1 ;del trace
0001274A <REDDebugger.ab3@3895>       Gosub GetVariableNameAndType    ; changed to a subroutine call to get the type too  tomsmart1 2016 02 14
00012782 <REDDebugger.ab3@3896>       If na$ <> ""                    ; check if we have a name
000127A4 <REDDebugger.ab3@3897>         If nt > 0 AND nt < 7          ; check id we have a type
000127AA <REDDebugger.ab3@3898>           Gosub _Deltrace
000127C8 <REDDebugger.ab3@3900>           If a AND winstatus(#_winVariables)
000127CE <REDDebugger.ab3@3901>             RedrawVarWindow{}
000127D4 <REDDebugger.ab3@3902>             UpdateVarWindow{}
000127E6 <REDDebugger.ab3@3907>     Case 2 ; del all...
0001284C <REDDebugger.ab3@3908>       reply = RTEZRequest(varfollow$,"Clear all variables?","_Yes|_No")
0001285A <REDDebugger.ab3@3909>       If reply = 1
00012864 <REDDebugger.ab3@3910>         ClearList varinfo()
00012882 <REDDebugger.ab3@3911>         If winstatus(#_winVariables) Then RedrawVarWindow{}
00012894 <REDDebugger.ab3@3914>     Case 3 ; sort
000128A6 <REDDebugger.ab3@3915> 
000128BE <REDDebugger.ab3@3916>       If winstatus(#_winVariables)
000128C4 <REDDebugger.ab3@3917>         RedrawVarWindow{}
000128CA <REDDebugger.ab3@3918>         UpdateVarWindow{}
000128DC <REDDebugger.ab3@3921>     Case 5 ; auto eval
000128FC <REDDebugger.ab3@3922>       autoeval = GTMenuChecked(0,3,5)
0001294C <REDDebugger.ab3@3923>       If autoeval <> 0 AND na$ = "" Then Gosub DefAutoEval
0001295E <REDDebugger.ab3@3925>     Case 6
00012964 <REDDebugger.ab3@3926>       Gosub DefAutoEval
00012976 <REDDebugger.ab3@3928>     Case 8
000129E0 <REDDebugger.ab3@3929>       a$ = RTEZGetString(scrtitle$,"Enter breakpoint address:",10)
00012A18 <REDDebugger.ab3@3930>       If a$ <> ""
00012A4C <REDDebugger.ab3@3931>         ad = Vallong(a$)
00012A52 <REDDebugger.ab3@3932>         Gosub addbreakpoint
00012A64 <REDDebugger.ab3@3935>     Case 9
00012A8C <REDDebugger.ab3@3936>       t$   = "Select breakpoint to delete:"
00012A96 <REDDebugger.ab3@3937>       flag = -1
00012A9C <REDDebugger.ab3@3938>       Gosub SelectBP
00012AA6 <REDDebugger.ab3@3939>       If bp
00012AC4 <REDDebugger.ab3@3940>         ad = breakpoint_adr+((bp-1)ASL 3)
00012ACA <REDDebugger.ab3@3941>         Gosub deletebreakpoint
00012ADC <REDDebugger.ab3@3944>     Case 10
00012AEE <REDDebugger.ab3@3945>       If Peek.l(breakpoint_adr)
00012B54 <REDDebugger.ab3@3946>         a = RTEZRequest(scrtitle$,"Kill all breakpoints?","_Okay|_Cancel")
00012B5E <REDDebugger.ab3@3947>         If a
00012B70 <REDDebugger.ab3@3948>           FillMem ?breakpoint,5*8
00012B96 <REDDebugger.ab3@3949>           If winstatus(#_winDisAsm) Then UpdateDisAsm{}
00012BA8 <REDDebugger.ab3@3953>     Case 11
00012BD0 <REDDebugger.ab3@3954>       t$   = "Current breakpoints:"
00012BD6 <REDDebugger.ab3@3955>       flag = 0
00012BDC <REDDebugger.ab3@3956>       Gosub SelectBP
00012BDE <REDDebugger.ab3@3957>   End Select
00012BE0 <REDDebugger.ab3@3958> Return
00012C18 <REDDebugger.ab3@3962>   D_InitParse customcomm$(ItemHit)
00012C3A <REDDebugger.ab3@3963>   a$ = ProcessString
00012C80 <REDDebugger.ab3@3964>   Execute_ a$,0,0
00012C82 <REDDebugger.ab3@3965> Return
00012C9C <REDDebugger.ab3@3972>   If Peek.w(ad) = $4e41
00012CAA <REDDebugger.ab3@3973>     ad+2
00012CB0 <REDDebugger.ab3@3974>     a = typ
00012CBA <REDDebugger.ab3@3975>     If a
00012CC0 <REDDebugger.ab3@3976>       ad2 = breakpoint_adr
00012CC6 <REDDebugger.ab3@3977>       num = 0
00012CE4 <REDDebugger.ab3@3978>       While Peek.l(ad2) <> 0
00012CFE <REDDebugger.ab3@3979>         If Peek.l(ad2) = ad
00012D0E <REDDebugger.ab3@3980>           Poke.l ad2,0
00012D14 <REDDebugger.ab3@3981>         Else
00012D22 <REDDebugger.ab3@3982>           ad2+8
00012D30 <REDDebugger.ab3@3983>           num+1
00012D36 <REDDebugger.ab3@3985>       Wend
00012D44 <REDDebugger.ab3@3987>       Poke.l ad2,ad
00012D58 <REDDebugger.ab3@3988>       Poke.w ad2+4,a
00012D7C <REDDebugger.ab3@3989>       If a = #break_simple Then b = 1 Else b = 0
00012D90 <REDDebugger.ab3@3990>       Poke.w ad2+6,b
00012D9A <REDDebugger.ab3@3991>       flag = -1
00012D9C <REDDebugger.ab3@3994> Return
00012E20 <REDDebugger.ab3@3998>   na$ = RTEZGetString("Auto EVAL","Please enter string to evaluate:",80,autoeval$)
00012E58 <REDDebugger.ab3@3999>   If na$ <> ""
00012E8C <REDDebugger.ab3@4000>     autoeval$ = na$
00012E92 <REDDebugger.ab3@4001>     autoeval  = 1
00012E98 <REDDebugger.ab3@4002>   Else
00012E9E <REDDebugger.ab3@4003>     autoeval  = 0
00012EC6 <REDDebugger.ab3@4004>     autoeval$ = ""
00012EE8 <REDDebugger.ab3@4006>   GTSetMenuChecked 0,3,5,autoeval
00012EEA <REDDebugger.ab3@4007> Return
00012F0C <REDDebugger.ab3@4011>   If Peek.w(ad) = $4e41 OR asmstep
00012F1A <REDDebugger.ab3@4012>     ad+2
00012F80 <REDDebugger.ab3@4013>     a = RTEZRequest(scrtitle$,"Select a breakpoint or function:","_Permanent|C_ount|_Simple|Cnt _down|_Remove Stop|Set PC|_Cancel")
00012F88 <REDDebugger.ab3@4014>     b = 0
00012F96 <REDDebugger.ab3@4015>     If a = 4
00013000 <REDDebugger.ab3@4016>       a$ = RTEZGetString(scrtitle$,"Enter the counter value for this breakpoint:",20)
00013034 <REDDebugger.ab3@4017>       b = Vallong(a$)
0001304C <REDDebugger.ab3@4018>       If b = 0 Then a = 0
0001305A <REDDebugger.ab3@4020>     If a = 6
00013068 <REDDebugger.ab3@4021>       pc_ad.l = Peek.l(MyBufferAddress)
0001307C <REDDebugger.ab3@4022>       Poke.l pc_ad+64,ad
00013082 <REDDebugger.ab3@4023>       RedrawRegs{}
00013090 <REDDebugger.ab3@4024>       UpdateDisAsm{}
00013096 <REDDebugger.ab3@4025>       a = 0
000130A0 <REDDebugger.ab3@4027>     If a
000130AE <REDDebugger.ab3@4028>       If a = 5
000130EC <REDDebugger.ab3@4029>         Poke.l ad+8,$4e714e71 : Poke.w ad+12,$4e71 : UpdateDisAsm{} : disasm_ad = ad
000130F4 <REDDebugger.ab3@4030>         CacheClearU_
000130F6 <REDDebugger.ab3@4031>         Return
000130FC <REDDebugger.ab3@4033>       ad2 = breakpoint_adr
00013102 <REDDebugger.ab3@4034>       num = 0
0001312E <REDDebugger.ab3@4035>       While Peek.l(ad2) <> 0 AND num < #maxbreakpoints
00013148 <REDDebugger.ab3@4036>         If Peek.l(ad2) = ad
00013158 <REDDebugger.ab3@4037>           Poke.l ad2,0
0001315E <REDDebugger.ab3@4038>         Else
0001316C <REDDebugger.ab3@4039>           ad2+8
0001317A <REDDebugger.ab3@4040>           num+1
00013180 <REDDebugger.ab3@4042>       Wend
0001318E <REDDebugger.ab3@4043>       If num < #maxbreakpoints
000131A4 <REDDebugger.ab3@4044>         If a = #break_simple    Then b = 1
000131B8 <REDDebugger.ab3@4045>         If a = #break_countdown Then a = #break_simple
000131C6 <REDDebugger.ab3@4046>         bt1.l = ad2-breakpoint_adr
000131F2 <REDDebugger.ab3@4047>         Poke.w bt1+?breakstore,Peek.w(ad-2)
00013210 <REDDebugger.ab3@4048>         If asmstep Then Poke.w ad-2,$4e41
0001321E <REDDebugger.ab3@4049>         Poke.l ad2,ad
00013232 <REDDebugger.ab3@4050>         Poke.w ad2+4,a
00013246 <REDDebugger.ab3@4051>         Poke.w ad2+6,b
0001324C <REDDebugger.ab3@4052>       Else
000132B2 <REDDebugger.ab3@4053>         a = RTEZRequest(scrtitle$,"No spare breakpoints available.","_Okay")
000132D8 <REDDebugger.ab3@4055>       If winstatus(#_winDisAsm) Then UpdateDisAsm{}
000132DE <REDDebugger.ab3@4057>   Else
00013344 <REDDebugger.ab3@4058>     a = RTEZRequest(scrtitle$,"Can only breakpoint basic instructions.","_Okay")
00013346 <REDDebugger.ab3@4060> Return
00013354 <REDDebugger.ab3@4065>   bt1 = ad-breakpoint_adr
00013390 <REDDebugger.ab3@4066>   Poke.w Peek.l(ad)-2,Peek.w(bt1+?breakstore)
000133AE <REDDebugger.ab3@4067>   While Peek.l(ad) <> 0
000133D2 <REDDebugger.ab3@4068>     Poke.l ad,Peek.l(ad+8)
000133FC <REDDebugger.ab3@4069>     Poke.l ad+4,Peek.l(ad+12)
0001340A <REDDebugger.ab3@4070>     ad+8
00013410 <REDDebugger.ab3@4071>   Wend
00013436 <REDDebugger.ab3@4072>   If winstatus(#_winDisAsm) Then UpdateDisAsm{}
00013438 <REDDebugger.ab3@4073> Return
00013460 <REDDebugger.ab3@4079>   a$   = ""
00013488 <REDDebugger.ab3@4080>   b$   = ""
0001348E <REDDebugger.ab3@4081>   ad.l = breakpoint_adr
000134AC <REDDebugger.ab3@4082>   If Peek.l(ad) = 0
00013512 <REDDebugger.ab3@4083>     a  = RTEZRequest(scrtitle$,"No breakpoints defined.","_Okay")
00013518 <REDDebugger.ab3@4084>     bp = 0
0001351E <REDDebugger.ab3@4085>   Else
00013524 <REDDebugger.ab3@4086>     num = 0
00013542 <REDDebugger.ab3@4087>     While Peek.l(ad) <> 0
00013550 <REDDebugger.ab3@4088>       num+1
0001355E <REDDebugger.ab3@4089>       ad2 = Peek.l(ad)
00013564 <REDDebugger.ab3@4090>       Gosub GETInstruction
00013678 <REDDebugger.ab3@4092>       a$+"BP "+Str$(num)+": "+GetHex$(ad2-2,3)+" >>> "+Left$(d_d$,40)+Chr$(10)
00013706 <REDDebugger.ab3@4093>       If flag Then b$+"_"+Str$(num)+"|"
00013714 <REDDebugger.ab3@4094>       ad+8
0001371A <REDDebugger.ab3@4095>     Wend
00013728 <REDDebugger.ab3@4096>     If flag
0001376E <REDDebugger.ab3@4097>       b$+"_Cancel"
00013774 <REDDebugger.ab3@4098>     Else
0001379C <REDDebugger.ab3@4099>       b$ = "_Okay"
00013850 <REDDebugger.ab3@4101>     bp = RTEZRequest(scrtitle$,t$+Chr$(10)+a$,b$)
00013852 <REDDebugger.ab3@4103> Return
00013868 <REDDebugger.ab3@4107>   If SubHit < 4
00013872 <REDDebugger.ab3@4108>     scrmode = SubHit
00013878 <REDDebugger.ab3@4109>   Else
00013880 <REDDebugger.ab3@4110>     Select SubHit
0001388C <REDDebugger.ab3@4112>       Case 5
00013894 <REDDebugger.ab3@4113>         *myscr.screeninfo = 0
000138C2 <REDDebugger.ab3@4114>         *myscr            = RTEZScreenModeRequest("Editor screen mode",%1000010000000000000)
000138CC <REDDebugger.ab3@4115>         If *myscr
000138FE <REDDebugger.ab3@4116>           If *myscr\width >= 640 AND *myscr\height >= 200
00013908 <REDDebugger.ab3@4117>             ModeID  = *myscr\id
00013916 <REDDebugger.ab3@4118>             swidth  = *myscr\width
00013924 <REDDebugger.ab3@4119>             sheight = *myscr\height
0001392A <REDDebugger.ab3@4120>           Else
00013990 <REDDebugger.ab3@4121>             reply = RTEZRequest(scrtitle$,"Minimum screen size is 640 x 200.","_Okay")
00013992 <REDDebugger.ab3@4125>     End Select
00013998 <REDDebugger.ab3@4127>   Gosub CheckScrModeMenus
0001399A <REDDebugger.ab3@4128> Return
000139B8 <REDDebugger.ab3@4132>   If scrmode = 1 OR scrmode = 2
000139BE <REDDebugger.ab3@4133>     a = On
000139C4 <REDDebugger.ab3@4134>   Else
000139CA <REDDebugger.ab3@4135>     a = Off
000139EE <REDDebugger.ab3@4138>   GTMenuState 0,0,6,6,a
00013A12 <REDDebugger.ab3@4139>   GTMenuState 0,0,6,7,a
00013A14 <REDDebugger.ab3@4140> Return
00013A72 <REDDebugger.ab3@4144>   a = RTEZGetLongRange(scrtitle$,"Maximum window height:",200,1024,maxheight)
00013A80 <REDDebugger.ab3@4145>   If a <> 0
00013A86 <REDDebugger.ab3@4146>     maxheight = a
00013AAA <REDDebugger.ab3@4147>     BitMap 1,640,maxheight,1 ; WIDTH MUST NOT CHANGE!
00013AD8 <REDDebugger.ab3@4148>     If tokenise Then BitMap 3,640,maxheight,2
00013ADA <REDDebugger.ab3@4150> Return
00013B00 <REDDebugger.ab3@4154>   If evw >= #_winObject0 AND evw <= #_winObject9
00013B0A <REDDebugger.ab3@4155>     FindStructureWin{evw}
00013B10 <REDDebugger.ab3@4156>     RefreshTypeWindow{}
00013B12 <REDDebugger.ab3@4157>     Return
00013B18 <REDDebugger.ab3@4159>   Select evw
00013B26 <REDDebugger.ab3@4161>     Case #_winSource
00013B3C <REDDebugger.ab3@4162>       Use Window #_winSource
00013B42 <REDDebugger.ab3@4164>         Gosub newsize
00013B48 <REDDebugger.ab3@4165>         Gosub refwindow
00013B5C <REDDebugger.ab3@4168>     Case #_winMemory1
00013B72 <REDDebugger.ab3@4169>       Use Window #_winMemory1
00013B80 <REDDebugger.ab3@4170>       InnerCls
00013B86 <REDDebugger.ab3@4171>       dowin = 0
00013B8C <REDDebugger.ab3@4172>       RedrawMem{}
00013BA0 <REDDebugger.ab3@4174>     Case #_winMemory2
00013BB6 <REDDebugger.ab3@4175>       Use Window #_winMemory2
00013BC4 <REDDebugger.ab3@4176>       InnerCls
00013BCA <REDDebugger.ab3@4177>       dowin = 1
00013BD0 <REDDebugger.ab3@4178>       RedrawMem{}
00013BE4 <REDDebugger.ab3@4180>     Case #_winVariables
00013BEA <REDDebugger.ab3@4181>       RedrawVarWindow{}
00013BF0 <REDDebugger.ab3@4182>       UpdateVarWindow{}
00013C04 <REDDebugger.ab3@4184>     Case #_winDisAsm
00013C10 <REDDebugger.ab3@4185>       UpdateDisAsm{1}   ; force clear of the Window
00013C24 <REDDebugger.ab3@4187>     Case #_winDisCop
00013C2A <REDDebugger.ab3@4188>       UpdateDisCop{}
00013C3E <REDDebugger.ab3@4190>     Case #_winRegisters
00013C44 <REDDebugger.ab3@4191>       InitRegsWin{}
00013C4A <REDDebugger.ab3@4192>       RedrawRegs{}
00013C5E <REDDebugger.ab3@4194>     Case #_winSearch
00013C6A <REDDebugger.ab3@4195>       RedrawSearchWin{?variabletypes}
00013C7E <REDDebugger.ab3@4197>     Case #_winArray
00013C88 <REDDebugger.ab3@4198>       RedrawArray{1}
00013C9C <REDDebugger.ab3@4200>     Case #_winCustom
00013CA2 <REDDebugger.ab3@4201>       RedrawCustomWin{}
00013CB6 <REDDebugger.ab3@4203>     Case #_winMouseables
00013CBC <REDDebugger.ab3@4204>       mouseables_off = 0
00013CC4 <REDDebugger.ab3@4205>       RedrawMouseables{True}
00013CC6 <REDDebugger.ab3@4207>   End Select
00013CC8 <REDDebugger.ab3@4208> Return
00013D1A <REDDebugger.ab3@4212>   a = Vallong(Right$(strg$,1))
00013D38 <REDDebugger.ab3@4213>   If a >= 0 AND a <= 7
00013D46 <REDDebugger.ab3@4214>     ad              = Peek.l(MyBufferAddress)
00013DB4 <REDDebugger.ab3@4215>     mempointer(cur) = Peek.l(ad+32+(32*(a$="d"))+(a ASL 2))
00013DE4 <REDDebugger.ab3@4216>     If mflag Then mempointer(cur) = Peek.l(mempointer(cur))
00013DEA <REDDebugger.ab3@4217>   Else
00013E50 <REDDebugger.ab3@4218>     reply = RTEZRequest(scrtitle$,"Invalid register number!","Ok")
00013E52 <REDDebugger.ab3@4220> Return
00013E7A <REDDebugger.ab3@4225>   syntax_$ = ""
00013E84 <REDDebugger.ab3@4226>   If i
00013EC2 <REDDebugger.ab3@4227>     toke.w   = Peek.w(getad{i}+Peek.w(i+4))
00013EC8 <REDDebugger.ab3@4229>     tokead.l = token_addr
00013ED6 <REDDebugger.ab3@4230>     toke = toke AND $7fff
00013F00 <REDDebugger.ab3@4231>     While (tokead <> 0 AND toke <> -1)
00013F20 <REDDebugger.ab3@4232>       If Peek.w(tokead+4) = toke
00013F4E <REDDebugger.ab3@4233>         syntax_$ = Peek.s(tokead+6)
00013FF0 <REDDebugger.ab3@4234>         syntax_$+" "+Peek.s(tokead+7+Len(syntax_$))
00013FFA <REDDebugger.ab3@4235>         toke = -1
00014008 <REDDebugger.ab3@4237>       tokead = Peek.l(tokead)
0001400E <REDDebugger.ab3@4238>     Wend
00014014 <REDDebugger.ab3@4240>   Gosub syntaxprint
00014016 <REDDebugger.ab3@4241> Return
00014032 <REDDebugger.ab3@4245>   If (Peek.l(Addr Window(#_winSource)))
00014048 <REDDebugger.ab3@4246>     Use Window #_winSource
0001407C <REDDebugger.ab3@4247>     lt$ = t$
00014082 <REDDebugger.ab3@4248>     y.l = wprinty.l
00014088 <REDDebugger.ab3@4249>     Gosub printlin
0001409A <REDDebugger.ab3@4250>     If syntax_ = 0
0001409C <REDDebugger.ab3@4252>       Return
000140B2 <REDDebugger.ab3@4256>     Use Window #_winSource
000140D8 <REDDebugger.ab3@4257>     y  = wprinty-WinFontHeight-5
0001410C <REDDebugger.ab3@4258>     t$ = syntax_$
00014112 <REDDebugger.ab3@4259>     Gosub printlin
00014114 <REDDebugger.ab3@4261> Return
00014160 <REDDebugger.ab3@4267>   Wline ix.l,y-1,ix+iw.l-1,y-1,1
000141A0 <REDDebugger.ab3@4268>   Wline ix.l,y,ix+iw-1,y,2
000141F2 <REDDebugger.ab3@4269>   WBox ix,y+1,ix+iw-1,y+WinFontHeight+2,0
00014206 <REDDebugger.ab3@4270>   b = FLen(t$)
00014292 <REDDebugger.ab3@4271>   a = TextFit_(RastPort(#_winSource),t$,b,&myextent.TextExtent,0,1,iw-2,1024)
000142BE <REDDebugger.ab3@4273>   WLocate 1,y-iy+2 : WColour 1,0
000142D0 <REDDebugger.ab3@4274>   If b < a
00014314 <REDDebugger.ab3@4275>     Print t$
0001431A <REDDebugger.ab3@4276>   Else
0001437C <REDDebugger.ab3@4277>     Print Left$(t$,a)
0001437E <REDDebugger.ab3@4279> Return
00014386 <REDDebugger.ab3@4284>   Restore buttondata
00014394 <REDDebugger.ab3@4286>   BorderPens 2,1
000143A2 <REDDebugger.ab3@4287>   Borders 4,5
000143AC <REDDebugger.ab3@4288>   GadgetsHeight.l = 5*2 +8 ; 5= border top and buttom,  8= topaz fontYSize
000143C2 <REDDebugger.ab3@4289>   gx.l = WinBorLeft : gn.l = 1 : wy = WinBorTextTop.l;+2
000143E4 <REDDebugger.ab3@4291>     Read t$
0001441C <REDDebugger.ab3@4292>     If t$ <> ""
00014424 <REDDebugger.ab3@4293>       gf.l = 0
000144CC <REDDebugger.ab3@4294>       If t$ = "GS" OR t$ = "PS" OR t$ = "BC" Then gf = %1
00014574 <REDDebugger.ab3@4295>       TextGadget #_winControl,gx,wy,gf,gn,t$ : gx+Len(t$)LSL 3+4*2; 4 = border left and right
00014582 <REDDebugger.ab3@4296>       gn+1
000145C0 <REDDebugger.ab3@4298>   Until t$ = ""
000145CE <REDDebugger.ab3@4301>   BorderPens 1,2
00014604 <REDDebugger.ab3@4302>   StringGadget 3, 88,wy   ,0,0, 10,160
00014640 <REDDebugger.ab3@4303>   StringGadget 3, 88,wy+14,0,1, 10,160
00014676 <REDDebugger.ab3@4305>   StringGadget 2,160,wy   ,0,1, 40,160
000146B2 <REDDebugger.ab3@4306>   StringGadget 2,160,wy+14,0,4, 40,160
000146EE <REDDebugger.ab3@4308>   StringGadget 2,160,wy+34,0,7,256,160
000146FC <REDDebugger.ab3@4310>   BorderPens 2,1
0001474E <REDDebugger.ab3@4311>   TextGadget 2,160,wy+48,0, 8,"  "
0001479A <REDDebugger.ab3@4313>   TextGadget 2,332,wy   ,0, 2,"MEM1"
000147E6 <REDDebugger.ab3@4314>   TextGadget 2,372,wy   ,0, 3,"MEM2"
00014838 <REDDebugger.ab3@4315>   TextGadget 2,332,wy+14,0, 5,"MEM1"
0001488A <REDDebugger.ab3@4316>   TextGadget 2,372,wy+14,0, 6,"MEM2"
00014898 <REDDebugger.ab3@4318>   Borders 8,4
000148EA <REDDebugger.ab3@4319>   TextGadget 2,150,wy+69,0,10," Start search "
000148F8 <REDDebugger.ab3@4320>   Borders 4,2
00014984 <REDDebugger.ab3@4323>   PropGadget  #_winArray,-13,wy+1,#VPROP_AFLAGS,#ARR_YGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
000149C0 <REDDebugger.ab3@4325>   ArrowGadget #_winArray,#ARR_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
000149FE <REDDebugger.ab3@4326>   ArrowGadget #_winArray,#ARR_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
00014A42 <REDDebugger.ab3@4328>   PropGadget  #_winArray,3,-7,#HPROP_AFLAGS,#ARR_XGAD,-22-33,6,#HPROP_PFLAGS,3
00014A80 <REDDebugger.ab3@4330>   ArrowGadget #_winArray,#ARR_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
00014ABE <REDDebugger.ab3@4331>   ArrowGadget #_winArray,#ARR_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
00014ADE <REDDebugger.ab3@4332>   SetPropInfo #_winArray,#ARR_YGAD,1,1
00014AFE <REDDebugger.ab3@4333>   SetPropInfo #_winArray,#ARR_XGAD,1,1
00014B42 <REDDebugger.ab3@4336>   PropGadget  #_winSource,3,-7,#HPROP_AFLAGS,#SRC_SGAD,-22-33,6,#HPROP_PFLAGS,3
00014B80 <REDDebugger.ab3@4337>   ArrowGadget #_winSource,#SRC_LGAD,#LEFTIMAGE,-49,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
00014BBE <REDDebugger.ab3@4338>   ArrowGadget #_winSource,#SRC_RGAD,#RIGHTIMAGE,-33,-9,#RIGHTREL|#BOTTOMREL|#BOTTOMBORDER,$2
00014C4A <REDDebugger.ab3@4341>   PropGadget  #_winMouseables,-13,wy+1,#VPROP_AFLAGS,#MSE_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
00014C86 <REDDebugger.ab3@4342>   ArrowGadget #_winMouseables,#MSE_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
00014CC4 <REDDebugger.ab3@4343>   ArrowGadget #_winMouseables,#MSE_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
00014CC6 <REDDebugger.ab3@4344> Return
00014CCE <REDDebugger.ab3@4357>   dreg     = 0
00014CF6 <REDDebugger.ab3@4358>   pubname$ = ""
00014D0C <REDDebugger.ab3@4360>   Use IntuiFont 1
00014D12 <REDDebugger.ab3@4361>   Select scrmode
00014D1E <REDDebugger.ab3@4363>     Case #SCR_WB
00014D58 <REDDebugger.ab3@4364>       FindScreen 0,"Workbench"
00014D80 <REDDebugger.ab3@4365>       pubname$ = "Workbench"
00014D8A <REDDebugger.ab3@4366>       dreg     = &pubname$
00014D9C <REDDebugger.ab3@4368>     Case #SCR_DEFPUB
00014DA4 <REDDebugger.ab3@4369>       dreg = 0
00014DB6 <REDDebugger.ab3@4371>     Case #SCR_NAMEDPUB
00014DC0 <REDDebugger.ab3@4372>       dreg = &pubscreenname$
00014DC2 <REDDebugger.ab3@4373>   End Select
00014DE6 <REDDebugger.ab3@4375>   If ExecVersion < 39 AND scrmode = #SCR_LIKEWB
00014E02 <REDDebugger.ab3@4376>     ModeID = $8000 : swidth = 640 : sheight = DispHeight
00014E20 <REDDebugger.ab3@4379>   If scrmode = #SCR_LIKEWB OR scrmode = #SCR_CUSTOM
00014E4E <REDDebugger.ab3@4380>     If scrmode = #SCR_LIKEWB AND ExecVersion >= 39
00014E58 <REDDebugger.ab3@4381>       si = ?myscreentags1
00014E5E <REDDebugger.ab3@4385>     Else
00014E74 <REDDebugger.ab3@4386>       If ExecVersion < 39
00014E7E <REDDebugger.ab3@4387>         si = ?myscreentagsv37
00014E84 <REDDebugger.ab3@4388>       Else
00014E8E <REDDebugger.ab3@4389>         si = ?myscreentags2
00014E94 <REDDebugger.ab3@4391>       Gosub SetupScreenTags
00014EA6 <REDDebugger.ab3@4397>     If pubscreen.l = 0
00014EBC <REDDebugger.ab3@4398>       Poke.l si+4,0
00014EC2 <REDDebugger.ab3@4399>     Else
00014ED8 <REDDebugger.ab3@4400>       Poke.l si+4,?pubname
00014F3A <REDDebugger.ab3@4403>     If ScreenTags(0,scrtitle$,si)<1024
00014F42 <REDDebugger.ab3@4404>       ModeID  = $8000
00014F48 <REDDebugger.ab3@4405>       swidth  = 640
00014F56 <REDDebugger.ab3@4406>       sheight = DispHeight
00014F5C <REDDebugger.ab3@4407>       Gosub SetupScreenTags
00014FAA <REDDebugger.ab3@4408>       ScreenTags 0,scrtitle$,si
00014FC2 <REDDebugger.ab3@4411>     s0.l = Peek.l(Addr Screen(0))
00014FCC <REDDebugger.ab3@4412>     If pubscreen
00014FE6 <REDDebugger.ab3@4413>       PubScreenStatus_ s0,0
0001500E <REDDebugger.ab3@4414>       pubname$ = "REDDebugger"
00015036 <REDDebugger.ab3@4417>     sw = Peek.w(s0+12) : sh = Peek.w(s0+14)
0001509C <REDDebugger.ab3@4419>       Window #_winBackdrop,0,0,sw,sh,$200900,"",1,2
000150A2 <REDDebugger.ab3@4423>   Else
000150D6 <REDDebugger.ab3@4424>     If GetPubScreen(0,dreg) = 0
000150F8 <REDDebugger.ab3@4425>       GetPubScreen 0,0
00015100 <REDDebugger.ab3@4426>       dreg = 0
00015118 <REDDebugger.ab3@4428>     s0 = Peek.l(Addr Screen(0))
00015142 <REDDebugger.ab3@4436>   AddProcessPtr "s",&pubname$
0001516A <REDDebugger.ab3@4438>   sw = Peek.w(s0+12) : sh = Peek.w(s0+14)
0001516C <REDDebugger.ab3@4439> Return
00015182 <REDDebugger.ab3@4443>   Poke.l ?scrmodeid+4,ModeID
00015184 <REDDebugger.ab3@4446> Return
0001518C <REDDebugger.ab3@4450>               Dc.l  #SA_PubName,pubname ; MUST BE FIRST TAG!
00015194 <REDDebugger.ab3@4451>               Dc.l  #SA_Type,#PUBLICSCREEN
0001519C <REDDebugger.ab3@4452>               Dc.l  #LikeWorkbench,1
000151A4 <REDDebugger.ab3@4454>               Dc.l  #AutoScroll,-1
000151AC <REDDebugger.ab3@4456>               Dc.l #SA_SharePens,-1
000151B4 <REDDebugger.ab3@4457>               Dc.l  0,0
000151BC <REDDebugger.ab3@4460>               Dc.l  #Pens,pens
000151C4 <REDDebugger.ab3@4463>               Dc.l  #SA_PubName,pubname ; MUST BE FIRST TAG!
000151CC <REDDebugger.ab3@4464>               Dc.l  #SA_Type,#PUBLICSCREEN
000151D4 <REDDebugger.ab3@4465>               Dc.l  #LikeWorkbench,1
000151DC <REDDebugger.ab3@4467>   scrmodeid:  Dc.l  #DisplayID,0
000151E4 <REDDebugger.ab3@4470>               Dc.l  #AutoScroll,-1
000151EC <REDDebugger.ab3@4471>               Dc.l #SA_SharePens,-1
000151F4 <REDDebugger.ab3@4473>               Dc.l  0,0
00015200 <REDDebugger.ab3@4475> pubname:      Dc.b  "ab2debugger",0
00015202 <REDDebugger.ab3@4478> pens:         Dc.w  -1
0001524E <REDDebugger.ab3@4483>   If ali <> 0 OR lt$ <> ""
00015264 <REDDebugger.ab3@4484>     Use Window #_winSource:
000152C0 <REDDebugger.ab3@4486>     WBox ix,iy+(ch.l/WinFontHeight ),ix+iw-1,y,0
000152D6 <REDDebugger.ab3@4487>     If ali Then i = ali : Gosub prtcode
000152E0 <REDDebugger.ab3@4488>     If syntax_
00015306 <REDDebugger.ab3@4489>       y = wprinty-6-WinFontHeight
0001530C <REDDebugger.ab3@4490>     Else
0001531A <REDDebugger.ab3@4491>       y = wprinty-1
00015354 <REDDebugger.ab3@4494>     t$ = lt$ : Gosub wprint
00015366 <REDDebugger.ab3@4496>   WLocate 0,0
00015368 <REDDebugger.ab3@4497> Return
0001538E <REDDebugger.ab3@4504>   If evw = #_winSource OR evw=#_winControl
0001539C <REDDebugger.ab3@4505>     If flag
000153A2 <REDDebugger.ab3@4509>         d_quit{}
000153A8 <REDDebugger.ab3@4512>   Else
000153CE <REDDebugger.ab3@4513>     If evw >= #_winObject0 AND evw <= #_winObject9
000153D8 <REDDebugger.ab3@4514>       FindStructureWin{evw}
00015410 <REDDebugger.ab3@4515>       FreeMem objwins()\mem_type,(objwins()\numitems ASL 2)+4
0001541A <REDDebugger.ab3@4516>       KillItem objwins()
00015424 <REDDebugger.ab3@4518>     DelWindow{evw}
0001544A <REDDebugger.ab3@4519>     If evw >= #_winObject0 AND evw <= #_winObject9
0001545C <REDDebugger.ab3@4520>       Free GadgetList evw
0001545E <REDDebugger.ab3@4523> Return
0001549A <REDDebugger.ab3@4527>   wininfo(#_winMemory1)   \title = "Memory 1"
000154D6 <REDDebugger.ab3@4528>   wininfo(#_winMemory2)   \title = "Memory 2"
0001557A <REDDebugger.ab3@4529> 
000155E0 <REDDebugger.ab3@4530>   wininfo(#_winRegisters) \flags = $20002f, "Register Window", -1 ,?help_reg
00015644 <REDDebugger.ab3@4531>   wininfo(#_winSource)    \flags = $0002f, "Sourcecode View", #_winSource, ?help_source
000156B6 <REDDebugger.ab3@4532>   wininfo(#_winVariables) \flags = $20002f, varfollow$, -1, ?help_var
0001571C <REDDebugger.ab3@4533>   wininfo(#_winDisAsm)    \flags = $20002f, "Disassembly", -1, ?help_asm
00015782 <REDDebugger.ab3@4534>   wininfo(#_winDisCop)    \flags = $20002f, "Copper Instructions",-1, ?help_cop
0001581E <REDDebugger.ab3@4535> 
00015882 <REDDebugger.ab3@4536>   wininfo(#_winArray)     \flags = $20003f, "Array", #_winArray, ?help_array
0001591E <REDDebugger.ab3@4537> 
00015982 <REDDebugger.ab3@4538>   wininfo(#_winMouseables)\flags = $20003f, "Label List", #_winMouseables, ?help_labels
0001598E <REDDebugger.ab3@4540>   ad2 = -1
000159C4 <REDDebugger.ab3@4541>   If dos_Exist{my_path$} ; Path changed (Marco 21.01.15)
00015A58 <REDDebugger.ab3@4542>     If ReadFile(0,dos_AddPart{my_path$,"RED_DBug.prefs"} ) ; Path changed (Marco 21.01.15)
00015A7C <REDDebugger.ab3@4544>         ad2 = AllocVec_(configsize+4096,#MEMF_PUBLIC|#MEMF_CLEAR)
00015A82 <REDDebugger.ab3@4545>         ad  = ad2
00015AA2 <REDDebugger.ab3@4546>         ReadMem 0,ad2,configsize
00015B22 <REDDebugger.ab3@4547>         If Peek.w(ad2) <> ( (Vallong("\\__VER_MAJOR") ASL 8) + Vallong("\\__VER_MINOR") )
00015B32 <REDDebugger.ab3@4548>           FreeVec_ ad2
00015B3E <REDDebugger.ab3@4549>           ad2 = -1
00015BD2 <REDDebugger.ab3@4552>       If ReadFile(0,dos_AddPart{my_path$,"RED_DBug2.prefs"} ) ; Path changed (Marco 21.01.15)
00015C02 <REDDebugger.ab3@4553>         ReadType 0,prefs
00015C1A <REDDebugger.ab3@4555>         CloseFile 0
00015C32 <REDDebugger.ab3@4557>       CloseFile 0
00015C84 <REDDebugger.ab3@4563>   If prefs\fontname >< "" AND prefs\fontsize > 4
00015C90 <REDDebugger.ab3@4564>     ta.TextAttr\ta_Name = &prefs\fontname
00015CA2 <REDDebugger.ab3@4565>     ta\ta_YSize         = prefs\fontsize
00015CAE <REDDebugger.ab3@4566>     ta\ta_Style         = 0
00015CBA <REDDebugger.ab3@4567>     ta\ta_Flags         = 0
00015CD0 <REDDebugger.ab3@4568>     *testfont.TextFont  = OpenDiskFont_ (ta)
00015CD6 <REDDebugger.ab3@4569>   Else
00015CDE <REDDebugger.ab3@4570>     *testfont = 0
00015CF0 <REDDebugger.ab3@4573>   If *testfont = 0 ; unable to open font => use system default
00015D02 <REDDebugger.ab3@4574>     InitRastPort_ testrp.RastPort  ; no (*)pointer else it get zeropagehits and crashs
00015D1E <REDDebugger.ab3@4575>     AskFont_ testrp,ta.TextAttr ; might be better
00015D48 <REDDebugger.ab3@4576>     prefs\fontname = Peek.s(ta\ta_Name)
00015D5C <REDDebugger.ab3@4577>     prefs\fontsize = ta\ta_YSize
00015DB0 <REDDebugger.ab3@4580>   LoadFont 1,prefs\fontname,prefs\fontsize
00015E08 <REDDebugger.ab3@4581>   LoadFont 2,prefs\fontname,prefs\fontsize,#FSF_BOLD
00015E60 <REDDebugger.ab3@4582>   LoadFont 3,prefs\fontname,prefs\fontsize,#FSF_ITALIC
00015E74 <REDDebugger.ab3@4584>   If ad2 = -1
00015E7E <REDDebugger.ab3@4585>     ad = ?initstate
00015E84 <REDDebugger.ab3@4586>     defaultuse.l = True         ; added to indicate that we use default settings to arrange the Windows  tomsmart1 2016 03 15
00015E8A <REDDebugger.ab3@4587>   Else
00015E90 <REDDebugger.ab3@4588>     defaultuse   = False
00015E98 <REDDebugger.ab3@4591>   startcode = 0
00015EAC <REDDebugger.ab3@4592>   scrmode   = Peek.w(ad+2)
00015EBA <REDDebugger.ab3@4593>   ad+4
00015EC8 <REDDebugger.ab3@4594>   ModeID    = Peek.l(ad)
00015EDC <REDDebugger.ab3@4595>   swidth    = Peek.w(ad+4)
00015EF0 <REDDebugger.ab3@4596>   sheight   = Peek.w(ad+6)
00015F06 <REDDebugger.ab3@4597>   tokenise  = Peek.b(ad+8)
00015F0C <REDDebugger.ab3@4598>   tokenise  = 1
00015F24 <REDDebugger.ab3@4599>   pubscreen = Peek.b(ad+9)
00015F38 <REDDebugger.ab3@4600>   maxheight = Peek.w(ad+10)
00015F5C <REDDebugger.ab3@4601>   BitMap 1,640,maxheight,1 ; WIDTH MUST NOT CHANGE!
00015F8A <REDDebugger.ab3@4602>   If tokenise Then BitMap 3,640,maxheight,2
00015F90 <REDDebugger.ab3@4603>   Gosub findsc
00015F96 <REDDebugger.ab3@4604>   address.l = ad
00015F9C <REDDebugger.ab3@4605>   Gosub openmenus
00015FA2 <REDDebugger.ab3@4606>   ad = address
00015FE4 <REDDebugger.ab3@4609>   LoadFont 0,"topaz.font",8
00015FEA <REDDebugger.ab3@4612>   Gosub initgads
00015FFE <REDDebugger.ab3@4613>   num = Peek.w(ad+12)
0001600C <REDDebugger.ab3@4614>   ad+14
0001603C <REDDebugger.ab3@4616>   For h = 0 To num-1                           ; copy and set the window position and dimentions
00016062 <REDDebugger.ab3@4617>     winstatus(h) = Peek.w(ad) : ad+2
0001607A <REDDebugger.ab3@4618>     If (#noresize BitTst h)
000160B8 <REDDebugger.ab3@4619>       wininfo(h)\h + WinBorTextTop + WinBorBottom
000160BE <REDDebugger.ab3@4620>     Else
000160FC <REDDebugger.ab3@4621>       wininfo(h)\w = Peek.w(ad+4),Peek.w(ad+6)
00016110 <REDDebugger.ab3@4623> 
00016144 <REDDebugger.ab3@4624>       wininfo(h)\x = Peek.w(ad),Peek.w(ad+2)
0001614A <REDDebugger.ab3@4625>     Else
0001615C <REDDebugger.ab3@4626>       If h = #_winControl                      ; check if we have the control window
0001617E <REDDebugger.ab3@4627>         wininfo(h)\x = 0,ScreenBarHeight       ; to open the control window not over the screenbar
00016184 <REDDebugger.ab3@4628>       Else
000161B8 <REDDebugger.ab3@4629> 
000161C6 <REDDebugger.ab3@4633>     ad+8
000161D6 <REDDebugger.ab3@4634>   Next h
000161EC <REDDebugger.ab3@4636>   MaxLen disasmlock$   = 85
00016202 <REDDebugger.ab3@4637>   MaxLen disasmlockpf$ = 85
00016246 <REDDebugger.ab3@4638>   procstatus     = Peek.b(ad) : ad+1 : If procstatus   Then Toggle #_winControl,18,On
0001628A <REDDebugger.ab3@4639>   blitzcontrol   = Peek.b(ad) : ad+1 : If blitzcontrol Then Toggle #_winControl,19,On
000162CE <REDDebugger.ab3@4640>   gosubstatus    = Peek.b(ad) : ad+1 : If gosubstatus  Then Toggle #_winControl,17,On
000162EE <REDDebugger.ab3@4641>   defpubscreen.l = Peek.b(ad) : ad+1
0001630E <REDDebugger.ab3@4642>   syntax_        = Peek.b(ad) : ad+1
00016336 <REDDebugger.ab3@4645>   disasmlock$ = Peek.s(ad)
00016396 <REDDebugger.ab3@4646>   If disasmlock$ = "" Then disasmlock$ = "pc-2"
000163CE <REDDebugger.ab3@4647>   Poke$ ?disasmlockstr,disasmlock$
00016404 <REDDebugger.ab3@4648>   ConvToPostFix disasmlock$,&evalbuffer$
0001642E <REDDebugger.ab3@4649>   i = PFEvaluate(Peek.s(&evalbuffer$))
00016458 <REDDebugger.ab3@4650>   disasmlockpf$ = Peek.s(&evalbuffer$)
00016490 <REDDebugger.ab3@4651>   If disasmlock$ <> ""
000164FC <REDDebugger.ab3@4652>     wininfo(#_winDisAsm)\title = "Disassembly ("+disasmlock$+")"
00016504 <REDDebugger.ab3@4653>     initdiss.l                 = 20
00016512 <REDDebugger.ab3@4656>   ad+128
00016522 <REDDebugger.ab3@4657>   num2.l = Peek.w(ad)
00016530 <REDDebugger.ab3@4658>   ad+2
0001655E <REDDebugger.ab3@4659>   For h = 23 To num2-1
00016584 <REDDebugger.ab3@4660>     winstatus(h) = Peek.w(ad) : ad+2
0001659C <REDDebugger.ab3@4661>     If (#noresize BitTst h)
000165DA <REDDebugger.ab3@4662>       wininfo(h)\h + WinBorTextTop + WinBorBottom
000165E0 <REDDebugger.ab3@4663>     Else
0001661E <REDDebugger.ab3@4664>       wininfo(h)\w = Peek.w(ad+4),Peek.w(ad+6)
00016652 <REDDebugger.ab3@4667>     wininfo(h)\x = Peek.w(ad),Peek.w(ad+2)
00016660 <REDDebugger.ab3@4669>     ad+8
00016670 <REDDebugger.ab3@4670>   Next h
00016694 <REDDebugger.ab3@4672>   If ad2 <> -1 Then FreeVec_ ad2
000166B2 <REDDebugger.ab3@4674>   If scrmode = #SCR_LIKEWB OR scrmode = #SCR_CUSTOM
000166D6 <REDDebugger.ab3@4675>     If pubscreen AND defpubscreen Then SetDefaultPubScreen_ ?pubname
000166DC <REDDebugger.ab3@4676>   Else
000166FC <REDDebugger.ab3@4677>     ReleasePubScreen 0,dreg
0001672A <REDDebugger.ab3@4680>   For h = 23 To num2-1
00016758 <REDDebugger.ab3@4681>       If winstatus(h) AND (#winprotect BitTst h) = 0
0001676E <REDDebugger.ab3@4682>          newwizardwin{h,1,?wzdat}
00016774 <REDDebugger.ab3@4683>         evw = h
00016784 <REDDebugger.ab3@4685>   Next h
0001678E <REDDebugger.ab3@4687>   NewWindow{#_winControl}
000167BE <REDDebugger.ab3@4689>   For h = 0 To num-1
000167EC <REDDebugger.ab3@4690>     If winstatus(h) AND (#winprotect BitTst h) = 0
00016812 <REDDebugger.ab3@4691>       If h = #_winMemory1 OR h = #_winMemory2
0001681C <REDDebugger.ab3@4692>         NewMemWindow{h}
00016822 <REDDebugger.ab3@4693>       Else
0001682C <REDDebugger.ab3@4694>         NewWindow{h}
00016832 <REDDebugger.ab3@4695>         evw = h
00016838 <REDDebugger.ab3@4696>         Gosub CorruptWindow
0001683E <REDDebugger.ab3@4698>     Else
00016850 <REDDebugger.ab3@4699>       winstatus(h) = 0
00016860 <REDDebugger.ab3@4701>   Next h
00016880 <REDDebugger.ab3@4703>   GTSetMenuChecked 0,0, 8  ,tokenise
000168A4 <REDDebugger.ab3@4704>   GTSetMenuChecked 0,0, 6,6,pubscreen
000168C8 <REDDebugger.ab3@4705>   GTSetMenuChecked 0,0, 6,7,defpubscreen
000168E8 <REDDebugger.ab3@4706>   GTSetMenuChecked 0,0, 9  ,syntax_
00016908 <REDDebugger.ab3@4707>   GTSetMenuChecked 0,0,10  ,logcon
0001692C <REDDebugger.ab3@4708>   GTSetMenuChecked 0,0, 6  ,scrmode,On
0001694C <REDDebugger.ab3@4709>   GTSetMenuChecked 0,1,16  ,asmstep
00016952 <REDDebugger.ab3@4710>   Gosub CheckScrModeMenus
00016968 <REDDebugger.ab3@4712>   Use Window #_winSource
00016972 <REDDebugger.ab3@4715>   CatchDosErrs
00016974 <REDDebugger.ab3@4719> Return
000169BE <REDDebugger.ab3@4723>   If rememberInnerWidth.l >< InnerWidth OR rememberInnerHeight.l >< InnerHeight
000169D4 <REDDebugger.ab3@4724>     Use Window #_winSource ; : InnerCls
000169E4 <REDDebugger.ab3@4726>     rememberInnerWidth.l  = InnerWidth
000169F4 <REDDebugger.ab3@4727>     rememberInnerHeight.l = InnerHeight
00016A52 <REDDebugger.ab3@4728>     ix = WLeftOff : iy = WTopOff : iw = InnerWidth : ih = InnerHeight-WinFontHeight-5
00016A66 <REDDebugger.ab3@4730>     wprinty = iy+ih+2
00016A96 <REDDebugger.ab3@4732>     If syntax_ Then ih-WinFontHeight-5
00016ACA <REDDebugger.ab3@4733>     cw = iw/8 : ch = ih/WinFontHeight
00016B02 <REDDebugger.ab3@4734>     ym = ch LSR 1 : If ch&1 = 0 Then ym-1
00016B68 <REDDebugger.ab3@4735>     ym*WinFontHeight:spc$=String$(" ",cw)
00016B6E <REDDebugger.ab3@4736>     Gosub printsourcewin
00016B92 <REDDebugger.ab3@4737>     SetPropInfo #_winSource,1,cw,1000,source_char_offset
00016BAE <REDDebugger.ab3@4738>     Redraw #_winSource,1
00016BB0 <REDDebugger.ab3@4740> Return
00016BE6 <REDDebugger.ab3@4745>   GTMenuTitle       0,0    ,"Project"
00016C4E <REDDebugger.ab3@4746>    GTMenuItem 0,    0,0,0  ,"Status register"     ,"" ,    0,?help_menus
00016CB6 <REDDebugger.ab3@4747>    GTMenuItem 0,    0,0,1  ,"About Debugger"      ,"" ,    0,?help_about
00016CD6 <REDDebugger.ab3@4748>    GTMenuItem 0,    0,0,2
00016D3E <REDDebugger.ab3@4749>    GTMenuItem 0,    0,0,3  ,"Keyboard shortcuts"  ,""  ,    0,?help_menus
00016D5E <REDDebugger.ab3@4750>    GTMenuItem 0,    0,0,4
00016DC6 <REDDebugger.ab3@4751>    GTMenuItem 0,    0,0,5  ,"Save configuration"  ,"W" ,    0,?help_configuration
00016E2E <REDDebugger.ab3@4752>    GTMenuItem 0,    0,0,6  ,"Screen mode..."      ,""  ,    0,?help_screenmode
00016E9C <REDDebugger.ab3@4754>     GTSubItem  0,   %1,0,6,0,"Workbench"           ,""  ,%1110,?help_screenmode
00016F0A <REDDebugger.ab3@4755>     GTSubItem  0,   %1,0,6,1,"Like Workbench"      ,""  ,%1101,?help_screenmode
00016F78 <REDDebugger.ab3@4756>     GTSubItem  0,   %1,0,6,2,"Custom"              ,""  ,%1011,?help_screenmode
00016FE6 <REDDebugger.ab3@4757>     GTSubItem  0,   %1,0,6,3,"Default public"      ,""  ,%0111,?help_screenmode
0001700A <REDDebugger.ab3@4758>     GTSubItem  0,   %1,0,6,4
00017078 <REDDebugger.ab3@4759>     GTSubItem  0,   %0,0,6,5,"Select custom..."    ,""  ,    0,?help_screenmode
000170E6 <REDDebugger.ab3@4760>     GTSubItem  0,%1001,0,6,6,"Public screen"       ,""  ,    0,?help_screenmode
00017154 <REDDebugger.ab3@4761>     GTSubItem  0,%1001,0,6,7,"Default pubscreen"   ,""  ,    0,?help_screenmode
000171BC <REDDebugger.ab3@4763>    GTMenuItem 0,    0,0, 7 ,"Window height..."    ,""  ,    0,?help_screenmode
00017224 <REDDebugger.ab3@4764>    GTMenuItem 0,    0,0, 8 ,"Choose Font"         ,""  ,    0,?help_menus
0001728C <REDDebugger.ab3@4765>    GTMenuItem 0,%1001,0, 9 ,"Show syntax"         ,""  ,    0,?help_menus
000172CA <REDDebugger.ab3@4766>    GTMenuItem 0,%1001,0,10 ,"Trace Log"
00017308 <REDDebugger.ab3@4767>    GTMenuItem 0,    0,0,11 ,"Quit"
0001733E <REDDebugger.ab3@4771>   GTMenuTitle       0,1    ,"Windows"
000173A6 <REDDebugger.ab3@4772>    GTMenuItem 0,    0,1, 0 ,"Registers"           ,"D" ,    0,?help_reg
0001740E <REDDebugger.ab3@4773>    GTMenuItem 0,    0,1, 1 ,"Memory 1"            ,"M" ,    0,?help_mem
00017476 <REDDebugger.ab3@4774>    GTMenuItem 0,    0,1, 2 ,"Memory 2"            ,"N" ,    0,?help_mem
000174DE <REDDebugger.ab3@4775>    GTMenuItem 0,    0,1, 3 ,"Variables"           ,"V" ,    0,?help_var
00017546 <REDDebugger.ab3@4776>    GTMenuItem 0,    0,1, 4 ,"Disassembly"         ,"6" ,    0,?help_asm
000175AE <REDDebugger.ab3@4777>    GTMenuItem 0,    0,1, 5 ,"Copper"              ,"C" ,    0,?help_cop
00017616 <REDDebugger.ab3@4778>    GTMenuItem 0,    0,1, 6 ,"Gosub Step"          ,"G" ,    0,?help_gs
0001767E <REDDebugger.ab3@4779>    GTMenuItem 0,    0,1, 7 ,"Procedure Step"      ,"P" ,    0,?help_ps
000176E6 <REDDebugger.ab3@4780>    GTMenuItem 0,    0,1, 8 ,"Blitz Control"       ,"B" ,    0,?help_bc
00017706 <REDDebugger.ab3@4781>    GTMenuItem 0,    0,1, 9
0001776E <REDDebugger.ab3@4782>    GTMenuItem 0,    0,1,10 ,"Search memory"       ,"S" ,    0,?help_search
000177D6 <REDDebugger.ab3@4783>    GTMenuItem 0,    0,1,11 ,"Array..."            ,"R" ,    0,?help_array
0001783E <REDDebugger.ab3@4784>    GTMenuItem 0,    0,1,12 ,"Structure..."        ,"T" ,    0,?help_struct
000178A6 <REDDebugger.ab3@4785>    GTMenuItem 0,    0,1,13 ,"Custom chips"        ,""  ,    0,?help_chips
0001790E <REDDebugger.ab3@4786>    GTMenuItem 0,    0,1,14 ,"Label list"          ,""  ,    0,?help_labels
00017976 <REDDebugger.ab3@4787>    GTMenuItem 0,    0,1,15 ,"FPU On"              ,""  ,    0,?help_fpu
000179DE <REDDebugger.ab3@4788>    GTMenuItem 0,%1001,1,16 ,"Asm Step..."         ,""  ,    0,?help_asmstep
00017A46 <REDDebugger.ab3@4789>    GTMenuItem 0,%1001,1,17 ,"Check Addr 0 Change" ,""  ,    0,?help_watch0
00017A7C <REDDebugger.ab3@4792>   GTMenuTitle 0,2,"Objects"
00017A86 <REDDebugger.ab3@4793>   si  = ?MyTypes
00017A8C <REDDebugger.ab3@4794>   num = 0
00017A9A <REDDebugger.ab3@4796>     ad1 = Peek.l(si)
00017AA8 <REDDebugger.ab3@4797>     si+4
00017AB2 <REDDebugger.ab3@4798>     If ad1
00017AE0 <REDDebugger.ab3@4799>       a$ = Peek.s(ad1+2)
00017B34 <REDDebugger.ab3@4800>       If num = 0 Then a$ = a$+"       "
00017BA8 <REDDebugger.ab3@4801>       GTMenuItem 0,0,2,num,a$,"",0,?help_objects
00017BB6 <REDDebugger.ab3@4802>       num+1
00017BCE <REDDebugger.ab3@4804>   Until ad1 = 0
00017C04 <REDDebugger.ab3@4807>   GTMenuTitle       0,3    ,"Misc"
00017C6C <REDDebugger.ab3@4808>    GTMenuItem 0,    0,3, 0 ,"Add trace..."        ,"A" ,    0,?help_menus
00017CD4 <REDDebugger.ab3@4809>    GTMenuItem 0,    0,3, 1 ,"Delete trace..."     ,""  ,    0,?help_menus
00017D3C <REDDebugger.ab3@4810>    GTMenuItem 0,    0,3, 2 ,"Delete all..."       ,""  ,    0,?help_menus
00017DA4 <REDDebugger.ab3@4811>    GTMenuItem 0,    0,3, 3 ,"Sort names"          ,""  ,    0,?help_menus
00017DC4 <REDDebugger.ab3@4812>    GTMenuItem 0,    0,3, 4
00017E2C <REDDebugger.ab3@4813>    GTMenuItem 0,%1001,3, 5 ,"Auto EVAL"           ,""  ,    0,?help_autoeval
00017E94 <REDDebugger.ab3@4814>    GTMenuItem 0,    0,3, 6 ,"Define"              ,"Z" ,    0,?help_autoeval
00017EB4 <REDDebugger.ab3@4815>    GTMenuItem 0,    0,3, 7
00017F1C <REDDebugger.ab3@4816>    GTMenuItem 0,    0,3, 8 ,"Add breakpoint..."   ,"[" ,    0,?help_breakpoints
00017F84 <REDDebugger.ab3@4817>    GTMenuItem 0,    0,3, 9 ,"Delete..."           ,"]" ,    0,?help_breakpoints
00017FEC <REDDebugger.ab3@4818>    GTMenuItem 0,    0,3,10 ,"Delete all..."       ,""  ,    0,?help_breakpoints
00018054 <REDDebugger.ab3@4819>    GTMenuItem 0,    0,3,11 ,"List..."             ,""  ,    0,?help_breakpoints
0001805A <REDDebugger.ab3@4820>   GetCustomMenus{}
00018072 <REDDebugger.ab3@4822>   CreateMenuStrip 0
00018074 <REDDebugger.ab3@4823> Return
00018096 <REDDebugger.ab3@4827>   prtcode = -1 : stepcnt = 0 : dstatus = #STOPPED : statego = -1
00018098 <REDDebugger.ab3@4828> Return
000180A2 <REDDebugger.ab3@4835>     ev = Event
000180B4 <REDDebugger.ab3@4836>     If ev = 0
000180C2 <REDDebugger.ab3@4837>       If dstatus = #TRACE
000180D4 <REDDebugger.ab3@4838>         Delay_ 1
000180DA <REDDebugger.ab3@4839>       Else
000180EC <REDDebugger.ab3@4840>         Delay_ 2
000180FE <REDDebugger.ab3@4845>     If ev.l = #IDCMP_MOUSEMOVE
00018128 <REDDebugger.ab3@4846>       If winbubble.l Then CloseWindow #bubble : winbubble.l = 0
00018138 <REDDebugger.ab3@4847>       ev = Event : Pop If : Goto _again1
00018146 <REDDebugger.ab3@4849>     memchecktimer-1
00018160 <REDDebugger.ab3@4850>     currentwin.l = Used Window
0001816A <REDDebugger.ab3@4851>     If watch0
00018186 <REDDebugger.ab3@4852>       If Peek.l (0) <> addr0
00018248 <REDDebugger.ab3@4853>         Use Window 0 : WTitle "!!!! Address 0 is changed !! $"+Hex$(Peek.l(0))+" "+Left$(Peek.s(Peek.l(0)),30)
0001825E <REDDebugger.ab3@4854>         Use Window currentwin
00018264 <REDDebugger.ab3@4871>     Goto _skip
0001828C <REDDebugger.ab3@4876>     If (EventCode AND $80) <> 0 Then Goto _nomid2 ; ignore up mouse
000182AE <REDDebugger.ab3@4877>     If (EventQualifier AND $1000) = 0 Then Goto _nomid3
000182C0 <REDDebugger.ab3@4878>     If evw = #_winMemory2
000182D4 <REDDebugger.ab3@4879>       If EventQualifier AND $30
000182DA <REDDebugger.ab3@4880>         JSR memhistoryup
000182EC <REDDebugger.ab3@4881>         Delay_(10)
00018300 <REDDebugger.ab3@4883>       If EventQualifier AND $c0
00018306 <REDDebugger.ab3@4884>         JSR memhistorydown
00018318 <REDDebugger.ab3@4885>         Delay_(10)
0001832A <REDDebugger.ab3@4888>     If evw = #_winDisAsm
0001833E <REDDebugger.ab3@4889>       If EventQualifier AND $30
00018344 <REDDebugger.ab3@4890>         JSR historyup
00018356 <REDDebugger.ab3@4891>         Delay_(10)
0001835C <REDDebugger.ab3@4892>         FlushEvents
00018370 <REDDebugger.ab3@4894>       If EventQualifier AND $c0
00018376 <REDDebugger.ab3@4895>         JSR historydown
00018388 <REDDebugger.ab3@4896>         Delay_(10)
0001838E <REDDebugger.ab3@4897>         FlushEvents
000183B0 <REDDebugger.ab3@4902>     If (EventQualifier AND $1000) <> 0 Then Goto _nomid2
000183E6 <REDDebugger.ab3@4903>     If ActiveWindow = Peek.l (Addr Window (#_winMemory2))
000183FC <REDDebugger.ab3@4904>       Use Window #_winMemory2
00018406 <REDDebugger.ab3@4905>       ev     = Event
0001842E <REDDebugger.ab3@4906>       xpos.l = WMouseX-WLeftOff
00018456 <REDDebugger.ab3@4907>       ypos.l = WMouseY-WTopOff
0001848E <REDDebugger.ab3@4908>       memvalueStrpos.l = TextLength_(RastPort,&memStr(0),10)  ; get the x startposition
000184F8 <REDDebugger.ab3@4909>       If (xpos > memvalueStrpos) AND (xpos < InnerWidth) AND (ypos > 0) AND (ypos < InnerHeight)
00018506 <REDDebugger.ab3@4910>         xpos   - memvalueStrpos
00018528 <REDDebugger.ab3@4911>         ypos   = ypos/WinFontHeight
0001856E <REDDebugger.ab3@4912>         xpos   = TextFit(memStr(ypos),xpos)
00018580 <REDDebugger.ab3@4913>         *ptr.l = (.l)&memStr(ypos)
0001858A <REDDebugger.ab3@4914>         If *ptr
00018590 <REDDebugger.ab3@4915>           Gosub getterm
00018596 <REDDebugger.ab3@4916>         Else
000185BE <REDDebugger.ab3@4917>           part$ = ""
000185F6 <REDDebugger.ab3@4919>         If part$ <> ""
000185FC <REDDebugger.ab3@4920>           JSR addmemhistory
00018632 <REDDebugger.ab3@4921>           ConvToPostFix part$,&evalbuffer$
0001865C <REDDebugger.ab3@4922>           temp = PFEvaluate(Peek.s(&evalbuffer$))
00018672 <REDDebugger.ab3@4923>           If PFErrorType = 0
00018686 <REDDebugger.ab3@4924>             mempointer(1) = temp
0001868C <REDDebugger.ab3@4925>             RedrawMem{}
000186C4 <REDDebugger.ab3@4926>             WTitle part$
000186D6 <REDDebugger.ab3@4927>             Delay_ 10
000186EC <REDDebugger.ab3@4931>       Use Window currentwin
00018734 <REDDebugger.ab3@4934>     If (ActiveWindow = Peek.l (Addr Window (#_winDisAsm) ) ) AND (OSVersion = #AmigaOS3)
0001874A <REDDebugger.ab3@4935>       Use Window #_winDisAsm
00018772 <REDDebugger.ab3@4936>       xpos = WMouseX-WLeftOff ; left border
0001879A <REDDebugger.ab3@4937>       ypos = WMouseY-WTopOff  ; top border
000187D2 <REDDebugger.ab3@4938>       disasmStrpos.l = TextLength_(RastPort,&disStr(1),18)  ; get the x startposition of the DisAsm string
0001883C <REDDebugger.ab3@4939>       If (xpos > disasmStrpos) AND (xpos < InnerWidth) AND (ypos > 0) AND (ypos < InnerHeight)
0001884A <REDDebugger.ab3@4941>         xpos - disasmStrpos               ; calc the mouse x position of the disasmstring
0001886C <REDDebugger.ab3@4942>         ypos = ypos/WinFontHeight         ; calc the line of the string by the mouse y
000188B2 <REDDebugger.ab3@4943>         xpos = TextFit(disStr(ypos),xpos) ; get the charnumber positionen of string
000188CC <REDDebugger.ab3@4944>         If xpos < 8 Then xpos = 8         ; to prevent a false detection on the asm command
000188DE <REDDebugger.ab3@4945>         *ptr = (.l)&disStr(ypos)          ; get the pointer of the string
000188E8 <REDDebugger.ab3@4946>         If *ptr
000188EE <REDDebugger.ab3@4947>           Gosub getterm    ; need xpos and i
000188F4 <REDDebugger.ab3@4948>         Else
0001891C <REDDebugger.ab3@4949>           part$ = ""
00018954 <REDDebugger.ab3@4951>         If part$ <> ""
000189B0 <REDDebugger.ab3@4952>           If Left$(part$,1) <> "#"       ; test if we have a address and no value
00018A2E <REDDebugger.ab3@4953>             part2$ = Replace$ (part$,"(","+")
00018A72 <REDDebugger.ab3@4954>             If part2$ <> part$
00018AFC <REDDebugger.ab3@4955>               part$ = Left$(part2$,Len(part2$)-4)
00018B9E <REDDebugger.ab3@4956>               If Left$(part$,1) <> "-" Then part$ = "+"+part$
00018C2E <REDDebugger.ab3@4957>               part2$ = Mid$(part2$,Len(part2$)-2,2)
00018C80 <REDDebugger.ab3@4958>               part$ = part2$+part$
00018CB8 <REDDebugger.ab3@4960>             WTitle part$
00018CEE <REDDebugger.ab3@4962>             ConvToPostFix part$,&evalbuffer$
00018D18 <REDDebugger.ab3@4963>             temp = PFEvaluate(Peek.s(&evalbuffer$))
00018D2E <REDDebugger.ab3@4964>             If PFErrorType = 0
00018D38 <REDDebugger.ab3@4965>               ev = Event
00018D4C <REDDebugger.ab3@4966>               If EventQualifier AND $30
00018D52 <REDDebugger.ab3@4967>                 JSR addhistory
00018D58 <REDDebugger.ab3@4968>                 disasm_ad = temp
00018D66 <REDDebugger.ab3@4969>                 UpdateDisAsm{}
00018D78 <REDDebugger.ab3@4970>                 Delay_(20)
00018D7E <REDDebugger.ab3@4971>               Else
00018DA2 <REDDebugger.ab3@4972>                 If winstatus(#_winMemory2) = 0 Then NewMemWindow{#_winMemory2}
00018DB6 <REDDebugger.ab3@4973>                 mempointer(1) = temp
00018DBC <REDDebugger.ab3@4974>                 RedrawMem{}
00018DC2 <REDDebugger.ab3@4977>             memchecktimer = 33
00018DD8 <REDDebugger.ab3@4978>             Use Window currentwin
00018E0E <REDDebugger.ab3@4985>     If ActiveWindow = Peek.l (Addr Window (#_winSource))
00018E24 <REDDebugger.ab3@4986>       Use Window #_winSource
00018E4C <REDDebugger.ab3@4989>       xpos = WMouseX-WLeftOff
00018E74 <REDDebugger.ab3@4990>       ypos = WMouseY-WTopOff
00018EE2 <REDDebugger.ab3@4992>       If xpos => 0 AND xpos < InnerWidth AND ypos > 2 AND ypos < InnerHeight
00018EF0 <REDDebugger.ab3@4993>         ypos+1
00018F12 <REDDebugger.ab3@4995>         ypos = ypos/WinFontHeight
00018F24 <REDDebugger.ab3@4996>         *ptr = (.l)&srcStr(ypos)
00018F6A <REDDebugger.ab3@4997>         xpos = TextFit(srcStr(ypos),xpos)
00019058 <REDDebugger.ab3@4998>         If winbubble.l = 0 Then Window #bubble,SMouseX-10,SMouseY-WinFontHeight*5,WindowWidth,WinFontHeight*3+4,$800,"",0,1 : winbubble = 1
00019062 <REDDebugger.ab3@4999>         If *ptr
00019068 <REDDebugger.ab3@5000>           Gosub getterm
0001906E <REDDebugger.ab3@5001>         Else
00019096 <REDDebugger.ab3@5002>           part $ = ""
0001909C <REDDebugger.ab3@5004>         Gosub storefpuregs
00019120 <REDDebugger.ab3@5005>         If Left$(part$,8) = "optimize" Then part$ = "not support"
000191A4 <REDDebugger.ab3@5006>         If Left$(part$,8) = "Syntax" Then part$ = "not support"
00019270 <REDDebugger.ab3@5007>         If Left$(part$,1) = "\" Then part$ = path$+poin$+part$ ; Then :
000192EE <REDDebugger.ab3@5008>         If poin$ Then part$ = poin$+part$
0001934C <REDDebugger.ab3@5009>         If part$ Then d_eval{part$,#SIGNAL}
00019384 <REDDebugger.ab3@5010>         WTitle part$
00019396 <REDDebugger.ab3@5011>         Delay_(2)
0001939C <REDDebugger.ab3@5012>         Gosub restorefpuregs
000193D0 <REDDebugger.ab3@5014>         ev$           = part$
000193D6 <REDDebugger.ab3@5015>         memchecktimer = 33
000193EC <REDDebugger.ab3@5016>         Use Window currentwin
000193EE <REDDebugger.ab3@5021>     Return
0001940E <REDDebugger.ab3@5025>     If winstatus(#fpuwin) AND fpuneedupdate.l
0001941C <REDDebugger.ab3@5026>       fpuneedupdate-1
00019436 <REDDebugger.ab3@5027>       currentwin = Used Window
0001944C <REDDebugger.ab3@5028>       Use Window #fpuwin
00019456 <REDDebugger.ab3@5029>       MOVE.l fpuoffset,fpreg
0001945A <REDDebugger.ab3@5030>       Dc.l $f2276800 ;fmove.x fp0,-(a7)
00019460 <REDDebugger.ab3@5031>       TST.l regpos
00019464 <REDDebugger.ab3@5032>       BEQ _noreg
0001948E <REDDebugger.ab3@5033>       For temp = 0 To 7
00019494 <REDDebugger.ab3@5034>         MOVE.l regpos,a0
0001949A <REDDebugger.ab3@5035>         ADD.l fpreg,a0
000194A0 <REDDebugger.ab3@5036>         Dc.l $f2284800 : Dc.w 0 ;fmove.x 0(a0),fp0
000194AA <REDDebugger.ab3@5037>         ADD.l #12,fpreg
000194AE <REDDebugger.ab3@5038>         fmove.s fp0,d0
000194B4 <REDDebugger.ab3@5039>         JSR fpuffp
000194F0 <REDDebugger.ab3@5040>         fp$(temp) = Str$(ffp)
0001955A <REDDebugger.ab3@5041>         WZPrint "fpr0"+Str$(temp),&fp$(temp)
0001956A <REDDebugger.ab3@5042>       Next temp
0001956E <REDDebugger.ab3@5045>       Dc.l $f21f4800 ;fmove.x (a7)+,fp0
00019584 <REDDebugger.ab3@5047>       Use Window currentwin
000195A4 <REDDebugger.ab3@5049>     If winstatus(#_winDisAsm) AND initdiss
000195D8 <REDDebugger.ab3@5050>       ad = PFEvaluate(disasmlockpf$) ; update disasm
000195DE <REDDebugger.ab3@5051>       disasm_ad = ad
00019604 <REDDebugger.ab3@5052>       If winstatus(#_winDisAsm) Then UpdateDisAsm{}
00019612 <REDDebugger.ab3@5053>       initdiss-1
00019626 <REDDebugger.ab3@5055>     If Peek.w(?donebreakpoint)
0001964E <REDDebugger.ab3@5056>       t$ = "[Breakpoint]"
00019654 <REDDebugger.ab3@5057>       Gosub wprint
0001965A <REDDebugger.ab3@5058>       CLR.w donebreakpoint
0001966A <REDDebugger.ab3@5060>     If memchecktimer < 1
0001970C <REDDebugger.ab3@5061>       a$ = "Chip: "+Str$(AvailMem_(%10))+" Fast:"+Str$(AvailMem_(%100))
00019728 <REDDebugger.ab3@5062>       If Peek.l(Addr Window (#_winSource))
0001973E <REDDebugger.ab3@5063>         Use Window #_winSource
00019744 <REDDebugger.ab3@5065>         memchecktimer = 33
00019758 <REDDebugger.ab3@5068>     If Peek.l(?varhandler)
00019768 <REDDebugger.ab3@5069>       asa.l = Peek.l(?varhandler)
00019794 <REDDebugger.ab3@5070>       n$    = Peeks$(asa,256)
000197A6 <REDDebugger.ab3@5071>       Poke.l ?varhandler,0
000197AC <REDDebugger.ab3@5072>       Gosub _CheckTrace
000197BE <REDDebugger.ab3@5074>     While FirstItem(d_e())
000197CE <REDDebugger.ab3@5076>       ad = Peek.l(?progmode)
000197DC <REDDebugger.ab3@5077>       a  = Peek.w(ad)
00019802 <REDDebugger.ab3@5078>       If pmodevalid = 0 OR a <> pmode
0001980C <REDDebugger.ab3@5079>         pmodevalid = -1
00019814 <REDDebugger.ab3@5080>         pmode      = a
0001982C <REDDebugger.ab3@5081>         GetProgMode pmode,&cntrlwin$+14
00019862 <REDDebugger.ab3@5082>         SetWindowTitles_ Peek.l(Addr Window(#_winControl)),&cntrlwin$,-1
00019898 <REDDebugger.ab3@5085>       If memlock$(0)
000198E2 <REDDebugger.ab3@5086>         mempointer(0) = PFEvaluate(memlockpf$(0))
00019918 <REDDebugger.ab3@5088>       If memlock$(1)
00019962 <REDDebugger.ab3@5089>         mempointer(1) = PFEvaluate(memlockpf$(1))
00019992 <REDDebugger.ab3@5092>       If winstatus(#_winMemory1) OR winstatus(#_winMemory2) Then RedrawMem{}
000199B0 <REDDebugger.ab3@5093>       If winstatus(#_winRegisters) Then RedrawRegs{}
000199CE <REDDebugger.ab3@5094>       If winstatus(#_winVariables) Then UpdateVarWindow{}   ; only the values are print
000199D8 <REDDebugger.ab3@5095>       ResetList objwins()
000199EA <REDDebugger.ab3@5096>       While NextItem(objwins())
00019A0E <REDDebugger.ab3@5097>         If objwins()\typepointer >= 0 Then RefreshTypeWindow{}
00019A14 <REDDebugger.ab3@5098>       Wend
00019A22 <REDDebugger.ab3@5100>       Select d_e()\t
00019A2E <REDDebugger.ab3@5102>         Case 0 ; supervisor mode error!
00019A7E <REDDebugger.ab3@5103>           t$ = "(*) "+d_e()\s
00019A84 <REDDebugger.ab3@5104>           Gosub wprint
00019A8A <REDDebugger.ab3@5105>           Gosub goterr
00019A9C <REDDebugger.ab3@5107>         Case 1 ; user mode error!
00019ADA <REDDebugger.ab3@5108>           t$ = d_e()\s
00019AE0 <REDDebugger.ab3@5109>           Gosub wprint
00019AE6 <REDDebugger.ab3@5110>           Gosub goterr
00019AF8 <REDDebugger.ab3@5112>         Case 2 ; EVAL result
00019B08 <REDDebugger.ab3@5113>           If execrequest = #_newtypewindow
00019B12 <REDDebugger.ab3@5114>             PopItem objwins()
00019B28 <REDDebugger.ab3@5115>             objwins()\typepointer = 0
00019B3C <REDDebugger.ab3@5116>             objwins()\maxobject   = 1
00019B42 <REDDebugger.ab3@5117>             execrequest           = 0
00019B48 <REDDebugger.ab3@5118>             objectbusy            = 0
00019B4E <REDDebugger.ab3@5119>             RefreshTypeWindow{}
00019B54 <REDDebugger.ab3@5120>           Else
00019B92 <REDDebugger.ab3@5121>             t$        = d_e()\s
00019BC6 <REDDebugger.ab3@5122>             lasteval$ = t$
00019BEA <REDDebugger.ab3@5123>             If FLen(t$) < 11
00019BF6 <REDDebugger.ab3@5125>               optimize 7 ; this would require an FPU
00019CE6 <REDDebugger.ab3@5126>                t$ = t$+" $"+Hex$(Val(t$))+" %"+Bin$(Val(t$))
00019CF2 <REDDebugger.ab3@5127>               optimize 5
00019CF8 <REDDebugger.ab3@5130>             Gosub EVALHandle ; print eval result
00019D0A <REDDebugger.ab3@5131>             Delay_ 1
00019D56 <REDDebugger.ab3@5132>             If winbubble = 1 AND part$ <> ""
00019D8A <REDDebugger.ab3@5133>               evalstr$ = t$
00019DA0 <REDDebugger.ab3@5134>               Use Window #bubble
00019DA6 <REDDebugger.ab3@5135>               Gosub printbubble
00019DAC <REDDebugger.ab3@5137>             Gosub wprint
00019DBE <REDDebugger.ab3@5140>         Case 3 ; dump code baby!
00019DCE <REDDebugger.ab3@5141>           If execrequest = #_newtypewindow
00019DD8 <REDDebugger.ab3@5142>             PopItem objwins()
00019DDE <REDDebugger.ab3@5143>             execrequest           = 0
00019DFE <REDDebugger.ab3@5144>             objwins()\typepointer = objwins()\objbaseadr
00019E26 <REDDebugger.ab3@5145>             t$                    = ""
00019E64 <REDDebugger.ab3@5146>             SetPropInfo objwins()\winnum,#OBJ_SGAD,1,objwins()\maxobject,0
00019E8E <REDDebugger.ab3@5147>             Redraw objwins()\winnum,#OBJ_SGAD
00019EB2 <REDDebugger.ab3@5148>             Use Window objwins()\winnum
00019F92 <REDDebugger.ab3@5149>             WTitle "Newtype: "+objwins()\t+" #"+Str$(objwins()\tracenum)+"/"+Str$(objwins()\maxobject-1)
00019F98 <REDDebugger.ab3@5150>             RefreshTypeWindow{}
00019F9E <REDDebugger.ab3@5151>             objectbusy = 0
00019FAE <REDDebugger.ab3@5153>           If execrequest = #_viewblitz
00019FC6 <REDDebugger.ab3@5154>             Enable #_winControl,10
00019FCC <REDDebugger.ab3@5155>             execrequest = 0
00019FE2 <REDDebugger.ab3@5157>           cb = d_e()\i
00019FF6 <REDDebugger.ab3@5158>           i  = Peek.l(buffmem+cb)
0001A02E <REDDebugger.ab3@5160>           If disasmlockpf$ <> ""
0001A062 <REDDebugger.ab3@5161>             ad = PFEvaluate(disasmlockpf$) ; update disasm
0001A070 <REDDebugger.ab3@5162>             If ad <> disasm_ad
0001A076 <REDDebugger.ab3@5163>               disasm_ad = ad
0001A09C <REDDebugger.ab3@5164>               If winstatus(#_winDisAsm) Then UpdateDisAsm{}
0001A0AC <REDDebugger.ab3@5168>           If syntax_ Then Gosub getsyntax
0001A0C6 <REDDebugger.ab3@5170>           pb = 0 : mc = -1 : Gosub prtcode : ;prtbusy = 0
0001A0DE <REDDebugger.ab3@5171>           Signal_ task,signalset
0001A0F0 <REDDebugger.ab3@5173>         Case 4 ; QUIT - outa-here
0001A0F6 <REDDebugger.ab3@5174>           exitflag = 1
0001A0F8 <REDDebugger.ab3@5176>       End Select
0001A122 <REDDebugger.ab3@5177>       MaxLen d_e()\s = 0 : KillItem d_e()
0001A128 <REDDebugger.ab3@5178>     Wend
0001A14E <REDDebugger.ab3@5181>   Until ev <> 0 OR exitflag <> 0
0001A164 <REDDebugger.ab3@5183>   Use Window currentwin
0001A176 <REDDebugger.ab3@5184>   Delay_ 2
0001A178 <REDDebugger.ab3@5185> Return
0001A184 <REDDebugger.ab3@5189>   evw.l       = evalrequest
0001A18A <REDDebugger.ab3@5190>   evalrequest = 0
0001A190 <REDDebugger.ab3@5191>   Select evw
0001A19E <REDDebugger.ab3@5193>     Case #_mouseable_eval
0001A1DC <REDDebugger.ab3@5194>       ad = Vallong(d_e()\s)
0001A1E2 <REDDebugger.ab3@5196>       Select evalrequestex
0001A1EE <REDDebugger.ab3@5198>         Case #_winMemory1
0001A202 <REDDebugger.ab3@5199>           mempointer(0) = ad
0001A20A <REDDebugger.ab3@5200>           cur           = 0
0001A210 <REDDebugger.ab3@5201>           RedrawMem{}
0001A222 <REDDebugger.ab3@5203>         Case #_winMemory2
0001A236 <REDDebugger.ab3@5204>           mempointer(1) = ad
0001A23E <REDDebugger.ab3@5205>           cur           = 1
0001A244 <REDDebugger.ab3@5206>           RedrawMem{}
0001A256 <REDDebugger.ab3@5208>         Case #_winDisAsm
0001A25C <REDDebugger.ab3@5209>           disasm_ad = ad
0001A26A <REDDebugger.ab3@5210>           UpdateDisAsm{}
0001A27C <REDDebugger.ab3@5212>         Case #_winSource
0001A290 <REDDebugger.ab3@5213>           il = Peek.l(ad+2)
0001A296 <REDDebugger.ab3@5214>           Gosub prtcode2
0001A298 <REDDebugger.ab3@5215>       End Select
0001A2AC <REDDebugger.ab3@5217>     Case #_memwindow
0001A2F6 <REDDebugger.ab3@5218>       mempointer(evalrequestex) = Vallong(d_e()\s)
0001A300 <REDDebugger.ab3@5219>       cur                       = evalrequestex
0001A306 <REDDebugger.ab3@5220>       RedrawMem{}
0001A32E <REDDebugger.ab3@5221>       t$=""
0001A342 <REDDebugger.ab3@5223>     Case #_structaddress
0001A34C <REDDebugger.ab3@5224>       PopItem objwins()
0001A396 <REDDebugger.ab3@5225>       objwins()\typepointer = Vallong(d_e()\s)
0001A39C <REDDebugger.ab3@5226>       RefreshTypeWindow{}
0001A3B0 <REDDebugger.ab3@5228>     Case #_variablelocate
0001A3F6 <REDDebugger.ab3@5229>       varinfo()\address = Vallong(d_e()\s)
0001A410 <REDDebugger.ab3@5230>       If varinfo()\address = 0
0001A41A <REDDebugger.ab3@5231>         KillItem varinfo()
0001A480 <REDDebugger.ab3@5232>         reply = RTEZRequest(scrtitle$,"Variable not found!","_Abort")
0001A486 <REDDebugger.ab3@5233>       Else
0001A4A2 <REDDebugger.ab3@5234>         If varinfo()\typ = 4
0001A4B2 <REDDebugger.ab3@5235>           mem = varinfo()\address
0001A4B8 <REDDebugger.ab3@5236>           Gosub FindString
0001A4C8 <REDDebugger.ab3@5237>           varinfo()\address = ad
0001A54C <REDDebugger.ab3@5238>           If ad = -1 Then KillItem varinfo() : a = RTEZRequest(scrtitle$,"String not found!","_Ok")
0001A564 <REDDebugger.ab3@5240>         If winstatus(#_winVariables)
0001A56A <REDDebugger.ab3@5241>           RedrawVarWindow{}
0001A570 <REDDebugger.ab3@5242>           UpdateVarWindow{}
0001A598 <REDDebugger.ab3@5245>       t$ = ""
0001A5AC <REDDebugger.ab3@5247>     Case #_disasmaddress
0001A5F2 <REDDebugger.ab3@5248>       disasm_ad = Vallong(d_e()\s) AND $fffffffe
0001A600 <REDDebugger.ab3@5249>       UpdateDisAsm{}
0001A614 <REDDebugger.ab3@5251>     Case #_discopaddress
0001A65A <REDDebugger.ab3@5252>       discop_ad = Vallong(d_e()\s) AND $fffffffe
0001A660 <REDDebugger.ab3@5253>       UpdateDisCop{}
0001A674 <REDDebugger.ab3@5255>     Case #_autoevalresult
0001A6D8 <REDDebugger.ab3@5256>       t$ = autoeval$+"="+t$
0001A6EC <REDDebugger.ab3@5258>     Case #_arrayfind
0001A72A <REDDebugger.ab3@5259>       arrayadd = Vallong(d_e()\s)
0001A744 <REDDebugger.ab3@5260>       If winstatus(#_winArray) = 0
0001A74E <REDDebugger.ab3@5261>         NewWindow{#_winArray}
0001A764 <REDDebugger.ab3@5263>       Use Window #_winArray
0001A7AA <REDDebugger.ab3@5264>       a$ = array$+"("
0001A7BC <REDDebugger.ab3@5265>       If array1 <> 0
0001A860 <REDDebugger.ab3@5266>         a$+Str$(array1)+","+Str$(array2)+")"
0001A866 <REDDebugger.ab3@5267>       Else
0001A8D4 <REDDebugger.ab3@5268>         a$+Str$(array2)+")"
0001A90C <REDDebugger.ab3@5270>       WTitle a$
0001A916 <REDDebugger.ab3@5271>       RedrawArray{1}
0001A918 <REDDebugger.ab3@5272>   End Select
0001A91A <REDDebugger.ab3@5273> Return
0001A94A <REDDebugger.ab3@5277>   For h = 0 To (Maximum Window)-1
0001A966 <REDDebugger.ab3@5278>     If Peek.l(Addr Window(h))
0001A978 <REDDebugger.ab3@5279>       If h > 22
0001A98C <REDDebugger.ab3@5280>         WZCloseWindow h
0001A992 <REDDebugger.ab3@5281>       Else
0001A9A8 <REDDebugger.ab3@5282>         Free Window h
0001A9D6 <REDDebugger.ab3@5284>       If Peek.l(Addr GadgetList(h)) Then Free GadgetList(h)
0001A9E6 <REDDebugger.ab3@5287>   Next h
0001AA10 <REDDebugger.ab3@5290>   For h = 1 To 100
0001AA44 <REDDebugger.ab3@5291>     If NewCloseScreen(0) <> 0 Then h = 250
0001AA56 <REDDebugger.ab3@5292>     Delay_ 1
0001AA66 <REDDebugger.ab3@5293>   Next
0001AAF0 <REDDebugger.ab3@5294>   If h <= 101 Then a = RTEZRequest(scrtitle$,warn1$,"_Ok") : Goto _again20
0001AB02 <REDDebugger.ab3@5295>   Free GTMenuList 0
0001AB1C <REDDebugger.ab3@5296>   FreeMem_ buffmem,#bufflen
0001AB1E <REDDebugger.ab3@5297> Return
0001AB36 <REDDebugger.ab3@5301>   Ascii = Peek.b(&n$) AND $ff
0001AB4E <REDDebugger.ab3@5302>   nt    = Peek.b(&n$+1)
0001AB66 <REDDebugger.ab3@5303>   nf    = Peek.b(&n$+2)
0001AB7C <REDDebugger.ab3@5304>   si    = Peek.l(&n$+4)
0001ABAC <REDDebugger.ab3@5305>   na$   = Peek.s(&n$+8)
0001ABB2 <REDDebugger.ab3@5306>   Select Ascii
0001ABBE <REDDebugger.ab3@5308>     Case #_memwindowmove
0001ABE0 <REDDebugger.ab3@5309>       If nt = 0 OR nt = 1
0001ABF6 <REDDebugger.ab3@5310>         mempointer(nt) = si
0001AC18 <REDDebugger.ab3@5311>         If nt=0 Then nt = #_winMemory1 Else nt = #_winMemory2
0001AC36 <REDDebugger.ab3@5312>         If winstatus(nt) = 0
0001AC42 <REDDebugger.ab3@5313>           NewMemWindow{nt}
0001AC54 <REDDebugger.ab3@5317>     Case #_diswindow
0001AC64 <REDDebugger.ab3@5318>       disasm_ad = si AND $fffffffe
0001AC7E <REDDebugger.ab3@5319>       If winstatus(#_winDisAsm) = 0
0001AC88 <REDDebugger.ab3@5320>         NewWindow{#_winDisAsm}
0001AC96 <REDDebugger.ab3@5322>       UpdateDisAsm{}
0001ACA8 <REDDebugger.ab3@5324>     Case #_varwindow
0001ACC2 <REDDebugger.ab3@5325>       If winstatus(#_winVariables) = 0
0001ACCC <REDDebugger.ab3@5326>         NewWindow{#_winVariables}
0001ACD2 <REDDebugger.ab3@5328>       a = 1
0001ACE4 <REDDebugger.ab3@5330>     Case #_deltrace
0001ACEA <REDDebugger.ab3@5331>       Gosub _Deltrace
0001ACFC <REDDebugger.ab3@5333>     Case #_addtrace
0001AD02 <REDDebugger.ab3@5334>       Gosub _Addtrace
0001AD14 <REDDebugger.ab3@5336>     Case #_copperlist
0001AD1A <REDDebugger.ab3@5337>       discop_ad = si
0001AD34 <REDDebugger.ab3@5338>       If winstatus(#_winDisCop) = 0
0001AD3E <REDDebugger.ab3@5339>         NewWindow{#_winDisCop}
0001AD44 <REDDebugger.ab3@5341>       UpdateDisCop{}
0001AD56 <REDDebugger.ab3@5343>     Case #_proccontrol
0001AD66 <REDDebugger.ab3@5344>       If nf = 0 ; (do Toggle)
0001AD70 <REDDebugger.ab3@5345>         procstatus = NOT(procstatus)
0001AD76 <REDDebugger.ab3@5346>       Else
0001AD80 <REDDebugger.ab3@5347>         procstatus = nt
0001AD9C <REDDebugger.ab3@5349>       Toggle #_winControl,18,procstatus
0001ADB8 <REDDebugger.ab3@5350>       Redraw #_winControl,18
0001ADBA <REDDebugger.ab3@5352>   End Select
0001ADD8 <REDDebugger.ab3@5353>   If a AND winstatus(#_winVariables)
0001ADDE <REDDebugger.ab3@5354>     RedrawVarWindow{}
0001ADE4 <REDDebugger.ab3@5355>     UpdateVarWindow{}
0001ADE6 <REDDebugger.ab3@5357> Return
0001ADEC <REDDebugger.ab3@5361>   a = 0
0001ADF6 <REDDebugger.ab3@5362>   ResetList varinfo()
0001AE08 <REDDebugger.ab3@5363>   While NextItem(varinfo())
0001AE56 <REDDebugger.ab3@5364>     If varinfo()\name = na$
0001AE76 <REDDebugger.ab3@5365>       If varinfo()\typ = nt ; added check of type to be sure we delete the right entry in the var trace  tomsmart1 2016 02 14
0001AE80 <REDDebugger.ab3@5366>         KillItem varinfo()
0001AE8A <REDDebugger.ab3@5367>         a=-1
0001AE90 <REDDebugger.ab3@5370>   Wend
0001AE92 <REDDebugger.ab3@5371> Return
0001AE9C <REDDebugger.ab3@5375>   AddLast varinfo()
0001AEDA <REDDebugger.ab3@5376>   varinfo()\name    = na$
0001AEEA <REDDebugger.ab3@5377>   varinfo()\address = si
0001AF00 <REDDebugger.ab3@5378>   varinfo()\typ     = nt
0001AF1A <REDDebugger.ab3@5379>   varinfo()\form    = nf-1
0001AF20 <REDDebugger.ab3@5380>   a = 1
0001AF3C <REDDebugger.ab3@5381>   If varinfo()\typ = 4
0001AF4C <REDDebugger.ab3@5382>     mem = varinfo()\address
0001AF52 <REDDebugger.ab3@5383>     Gosub FindString
0001AF62 <REDDebugger.ab3@5384>     varinfo()\address = ad
0001AF86 <REDDebugger.ab3@5385>     If ad = -1 Then KillItem varinfo() : a = 0
0001AF88 <REDDebugger.ab3@5387> Return
0001AFCA <REDDebugger.ab3@5393>   If dowin = 0 Then Use Window #_winMemory1 Else Use Window #_winMemory2
0001AFE8 <REDDebugger.ab3@5394>   wwide.l = (InnerWidth ASR 3)-10
0001AFFA <REDDebugger.ab3@5395>   wwide/7
0001B00A <REDDebugger.ab3@5396>   jump = wwide ASL 1
0001B042 <REDDebugger.ab3@5397>   If kbshift Then jump = jump*(InnerHeight ASR 6)
0001B056 <REDDebugger.ab3@5400>   If flag = -1
0001B082 <REDDebugger.ab3@5401>     mempointer(dowin)-jump
0001B088 <REDDebugger.ab3@5402>   Else
0001B0B4 <REDDebugger.ab3@5403>     mempointer(dowin)+jump
0001B0BA <REDDebugger.ab3@5405>   RedrawMem{}
0001B0BC <REDDebugger.ab3@5406> Return
0001B0DA <REDDebugger.ab3@5415> Statement DoCurs{xad.b,num.b}
0001B114 <REDDebugger.ab3@5418>   If (Peek.l(Addr Window(#_winMemory1+num)) = 0) Then Statement Return
0001B146 <REDDebugger.ab3@5419>   y.l  = (((mad-mempointer(num))/wwide)ASL 3)+iy
0001B168 <REDDebugger.ab3@5420>   *rp.RastPort = RastPort(#_winMemory1+num)
0001B182 <REDDebugger.ab3@5421>   SetDrMd_ *rp,2
0001B192 <REDDebugger.ab3@5422>   If editflag = 0
0001B1B2 <REDDebugger.ab3@5423>     x.l = ix+72+(xad ASL 3)
0001B1C6 <REDDebugger.ab3@5424>     If (mad AND %1) ; Odd address
0001B1EE <REDDebugger.ab3@5425>       x+(((xad-1)ASR 2) ASL 3)
0001B1F4 <REDDebugger.ab3@5426>     Else
0001B216 <REDDebugger.ab3@5427>       x+((xad ASR 2) ASL 3)
0001B21C <REDDebugger.ab3@5429>   Else
0001B24A <REDDebugger.ab3@5430>     x = ix+80+(wwide*20)+(xad ASL 3)
0001B286 <REDDebugger.ab3@5432>   RectFill_ *rp,x,y,x+7,y+7
0001B2A0 <REDDebugger.ab3@5433>   SetDrMd_ *rp,1
0001B2A4 <REDDebugger.ab3@5434> End Statement
0001B2D2 <REDDebugger.ab3@5438>   If (Peek.l(Addr Window(winnum)) = 0) Then Return
0001B2EA <REDDebugger.ab3@5440>   Use Window winnum
0001B304 <REDDebugger.ab3@5441>   Activate winnum
0001B330 <REDDebugger.ab3@5442>   WTitle "Edit mode"
0001B336 <REDDebugger.ab3@5443>   Gosub meminfo
0001B346 <REDDebugger.ab3@5444>   DoCurs{0,dowin}
0001B34C <REDDebugger.ab3@5446>   FlushEvents
0001B352 <REDDebugger.ab3@5447>   flag = 0
0001B35C <REDDebugger.ab3@5449>     ev  = WaitEvent
0001B378 <REDDebugger.ab3@5450>     evw = (EventWindow=winnum)
0001B384 <REDDebugger.ab3@5451>     evq = EventQualifier
0001B3A6 <REDDebugger.ab3@5452>     a$  = Inkey$
0001B404 <REDDebugger.ab3@5453>     If evw = 0 OR ev = $80000 Then a$ = " " : ev = 0 : evq = 0
0001B416 <REDDebugger.ab3@5454>     If ev AND evw
0001B41C <REDDebugger.ab3@5455>       Select ev
0001B42A <REDDebugger.ab3@5457>         Case 2
0001B430 <REDDebugger.ab3@5458>           Gosub meminfo
0001B444 <REDDebugger.ab3@5460>         Case 4
0001B44A <REDDebugger.ab3@5461>           Gosub meminfo
0001B458 <REDDebugger.ab3@5463>             w.w  = InnerWidth
0001B466 <REDDebugger.ab3@5464>             hi.w = InnerHeight
0001B47A <REDDebugger.ab3@5467>         Case 512
0001B4B2 <REDDebugger.ab3@5468>           a$ = " " : ev = 0 : evq = 0
0001B4C6 <REDDebugger.ab3@5470>         Case 1024
0001B4CE <REDDebugger.ab3@5471>           Select EventCode
0001B4DC <REDDebugger.ab3@5473>             Case $4c ; UP cursor
0001B4F4 <REDDebugger.ab3@5474>               mad-wwide : flag = -1
0001B508 <REDDebugger.ab3@5476>             Case $4d ; DOWN cursor
0001B520 <REDDebugger.ab3@5477>               mad+wwide : flag = -1
0001B534 <REDDebugger.ab3@5479>             Case $4F ; Left cursor
0001B572 <REDDebugger.ab3@5480>               xad.l-1 : If xad = -1 Then xad = wxad.l-1 : mad.l-wwide.l
0001B57C <REDDebugger.ab3@5481>               flag = -1
0001B590 <REDDebugger.ab3@5483>             Case $4E ; Right cursor
0001B5A8 <REDDebugger.ab3@5484>               xad+1: flag = -1
0001B5AA <REDDebugger.ab3@5485>           End Select
0001B5E0 <REDDebugger.ab3@5486>           If flag Then a$ = ""
0001B5E2 <REDDebugger.ab3@5487>       End Select
0001B60A <REDDebugger.ab3@5490>     b$ = ""
0001B642 <REDDebugger.ab3@5491>     If a$ <> ""
0001B68A <REDDebugger.ab3@5492>       If (evq AND %1000) Then b$ = a$
0001B736 <REDDebugger.ab3@5493>       If a$ <> " " AND a$ <> Chr$(9) Then b$ = a$
0001B744 <REDDebugger.ab3@5495>     If editflag
0001B77C <REDDebugger.ab3@5496>       If b$ <> ""
0001B7C6 <REDDebugger.ab3@5497>         Poke.b mad+xad,Asc(a$)
0001B7D4 <REDDebugger.ab3@5498>         xad+1
0001B7DE <REDDebugger.ab3@5499>         flag = -1
0001B806 <REDDebugger.ab3@5500>         a$ = ""
0001B80C <REDDebugger.ab3@5502>     Else
0001B844 <REDDebugger.ab3@5503>       If b$ <> ""
0001B890 <REDDebugger.ab3@5504>         b$ = UCase$(b$)
0001B962 <REDDebugger.ab3@5505>         If (b$ >= "0" AND b$ <= "9") OR (b$ >= "A" AND b$ <= "F")
0001B980 <REDDebugger.ab3@5506>           a = Peek.b(mad+(xad ASR 1))
0001B9C6 <REDDebugger.ab3@5507>           b = Vallong("$"+b$)
0001B9DA <REDDebugger.ab3@5508>           If (xad AND %1)
0001B9F0 <REDDebugger.ab3@5509>             a = (a AND $f0) OR b
0001B9F6 <REDDebugger.ab3@5510>           Else
0001BA14 <REDDebugger.ab3@5511>             a = (a AND $0f) OR (b ASL 4)
0001BA30 <REDDebugger.ab3@5513>           Poke.b mad+(xad ASR 1),a
0001BA3E <REDDebugger.ab3@5514>           xad+1
0001BA48 <REDDebugger.ab3@5515>           flag = -1
0001BA70 <REDDebugger.ab3@5517>         a$ = ""
0001BAB4 <REDDebugger.ab3@5520>     If a$ = Chr$(9)
0001BAC4 <REDDebugger.ab3@5521>       editflag = 1-editflag
0001BAD4 <REDDebugger.ab3@5522>       If editflag = 0
0001BAE4 <REDDebugger.ab3@5523>         wxad ASL 1
0001BAF4 <REDDebugger.ab3@5524>         xad ASL 1
0001BAFA <REDDebugger.ab3@5525>       Else
0001BB0A <REDDebugger.ab3@5526>         wxad = wxad ASR 1
0001BB1A <REDDebugger.ab3@5527>         xad  = xad ASR 1
0001BB20 <REDDebugger.ab3@5529>       flag = 1
0001BB2E <REDDebugger.ab3@5531>     If flag
0001BB5A <REDDebugger.ab3@5532>       If xad > wxad-1 Then xad = 0 : mad+wwide
0001BBA6 <REDDebugger.ab3@5533>       If mad >= nmad.l Then mad = nmad : mempointer(dowin)+wwide : nmad+wwide
0001BC14 <REDDebugger.ab3@5534>       If mad < mempointer(dowin) Then mempointer(dowin)-wwide : mad = mempointer(dowin) : nmad-wwide
0001BC1E <REDDebugger.ab3@5535>       num = dowin
0001BC2A <REDDebugger.ab3@5536>       DrawMem{dowin}
0001BC3A <REDDebugger.ab3@5537>       DoCurs{xad,dowin}
0001BC40 <REDDebugger.ab3@5538>       flag = 0
0001BC7E <REDDebugger.ab3@5540>   Until a$ = " "
0001BC8E <REDDebugger.ab3@5541>   DoCurs{xad,dowin}
0001BC9A <REDDebugger.ab3@5542>   Domemtitle {dowin}
0001BCA4 <REDDebugger.ab3@5543>   dowin = -1
0001BCAA <REDDebugger.ab3@5544>   RedrawMem{}
0001BCAC <REDDebugger.ab3@5545> Return
0001BCCA <REDDebugger.ab3@5549>   wwide = (InnerWidth ASR 3)-10
0001BCDC <REDDebugger.ab3@5550>   wwide/7
0001BCEC <REDDebugger.ab3@5551>   wxad = wwide ASL 2
0001BCFC <REDDebugger.ab3@5552>   wwide ASL 1
0001BD12 <REDDebugger.ab3@5554>   mad.l  = mempointer(dowin)
0001BD40 <REDDebugger.ab3@5555>   nmad.l = mad+((InnerHeight ASR 3)*wwide)
0001BD48 <REDDebugger.ab3@5556>   xad    = 0 ; count number of 4 bit groups from address ad
0001BD52 <REDDebugger.ab3@5557>   flag   = -1
0001BD70 <REDDebugger.ab3@5558>   If editflag Then wxad = wxad ASR 1
0001BD72 <REDDebugger.ab3@5559> Return
0001BD80 <REDDebugger.ab3@5563>   ad = Peek.l(MyBufferAddress)
0001BD8A <REDDebugger.ab3@5564>   If (ad)
0001BD9E <REDDebugger.ab3@5565>     ad2 = Peek.l(ad+52)  ; get Value of Register A5
0001BDA8 <REDDebugger.ab3@5566>     If (ad2)
0001BDB2 <REDDebugger.ab3@5569>       ad2_offset.l = $8000 +2   ; set the size to search
0001BDBE <REDDebugger.ab3@5570>       ad = -1 ; for the case we don't find the string pointer
0001BDCC <REDDebugger.ab3@5572>         ad2_offset - 2 ;
0001BDEC <REDDebugger.ab3@5573>         If Peek.l(ad2 - ad2_offset) = mem  ; test if the pointers match
0001BDFA <REDDebugger.ab3@5574>           ad = ad2 - ad2_offset ; yes get address
0001BE02 <REDDebugger.ab3@5575>           ad2_offset = 0 ; for end until
0001BE1A <REDDebugger.ab3@5577>       Until ad2_offset = 0  ; test if we reach the end
0001BE20 <REDDebugger.ab3@5578>     Else
0001BE2C <REDDebugger.ab3@5579>       ad = -1
0001BE40 <REDDebugger.ab3@5582>   If ad = -1
0001BE46 <REDDebugger.ab3@5592>     *progtask.Task = task        ; get the task pointer of the program to debug
0001BE50 <REDDebugger.ab3@5593>     If (*progtask)               ; test if we have a vaild pointer
0001BE64 <REDDebugger.ab3@5594>       ad2_offset.l = *progtask\tc_SPUpper -3 ; get the upper Stack address and -3 for peek.l to prevent hits
0001BE70 <REDDebugger.ab3@5595>       ad = -1 ; for the case we don't find the string pointer
0001BE7E <REDDebugger.ab3@5597>         ad2_offset -1
0001BE98 <REDDebugger.ab3@5598>         If Peek.l(ad2_offset) = mem  ; test if the pointers match
0001BE9E <REDDebugger.ab3@5599>           ad = ad2_offset ; yes get address
0001BEAC <REDDebugger.ab3@5600>           ad2_offset = *progtask\tc_SPLower ; for end until
0001BEC8 <REDDebugger.ab3@5602>       Until ad2_offset = *progtask\tc_SPLower ; test if we reach the lower Stack address
0001BECE <REDDebugger.ab3@5603>     Else
0001BEDA <REDDebugger.ab3@5604>       ad = -1
0001BEDC <REDDebugger.ab3@5607> Return
0001BF10 <REDDebugger.ab3@5611>   ad1        = Vallong(StringText$(2,1))
0001BF16 <REDDebugger.ab3@5612>   old_ad     = ad1
0001BF4A <REDDebugger.ab3@5613>   ad2        = Vallong(StringText$(2,4))
0001BF7E <REDDebugger.ab3@5614>   searchfor$ = StringText$(2,7)
0001BF88 <REDDebugger.ab3@5615>   nt         = searchtype
0001BF9A <REDDebugger.ab3@5617>   If nt = 0 Then Return
0001BFDE <REDDebugger.ab3@5619>   If nt < 4 Then si = Vallong(searchfor$)
0001BFF8 <REDDebugger.ab3@5620>   If nt = 4 Then si = &searchfor$
0001C004 <REDDebugger.ab3@5622>   optimize 7 ; this would require an FPU
0001C068 <REDDebugger.ab3@5623>    If nt = 5 Then mq = Val(searchfor$) : si = Peek.l(&mq)
0001C0C2 <REDDebugger.ab3@5624>    If nt = 6 Then mf = Val(searchfor$) : si = Peek.l(&mf)
0001C0CE <REDDebugger.ab3@5625>   optimize 5
0001C0F6 <REDDebugger.ab3@5627>   t$ = "Searching memory.... <SPACE> to abort"
0001C0FC <REDDebugger.ab3@5628>   Gosub wprint
0001C102 <REDDebugger.ab3@5629>   num = 0
0001C128 <REDDebugger.ab3@5632>   ad = SearchMem(nt,si,ad1,ad2)
0001C14E <REDDebugger.ab3@5634>   If ad <> 0 AND ad <> 1
0001C15C <REDDebugger.ab3@5635>     num+1
0001C166 <REDDebugger.ab3@5636>     ad = SearchMemFound
0001C1E2 <REDDebugger.ab3@5637>     b$ = Peek.s(?search0)+Hex$(old_ad)+Peek.s(?search01)+Hex$(ad2)
0001C2E4 <REDDebugger.ab3@5638>     b$+Peek.s(?search1)+Hex$(ad)+Peek.s(?search2)+Hex$(ad-old_ad)+Peek.s(?search3)+Hex$(num)+Peek.s(?search4)
0001C34A <REDDebugger.ab3@5639>     reply = RTEZRequest("Search",b$,"Mem_1|Mem_2|_Again|_Exit")
0001C358 <REDDebugger.ab3@5640>     If reply <> 0
0001C37A <REDDebugger.ab3@5641>       If reply = 3 Then ad1 = ad+1 : Goto _doagain
0001C394 <REDDebugger.ab3@5642>       mempointer(reply-1) = ad
0001C39A <REDDebugger.ab3@5643>       RedrawMem{}
0001C3A0 <REDDebugger.ab3@5645>   Else
0001C40C <REDDebugger.ab3@5646>     If ad = 1 Then a$ = Peek.s(?exitpress) Else a$ = Peek.s(?notfound)
0001C472 <REDDebugger.ab3@5647>     reply = RTEZRequest("Search",a$,"_Okay")
0001C4A0 <REDDebugger.ab3@5650>   t$ = "" : Gosub wprint
0001C4A2 <REDDebugger.ab3@5651> Return
0001C4C4 <REDDebugger.ab3@5654> exitpress: Dc.b       "Search aborted - value not found!",0
0001C4E8 <REDDebugger.ab3@5655> notfound:  Dc.b       "Value not found within given range!",0
0001C504 <REDDebugger.ab3@5656> search0:   Dc.b       "Search start address      $",0
0001C521 <REDDebugger.ab3@5657> search01:  Dc.b 10,   "Search end address        $",0
0001C53E <REDDebugger.ab3@5658> search1:   Dc.b 10,   "Found value at address    $",0
0001C55B <REDDebugger.ab3@5659> search2:   Dc.b 10,   "Offset from start address $",0
0001C578 <REDDebugger.ab3@5660> search3:   Dc.b 10,   "Total occurences found    $",0
0001C59B <REDDebugger.ab3@5661> search4:   Dc.b 10,10,"  Move memory window to address?",0
0001C59C <REDDebugger.ab3@5662> Even
0001C5B4 <REDDebugger.ab3@5671>   ShowScreen 0
0001C5D0 <REDDebugger.ab3@5672>   If Peek.l(Addr Window(0))
0001C5E8 <REDDebugger.ab3@5673>     Activate 0
0001C5F0 <REDDebugger.ab3@5675>   MOVE.w  #0,proccount
0001C612 <REDDebugger.ab3@5676>   If winstatus(#_winArray) Then RedrawArray{0}
0001C614 <REDDebugger.ab3@5677> Return
0001C632 <REDDebugger.ab3@5684>   If AddItem(objwins()) = 0
0001C698 <REDDebugger.ab3@5685>     reply = RTEZRequest(scrtitle$,"No more object windows!","_Okay")
0001C69A <REDDebugger.ab3@5686>     Return
0001C6A0 <REDDebugger.ab3@5690>   num = #_winObject0
0001C6C8 <REDDebugger.ab3@5691>   While Peek.l(Addr Window(num)) <> 0
0001C6D6 <REDDebugger.ab3@5692>     num+1
0001C6DC <REDDebugger.ab3@5693>   Wend
0001C6F0 <REDDebugger.ab3@5695>   objwins()\winnum      = num
0001C700 <REDDebugger.ab3@5696>   objwins()\objadr      = address
0001C716 <REDDebugger.ab3@5697>   objwins()\objbaseadr  = 0
0001C72A <REDDebugger.ab3@5698>   objwins()\is_bbobject = is_bb
0001C74A <REDDebugger.ab3@5701>   ox = 0 : oy = WinFontHeight+3 : ow = 320
0001C750 <REDDebugger.ab3@5702>   typelength = 7
0001C756 <REDDebugger.ab3@5703>   num        = 0
0001C76E <REDDebugger.ab3@5704>   *_scr.Screen = Peek.l(Addr Screen(0))
0001C778 <REDDebugger.ab3@5705>   If *_scr
0001C7C6 <REDDebugger.ab3@5706>     winheight = *_scr\BarHeight  +WinFontHeight + *_scr\WBorBottom +2 + *_scr\WBorTop
0001C7CC <REDDebugger.ab3@5707>   Else
0001C7EC <REDDebugger.ab3@5708>     winheight = 23+WinFontHeight
0001C7F6 <REDDebugger.ab3@5711>   If is_bb
0001C824 <REDDebugger.ab3@5712>     wininfo(objwins()\winnum)\helplink = ?help_objects
0001C82A <REDDebugger.ab3@5713>     Gosub ObjectWin
0001C830 <REDDebugger.ab3@5714>   Else
0001C85E <REDDebugger.ab3@5715>     wininfo(objwins()\winnum)\helplink = ?help_struct
0001C864 <REDDebugger.ab3@5716>     Gosub StructWin
0001C872 <REDDebugger.ab3@5718>   If reply = 0
0001C87C <REDDebugger.ab3@5719>     KillItem objwins()
0001C87E <REDDebugger.ab3@5720>     Return
0001C8A8 <REDDebugger.ab3@5723>   If num < 3 Then winheight+(3-num)*8
0001C8BC <REDDebugger.ab3@5725>   objwins()\numitems = num
0001C8FA <REDDebugger.ab3@5726>   objwins()\t        = typetitle$
0001C91E <REDDebugger.ab3@5727>   memadr             = AllocMem((num ASL 2)+4,65536)
0001C930 <REDDebugger.ab3@5728>   If memadr = 0
0001C93A <REDDebugger.ab3@5729>     KillItem objwins()
0001C93C <REDDebugger.ab3@5730>     Return
0001C960 <REDDebugger.ab3@5733>   typewidth = ix+(typelength ASL 3)+8+16
0001CA0A <REDDebugger.ab3@5735>   PropGadget objwins()\winnum,-13,WinFontHeight+5,#VPROP_AFLAGS,#OBJ_SGAD,10,-17-WinFontHeight-22,#VPROP_PFLAGS,3
0001CA38 <REDDebugger.ab3@5736>   SetPropInfo objwins()\winnum,#OBJ_SGAD,1,1
0001CA82 <REDDebugger.ab3@5737>   ArrowGadget objwins()\winnum,#OBJ_UGAD,#UPIMAGE,-17,-20-11,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
0001CACE <REDDebugger.ab3@5738>   ArrowGadget objwins()\winnum,#OBJ_DGAD,#DOWNIMAGE,-17,-20,#RIGHTREL|#BOTTOMREL|#RIGHTBORDER,$2
0001CAEA <REDDebugger.ab3@5740>   SizeLimits typewidth+22,winheight,640,1600;winheight
0001CAF4 <REDDebugger.ab3@5741> 
0001CBA0 <REDDebugger.ab3@5742>   Window objwins()\winnum,ox,oy,ow,winheight,wflg,"Newtype: "+typetitle$,1,2,objwins()\winnum
0001CBC0 <REDDebugger.ab3@5747>   GTSetMenu 0
0001CBDC <REDDebugger.ab3@5748>   WindowFont 0
0001CC00 <REDDebugger.ab3@5749>   winstatus(objwins()\winnum) = -1
0001CC5A <REDDebugger.ab3@5751>   Wline typewidth-5,iy,typewidth-5,iy+InnerHeight-1,1
0001CC6E <REDDebugger.ab3@5753>   objwins()\tracenum    = 0
0001CC82 <REDDebugger.ab3@5754>   objwins()\typewidth   = typewidth
0001CCA4 <REDDebugger.ab3@5755>   objwins()\typepointer = -1,memadr
0001CCCA <REDDebugger.ab3@5756>   rp                    = RastPort(objwins()\winnum)
0001CCD8 <REDDebugger.ab3@5758>   OutTextPen rp,1
0001CD1C <REDDebugger.ab3@5759>   OutText ix+2,iy+1,rp,"Address"
0001CD2C <REDDebugger.ab3@5760>   oy = 9+iy
0001CD36 <REDDebugger.ab3@5761>   If is_bb
0001CD3C <REDDebugger.ab3@5762>     Gosub ObjectWinD
0001CD42 <REDDebugger.ab3@5763>   Else
0001CD48 <REDDebugger.ab3@5764>     Gosub StructWinD
0001CD4A <REDDebugger.ab3@5766> Return
0001CD5E <REDDebugger.ab3@5770>   If winbubble = 0 Then Return
0001CD74 <REDDebugger.ab3@5771>   Use Window #bubble
0001CD90 <REDDebugger.ab3@5772>   WindowFont 1
0001CDBE <REDDebugger.ab3@5773>   xs.l = WindowWidth : ys.l = WinFontHeight*3+4
0001CDCC <REDDebugger.ab3@5775>   WCls
0001CDFA <REDDebugger.ab3@5776>   WBox 0,0,xs-1,ys-1,3
0001CE34 <REDDebugger.ab3@5777>   Wline    0,   0,xs-1,   0,1
0001CE7A <REDDebugger.ab3@5778>   Wline xs-1,   0,xs-1,ys-1,1
0001CEC0 <REDDebugger.ab3@5779>   Wline xs-1,ys-1,   0,ys-1,1
0001CEFA <REDDebugger.ab3@5780>   Wline    0,ys-1,   0,   0,1
0001CF0E <REDDebugger.ab3@5781>   WJam 0 : WColour 2
0001CF64 <REDDebugger.ab3@5782>   WLocate 1,1 : Print part$
0001CFD0 <REDDebugger.ab3@5783>   WLocate 1,WinFontHeight+1 : Print evalstr$
0001D036 <REDDebugger.ab3@5784>   WLocate 1,WinFontHeight*2+2 : Print "01234567890123456789012345678901234567890 String Lineal"
0001D04A <REDDebugger.ab3@5785>   WColour 1 : WJam 1
0001D04C <REDDebugger.ab3@5786> Return
0001D068 <REDDebugger.ab3@5791>   objwins()\type_sizeof = Peek.w(address)
0001D076 <REDDebugger.ab3@5792>   address+2
0001D09E <REDDebugger.ab3@5794>   typetitle$ = Peek.s(address)
0001D0E6 <REDDebugger.ab3@5795>   address+Len(typetitle$)+1
0001D0EC <REDDebugger.ab3@5796>   address2 = address
0001D0FE <REDDebugger.ab3@5797>   y2.l     = sh-oy
0001D11A <REDDebugger.ab3@5798>   If y2 > maxheight Then y2 = maxheight
0001D142 <REDDebugger.ab3@5800>     a$ = Peek.s(address)
0001D18A <REDDebugger.ab3@5801>     address+Len(a$)+3
0001D1B6 <REDDebugger.ab3@5802>     If a$
0001D1C4 <REDDebugger.ab3@5803>       num+1
0001D238 <REDDebugger.ab3@5804>       If (Len(a$)) > typelength Then typelength = Len(a$)
0001D246 <REDDebugger.ab3@5805>       winheight+8
0001D282 <REDDebugger.ab3@5806>       If (winheight+8) > y2 Then a$ = ""
0001D2C0 <REDDebugger.ab3@5808>   Until a$ = ""
0001D2CA <REDDebugger.ab3@5809>   reply = -1
0001D2CC <REDDebugger.ab3@5810> Return
0001D2D2 <REDDebugger.ab3@5814>   address = address2
0001D2FC <REDDebugger.ab3@5815>   For h = 1 To num
0001D324 <REDDebugger.ab3@5816>     a$ = Peek.s(address)
0001D36C <REDDebugger.ab3@5817>     address+Len(a$)+1
0001D37C <REDDebugger.ab3@5818>     typ   = Peek.b(address)
0001D392 <REDDebugger.ab3@5819>     skp.b = Peek.b(address+1)
0001D3A6 <REDDebugger.ab3@5820>     If skp = -1
0001D3C8 <REDDebugger.ab3@5821>       If typ < 3 Then skp = typ Else skp = 4
0001D498 <REDDebugger.ab3@5823>     OutText ix+2,oy,rp,LSet$(a$,typelength)+"."+Mid$(objtype$,typ,1)
0001D4A6 <REDDebugger.ab3@5824>     oy+8
0001D4B4 <REDDebugger.ab3@5825>     Poke.w memadr,typ
0001D4CA <REDDebugger.ab3@5826>     Poke.w memadr+2,skp
0001D4D8 <REDDebugger.ab3@5827>     memadr+4
0001D4E6 <REDDebugger.ab3@5828>     address+2
0001D4F6 <REDDebugger.ab3@5829>   Next h
0001D582 <REDDebugger.ab3@5832>     a$ = "poke.w "+Str$(&objwins()\maxobject)+",maximum "+typetitle$
0001D63E <REDDebugger.ab3@5833>     a$+":Poke.l "+Str$(&objwins()\objbaseadr)+",Addr "+typetitle$+"(0)"
0001D66C <REDDebugger.ab3@5834>     d_exec{a$}
0001D672 <REDDebugger.ab3@5835>     execrequest = #_newtypewindow
0001D67C <REDDebugger.ab3@5836>     objectbusy  = -1
0001D686 <REDDebugger.ab3@5837>     PushItem objwins()
0001D688 <REDDebugger.ab3@5842> Return
0001D71A <REDDebugger.ab3@5846>   suc.l = OpenFile(0,dos_AddPart{my_path$,"structure.lookup"})
0001D742 <REDDebugger.ab3@5847>   fil$  = ""
0001D754 <REDDebugger.ab3@5848>   If suc = 0
0001D7BA <REDDebugger.ab3@5849>     reply = RTEZRequest(scrtitle$,"Couldn't locate structure.lookup file.","_Abort")
0001D7C0 <REDDebugger.ab3@5850>     reply = 0
0001D7C2 <REDDebugger.ab3@5851>     Return
0001D852 <REDDebugger.ab3@5853>   t$ = RTEZGetString(scrtitle$,"Enter structure name:",80,laststructure$)
0001D892 <REDDebugger.ab3@5854>   If t$ = "" Then reply = 0 : Return
0001D8C6 <REDDebugger.ab3@5855>   laststructure$ = t$
0001D912 <REDDebugger.ab3@5856>   t$             = LCase$(t$)
0001D93A <REDDebugger.ab3@5857>   a$             = ""
0001D962 <REDDebugger.ab3@5858>   b$             = ""
0001D96A <REDDebugger.ab3@5859>   filepos.l      = 0
0001D97E <REDDebugger.ab3@5860>   FileInput 0
0001D984 <REDDebugger.ab3@5861>   flag = 0
0001D9F6 <REDDebugger.ab3@5862>   While b$ <> t$ AND NOT(Eof(0))
0001DA1E <REDDebugger.ab3@5863>     a$ = Edit$(256)
0001DA7A <REDDebugger.ab3@5864>     If Left$(a$,1) = "!"
0001DACC <REDDebugger.ab3@5865>       fil$ = Mid$(a$,2)
0001DAD2 <REDDebugger.ab3@5866>     Else
0001DB3C <REDDebugger.ab3@5867>       b$ = LCase$(Mid$(a$,10))
0001DB42 <REDDebugger.ab3@5869>   Wend
0001DBB0 <REDDebugger.ab3@5870>   filepos = Vallong("$"+Left$(a$,8))
0001DBF4 <REDDebugger.ab3@5871>   If b$ <> t$
0001DC5A <REDDebugger.ab3@5872>     reply = RTEZRequest(scrtitle$,"Type not found!","_Okay")
0001DC72 <REDDebugger.ab3@5873>     CloseFile 0
0001DC78 <REDDebugger.ab3@5874>     reply = 0
0001DC8C <REDDebugger.ab3@5875>     WindowInput 0
0001DC8E <REDDebugger.ab3@5876>     Return
0001DCA6 <REDDebugger.ab3@5878>   CloseFile 0
0001DCEE <REDDebugger.ab3@5879>   suc = OpenFile(0,fil$)
0001DD00 <REDDebugger.ab3@5880>   If suc = 0
0001DD66 <REDDebugger.ab3@5881>     reply = RTEZRequest(scrtitle$,"File not found!","_Okay")
0001DD7E <REDDebugger.ab3@5882>     CloseFile 0
0001DD84 <REDDebugger.ab3@5883>     reply = 0
0001DD98 <REDDebugger.ab3@5884>     WindowInput 0
0001DD9A <REDDebugger.ab3@5885>     Return
0001DDAE <REDDebugger.ab3@5887>   FileInput 0
0001DDCA <REDDebugger.ab3@5888>   FileSeek 0,filepos
0001DDF2 <REDDebugger.ab3@5889>   a$                    = Edit$(256)
0001DE7C <REDDebugger.ab3@5890>   typetitle$            = Left$(a$,Len(a$)-1)
0001DEA4 <REDDebugger.ab3@5891>   a$                    = Edit$(256)
0001DF10 <REDDebugger.ab3@5892>   objwins()\type_sizeof = Val(Mid$(a$,8,6))
0001DF38 <REDDebugger.ab3@5893>   a$                    = "!"
0001DF4A <REDDebugger.ab3@5894>   y2                    = sh-oy
0001DF66 <REDDebugger.ab3@5896>   If y2 > maxheight Then y2 = maxheight
0001DFA4 <REDDebugger.ab3@5898>   While a$ <> ""
0001DFCC <REDDebugger.ab3@5899>     a$ = Edit$(256)
0001E066 <REDDebugger.ab3@5900>     If a$ <> "" AND Right$(a$,1) <> ":"
0001E0B8 <REDDebugger.ab3@5901>       a$ = Mid$(a$,22)
0001E0C6 <REDDebugger.ab3@5902>       num+1
0001E13A <REDDebugger.ab3@5903>       If (Len(a$)) > typelength Then typelength = Len(a$)
0001E148 <REDDebugger.ab3@5904>       winheight+8
0001E184 <REDDebugger.ab3@5905>       If (winheight+8) > y2 Then a$ = ""
0001E18A <REDDebugger.ab3@5906>     Else
0001E1B2 <REDDebugger.ab3@5907>       a$ = ""
0001E1B8 <REDDebugger.ab3@5909>   Wend
0001E1C2 <REDDebugger.ab3@5910>   reply = -1
0001E1C4 <REDDebugger.ab3@5911> Return
0001E1E0 <REDDebugger.ab3@5915>   FileSeek 0,filepos
0001E1F4 <REDDebugger.ab3@5916>   FileInput 0
0001E1FA <REDDebugger.ab3@5918>   flag   = 0
0001E222 <REDDebugger.ab3@5919>   a$     = Edit$(256)
0001E24A <REDDebugger.ab3@5920>   a$     = Edit$(256)
0001E250 <REDDebugger.ab3@5921>   prev.w = 0
0001E27A <REDDebugger.ab3@5923>   For h = 1 To num
0001E2A2 <REDDebugger.ab3@5924>     a$  = Edit$(256)
0001E302 <REDDebugger.ab3@5925>     typ = Val(Mid$(a$,3,5))
0001E310 <REDDebugger.ab3@5926>     skp = typ-prev
0001E338 <REDDebugger.ab3@5927>     If h > 1 Then Poke.w memadr-2,skp
0001E33E <REDDebugger.ab3@5929>     prev = typ
0001E398 <REDDebugger.ab3@5931>     Select Val(Mid$(a$,17,3))
0001E3A6 <REDDebugger.ab3@5933>       Case 1
0001E3AC <REDDebugger.ab3@5934>         typ = 1
0001E3C0 <REDDebugger.ab3@5936>       Case 2
0001E3C6 <REDDebugger.ab3@5937>         typ = 2
0001E3DA <REDDebugger.ab3@5939>       Case 4
0001E3E0 <REDDebugger.ab3@5940>         typ = 3
0001E3E6 <REDDebugger.ab3@5942>       Default
0001E3EC <REDDebugger.ab3@5943>         typ = 0
0001E3EE <REDDebugger.ab3@5944>     End Select
0001E440 <REDDebugger.ab3@5946>     a$ = Mid$(a$,22)
0001E48C <REDDebugger.ab3@5947>     b$ = LCase$(a$)
0001E4F4 <REDDebugger.ab3@5949>     If Instr(b$,"name") AND skp = 4
0001E504 <REDDebugger.ab3@5950>       If flag = 0
0001E5C4 <REDDebugger.ab3@5951>         reply = RTEZRequest(scrtitle$,"Keyword 'name' found."+Chr$(10)+"Point "+a$+" to string?","_Yes|_All|_No")
0001E5D8 <REDDebugger.ab3@5952>         If reply <> 0 Then typ = 4
0001E5F0 <REDDebugger.ab3@5953>         If reply = 2 Then flag = -1
0001E5F6 <REDDebugger.ab3@5954>       Else
0001E5FC <REDDebugger.ab3@5955>         typ = 4
0001E660 <REDDebugger.ab3@5958>     a$ = LSet$(a$,typelength)+"."
0001E66E <REDDebugger.ab3@5959>     If typ > 0
0001E6EE <REDDebugger.ab3@5960>       a$+Mid$(objtype$,typ,1)
0001E6F4 <REDDebugger.ab3@5961>     Else
0001E73A <REDDebugger.ab3@5962>       a$+"?"
0001E740 <REDDebugger.ab3@5963>       typ = 1
0001E78A <REDDebugger.ab3@5965>     OutText ix+2,oy,rp,a$
0001E798 <REDDebugger.ab3@5966>     oy+8
0001E7A6 <REDDebugger.ab3@5967>     Poke.w memadr,typ
0001E7B4 <REDDebugger.ab3@5968>     memadr+4
0001E7C4 <REDDebugger.ab3@5969>   Next h
0001E7D8 <REDDebugger.ab3@5971>   WindowInput 0
0001E7F0 <REDDebugger.ab3@5972>   CloseFile 0
0001E806 <REDDebugger.ab3@5974>   objwins()\typepointer = 0
0001E80C <REDDebugger.ab3@5975>   RefreshTypeWindow{}
0001E80E <REDDebugger.ab3@5976> Return
0001E832 <REDDebugger.ab3@5980>   ad2 = AllocVec_(configsize+4096,#MEMF_CLEAR|#MEMF_PUBLIC)
0001E83C <REDDebugger.ab3@5981>   If ad2
0001E842 <REDDebugger.ab3@5982>     ad = ad2
0001E87A <REDDebugger.ab3@5983>     Poke.b ad   ,Vallong("\\__VER_MAJOR")
0001E8B8 <REDDebugger.ab3@5984>     Poke.b ad+ 1,Vallong("\\__VER_MINOR")
0001E8CC <REDDebugger.ab3@5985>     Poke.w ad+ 2,scrmode
0001E8E0 <REDDebugger.ab3@5986>     Poke.l ad+ 4,ModeID
0001E8F4 <REDDebugger.ab3@5987>     Poke.w ad+ 8,swidth
0001E908 <REDDebugger.ab3@5988>     Poke.w ad+10,sheight
0001E91C <REDDebugger.ab3@5989>     Poke.b ad+12,tokenise
0001E956 <REDDebugger.ab3@5990>     Poke.b ad+13,GTMenuChecked(0,0,6,6)
0001E96A <REDDebugger.ab3@5991>     Poke.w ad+14,maxheight
0001E97E <REDDebugger.ab3@5992>     Poke.w ad+16,#save_numwindows
0001E98C <REDDebugger.ab3@5993>     ad+18
0001E9B6 <REDDebugger.ab3@5994>     For h = 0 To #save_numwindows-1
0001E9DC <REDDebugger.ab3@5995>       Poke.w ad,winstatus(h) : ad+2
0001EA04 <REDDebugger.ab3@5996>       If (Peek.l(Addr Window(h) ) >< 0)
0001EA1A <REDDebugger.ab3@5997>         Use Window h
0001EA38 <REDDebugger.ab3@5998>         wininfo(h)\x = WindowX
0001EA5A <REDDebugger.ab3@5999>         wininfo(h)\y = WindowY
0001EA7C <REDDebugger.ab3@6000>         wininfo(h)\w = WindowWidth
0001EA9E <REDDebugger.ab3@6001>         wininfo(h)\h = WindowHeight
0001EACA <REDDebugger.ab3@6003>       Poke.w ad,wininfo(h)\x : ad+2
0001EAFA <REDDebugger.ab3@6004>       Poke.w ad,wininfo(h)\y : ad+2
0001EB2A <REDDebugger.ab3@6005>       Poke.w ad,wininfo(h)\w : ad+2
0001EB5A <REDDebugger.ab3@6006>       Poke.w ad,wininfo(h)\h : ad+2
0001EB6A <REDDebugger.ab3@6007>     Next h
0001EB86 <REDDebugger.ab3@6009>     Poke.b ad,procstatus              : ad+1
0001EBA2 <REDDebugger.ab3@6010>     Poke.b ad,blitzcontrol            : ad+1
0001EBBE <REDDebugger.ab3@6011>     Poke.b ad,gosubstatus             : ad+1
0001EC00 <REDDebugger.ab3@6012>     Poke.b ad,GTMenuChecked(0,0,6,7)  : ad+1
0001EC1C <REDDebugger.ab3@6013>     Poke.b ad,syntax_                 : ad+1
0001EC60 <REDDebugger.ab3@6015>     Poke.s ad,disasmlock$              : ad+128
0001EC7C <REDDebugger.ab3@6016>     Poke.w ad,#wizardwindows          : ad+2
0001ECA6 <REDDebugger.ab3@6017>     For h = 23 To #wizardwindows-1
0001ECCC <REDDebugger.ab3@6018>       Poke.w ad,winstatus(h)          : ad+2
0001ECF4 <REDDebugger.ab3@6019>       If (Peek.l(Addr Window(h) ) >< 0)
0001ED0A <REDDebugger.ab3@6020>         Use Window h
0001ED28 <REDDebugger.ab3@6021>         wininfo(h)\x = WindowX
0001ED4A <REDDebugger.ab3@6022>         wininfo(h)\y = WindowY
0001ED6C <REDDebugger.ab3@6023>         wininfo(h)\w = WindowWidth
0001ED8E <REDDebugger.ab3@6024>         wininfo(h)\h = WindowHeight
0001ED94 <REDDebugger.ab3@6025>       Else
0001EDC0 <REDDebugger.ab3@6026>         Poke.w ad,wininfo(h)\x : ad+2
0001EDF0 <REDDebugger.ab3@6027>         Poke.w ad,wininfo(h)\y : ad+2
0001EE20 <REDDebugger.ab3@6028>         Poke.w ad,wininfo(h)\w : ad+2
0001EE50 <REDDebugger.ab3@6029>         Poke.w ad,wininfo(h)\h : ad+2
0001EE60 <REDDebugger.ab3@6031>     Next h
0001EE8E <REDDebugger.ab3@6034>     SaveIt{my_path$} ; Path changed (Marco 21.01.15)
0001EE9E <REDDebugger.ab3@6035>     FreeVec_ ad2
0001EEA4 <REDDebugger.ab3@6036>   Else
0001EEDE <REDDebugger.ab3@6037>     error{"Unable to save config - not enough memory!"}
0001EEE0 <REDDebugger.ab3@6039> Return
0001EEEA <REDDebugger.ab3@6043>   ec.l = EventCode
0001EEFE <REDDebugger.ab3@6044>   If ec <> -1
0001EF08 <REDDebugger.ab3@6045>     hitmenu.w    = -1
0001EF12 <REDDebugger.ab3@6046>     hititem.w    = -1
0001EF1C <REDDebugger.ab3@6047>     hitsubitem.w = -1
0001EF46 <REDDebugger.ab3@6049>     If (ec AND 31) <> 31 Then hitmenu = (ec AND 31)
0001EF5E <REDDebugger.ab3@6051>     n = (ec ASR 5) AND 63
0001EF72 <REDDebugger.ab3@6052>     If n <> 63 Then hititem = n
0001EF8A <REDDebugger.ab3@6054>     n = ((ec ASR 11) AND 31)
0001EF9E <REDDebugger.ab3@6055>     If n <> 31 Then hitsubitem = n
0001EFC2 <REDDebugger.ab3@6057>     ad.l = GTGetUserData(0,hitmenu,hititem,hitsubitem)
0001EFD4 <REDDebugger.ab3@6058>     If ad <> 0
0001EFFC <REDDebugger.ab3@6059>       a$ = Peek.s(ad)
0001F02A <REDDebugger.ab3@6060>       DoHelp{a$}
0001F02C <REDDebugger.ab3@6063> Return
0001F033 <REDDebugger.ab3@6067>   Dc.b "Byte  ",0
0001F03A <REDDebugger.ab3@6068>   Dc.b "Word  ",0
0001F041 <REDDebugger.ab3@6069>   Dc.b "Long  ",0
0001F048 <REDDebugger.ab3@6070>   Dc.b "String",0
0001F04F <REDDebugger.ab3@6071>   Dc.b "Quick ",0
0001F056 <REDDebugger.ab3@6072>   Dc.b "Float ",0
0001F06D <REDDebugger.ab3@6075>   Dc.b "Status register flags:",10
0001F07A <REDDebugger.ab3@6076>   Dc.b "X: Extension",10
0001F087 <REDDebugger.ab3@6077>   Dc.b "N: Negative ",10
0001F094 <REDDebugger.ab3@6078>   Dc.b "Z: Zero     ",10
0001F0A1 <REDDebugger.ab3@6079>   Dc.b "O: Overflow ",10
0001F0AE <REDDebugger.ab3@6080>   Dc.b "C: Carry    ",0
0001F0F1 <REDDebugger.ab3@6083>   Dc.b "This program handles runtime error",10,"debugging for programs compiled",10
0001F131 <REDDebugger.ab3@6084>   Dc.b "and run inside AmiBasic3.",10," ",10,"The original version was written by",10
0001F171 <REDDebugger.ab3@6085>   Dc.b "Mark Sibly of ACID software.",10," ",10,"This version has been written by",10
0001F197 <REDDebugger.ab3@6086>   Dc.b "Stephen McNamara of Red When Excited.",10
0001F1B7 <REDDebugger.ab3@6087>   Dc.b "Updated in 2002 by Bernd Roesch",10
0001F1E0 <REDDebugger.ab3@6088>   Dc.b "Additional updates in 2007 by Sven Drge",10
0001F209 <REDDebugger.ab3@6089>   Dc.b "Updates 2009-2015 by the Opensource Team",10
0001F20A <REDDebugger.ab3@6090>   Dc.b 0
0001F21E <REDDebugger.ab3@6093>   Dc.b "Keyboard Shortcuts",10,10
0001F243 <REDDebugger.ab3@6094>   Dc.b "BREAK      - CTRL ALT C    STEP  - S",10
0001F268 <REDDebugger.ab3@6095>   Dc.b "STEPOVER   - D  Call dbl_Flip {} - F",10
0001F28D <REDDebugger.ab3@6096>   Dc.b "SKIP       - I             TRACE - T",10
0001F2B2 <REDDebugger.ab3@6097>   Dc.b "RUN        - R             <<    - ,",10
0001F2D7 <REDDebugger.ab3@6098>   Dc.b ">>         - .             EXEC  - X",10
0001F2FC <REDDebugger.ab3@6099>   Dc.b "EVAL       - E             QUIT- ESc",10
0001F321 <REDDebugger.ab3@6100>   Dc.b "     TAB - Cycle active window      ",10
0001F322 <REDDebugger.ab3@6101>   Dc.b 10
0001F33A <REDDebugger.ab3@6102>   Dc.b "Whilst in some windows,",10
0001F36C <REDDebugger.ab3@6103>   Dc.b "'m' = Enter startadress Shift+m last eval address" ,10
0001F38A <REDDebugger.ab3@6104>   Dc.b "'l' = Lock Window to Register",10
0001F3BF <REDDebugger.ab3@6105>   Dc.b "'SPACE' in memwin allow change value(SPACE for exit)",10
0001F3D1 <REDDebugger.ab3@6106>   Dc.b "ALT+LMB Jump into",10
0001F3FE <REDDebugger.ab3@6107>   Dc.b "ALT+MMB Jump to last position before ALT+LMB",10
0001F425 <REDDebugger.ab3@6108>   Dc.b "CTRL 'm' in disasmwin show line in ped",10
0001F440 <REDDebugger.ab3@6109>   Dc.b "'b' = show next breakpoint",0
0001F45A <REDDebugger.ab3@6113>   Dc.b "Enter new register value:",10
0001F474 <REDDebugger.ab3@6114>   Dc.b "    e.g. d0=12345678     ",10
0001F48E <REDDebugger.ab3@6115>   Dc.b "         d7=$0           ",10
0001F4A8 <REDDebugger.ab3@6116>   Dc.b "         a0=",34,"bLtZ",34,"       ",0
0001F4AC <REDDebugger.ab3@6124>   Dc.l BitmapType
0001F4B0 <REDDebugger.ab3@6125>   Dc.l BlitzfontType
0001F4B4 <REDDebugger.ab3@6126>   Dc.l BufferType
0001F4B8 <REDDebugger.ab3@6127>   Dc.l Coplisttype
0001F4BC <REDDebugger.ab3@6128>   Dc.l FileType
0001F4C0 <REDDebugger.ab3@6129>   Dc.l GTListType
0001F4C4 <REDDebugger.ab3@6130>   Dc.l GTMenuListType
0001F4C8 <REDDebugger.ab3@6131>   Dc.l IntuifontType
0001F4CC <REDDebugger.ab3@6132>   Dc.l MapObjType
0001F4D0 <REDDebugger.ab3@6133>   Dc.l ModuleType
0001F4D4 <REDDebugger.ab3@6134>   Dc.l PaletteType
0001F4D8 <REDDebugger.ab3@6135>   Dc.l QueueType
0001F4DC <REDDebugger.ab3@6136>   Dc.l ShapeType
0001F4E0 <REDDebugger.ab3@6137>   Dc.l SliceType
0001F4E4 <REDDebugger.ab3@6138>   Dc.l SoundType
0001F4E8 <REDDebugger.ab3@6139>   Dc.l SpriteType
0001F4EC <REDDebugger.ab3@6140>   Dc.l StencilType
0001F4F0 <REDDebugger.ab3@6141>   Dc.l TapeType
0001F4F4 <REDDebugger.ab3@6142>   Dc.l WindowType
0001F4F8 <REDDebugger.ab3@6143>   Dc.l 0
0001F4FA <REDDebugger.ab3@6155>   Dc.w 128
0001F502 <REDDebugger.ab3@6156>   Dc.b "Palette",0
0001F50C <REDDebugger.ab3@6157>   Dc.b "*_pdata",0,#_long,-1
0001F516 <REDDebugger.ab3@6158>   Dc.b "numcols",0,#_word,-1
0001F51F <REDDebugger.ab3@6159>   Dc.b "[locol",0,#_word,-1
0001F527 <REDDebugger.ab3@6160>   Dc.b "hicol",0,#_word,-1
0001F52F <REDDebugger.ab3@6161>   Dc.b "speed",0,#_word,-1
0001F536 <REDDebugger.ab3@6162>   Dc.b "var]",0,#_word,-1
0001F537 <REDDebugger.ab3@6163>   Dc.b 0
0001F538 <REDDebugger.ab3@6165> Even
0001F53A <REDDebugger.ab3@6167>   Dc.w 64
0001F541 <REDDebugger.ab3@6168>   Dc.b "Bitmap",0
0001F54C <REDDebugger.ab3@6169>   Dc.b "_ebwidth",0,#_word,-1
0001F556 <REDDebugger.ab3@6170>   Dc.b "_height",0,#_word,-1
0001F55F <REDDebugger.ab3@6171>   Dc.b "_depth",0,#_word,-1
0001F566 <REDDebugger.ab3@6172>   Dc.b "_pad",0,#_word,-1
0001F570 <REDDebugger.ab3@6173>   Dc.b "_plane0",0,#_long,-1
0001F57A <REDDebugger.ab3@6174>   Dc.b "_plane1",0,#_long,-1
0001F584 <REDDebugger.ab3@6175>   Dc.b "_plane2",0,#_long,-1
0001F58E <REDDebugger.ab3@6176>   Dc.b "_plane3",0,#_long,-1
0001F598 <REDDebugger.ab3@6177>   Dc.b "_plane4",0,#_long,-1
0001F5A2 <REDDebugger.ab3@6178>   Dc.b "_plane5",0,#_long,-1
0001F5AC <REDDebugger.ab3@6179>   Dc.b "_plane6",0,#_long,-1
0001F5B6 <REDDebugger.ab3@6180>   Dc.b "_plane7",0,#_long,-1
0001F5BF <REDDebugger.ab3@6181>   Dc.b "_xcurs",0,#_word,-1
0001F5C8 <REDDebugger.ab3@6182>   Dc.b "_ycurs",0,#_word,-1
0001F5D2 <REDDebugger.ab3@6183>   Dc.b "_pad[8]",0,#_byte,8
0001F5DB <REDDebugger.ab3@6184>   Dc.b "_flags",0,#_word,-1
0001F5EA <REDDebugger.ab3@6185>   Dc.b "_bitplanemod",0,#_word,-1
0001F5F3 <REDDebugger.ab3@6186>   Dc.b "_xclip",0,#_word,-1
0001F5FC <REDDebugger.ab3@6187>   Dc.b "_yclip",0,#_word,-1
0001F605 <REDDebugger.ab3@6188>   Dc.b "_cclip",0,#_word,-1
0001F60F <REDDebugger.ab3@6189>   Dc.b "_isreal",0,#_word,-1
0001F610 <REDDebugger.ab3@6190>   Dc.b 0
0001F612 <REDDebugger.ab3@6194>   Dc.w 8
0001F619 <REDDebugger.ab3@6195>   Dc.b "Module",0
0001F624 <REDDebugger.ab3@6196>   Dc.b "_mt_data",0,#_long,-1
0001F62E <REDDebugger.ab3@6197>   Dc.b "_length",0,#_long,-1
0001F62F <REDDebugger.ab3@6198>   Dc.b 0
0001F630 <REDDebugger.ab3@6200> Even
0001F632 <REDDebugger.ab3@6202>   Dc.w 4
0001F63C <REDDebugger.ab3@6203>   Dc.b "Blitzfont",0
0001F644 <REDDebugger.ab3@6204>   Dc.b "_font",0,#_long,-1
0001F645 <REDDebugger.ab3@6205>   Dc.b 0
0001F646 <REDDebugger.ab3@6207> Even
0001F648 <REDDebugger.ab3@6209>   Dc.w 32
0001F64E <REDDebugger.ab3@6210>   Dc.b "Shape",0
0001F65C <REDDebugger.ab3@6211>   Dc.b "_pixelwidth",0,#_word,-1
0001F66B <REDDebugger.ab3@6212>   Dc.b "_pixelheight",0,#_word,-1
0001F674 <REDDebugger.ab3@6213>   Dc.b "_depth",0,#_word,-1
0001F67F <REDDebugger.ab3@6214>   Dc.b "_ebwidth",0,#_word,-1
0001F68A <REDDebugger.ab3@6215>   Dc.b "_bltsize",0,#_word,-1
0001F695 <REDDebugger.ab3@6216>   Dc.b "_xhandle",0,#_word,-1
0001F6A0 <REDDebugger.ab3@6217>   Dc.b "_yhandle",0,2,-1
0001F6A8 <REDDebugger.ab3@6218>   Dc.b "_data",0,#_long,-1
0001F6B2 <REDDebugger.ab3@6219>   Dc.b "_cookie",0,#_long,-1
0001F6BE <REDDebugger.ab3@6220>   Dc.b "_onebpmem",0,#_word,-1
0001F6CB <REDDebugger.ab3@6221>   Dc.b "_onebpmemx",0,#_word,-1
0001F6D7 <REDDebugger.ab3@6222>   Dc.b "_allbpmem",0,#_word,-1
0001F6E4 <REDDebugger.ab3@6223>   Dc.b "_allbpmemx",0,#_word,-1
0001F6EE <REDDebugger.ab3@6224>   Dc.b "_pad[2]",0,#_byte,2
0001F6EF <REDDebugger.ab3@6225>   Dc.b 0
0001F6F0 <REDDebugger.ab3@6227> Even
0001F6F2 <REDDebugger.ab3@6229>   Dc.w 16
0001F6F7 <REDDebugger.ab3@6230>   Dc.b "Tape",0
0001F701 <REDDebugger.ab3@6231>   Dc.b "_ielist",0,#_long,-1
0001F70E <REDDebugger.ab3@6232>   Dc.b "_timevalhi",0,#_long,-1
0001F71B <REDDebugger.ab3@6233>   Dc.b "_timevallo",0,#_long,-1
0001F725 <REDDebugger.ab3@6234>   Dc.b "_pad[4]",0,#_byte,4
0001F726 <REDDebugger.ab3@6235>   Dc.b 0
0001F728 <REDDebugger.ab3@6239>   Dc.w 8
0001F730 <REDDebugger.ab3@6240>   Dc.b "Stencil",0
0001F73B <REDDebugger.ab3@6241>   Dc.b "_ebwidth",0,#_word,-1
0001F745 <REDDebugger.ab3@6242>   Dc.b "_height",0,#_word,-1
0001F74D <REDDebugger.ab3@6243>   Dc.b "_data",0,#_long,-1
0001F74E <REDDebugger.ab3@6244>   Dc.b 0
0001F750 <REDDebugger.ab3@6248>   Dc.w 16
0001F756 <REDDebugger.ab3@6249>   Dc.b "Queue",0
0001F765 <REDDebugger.ab3@6250>   Dc.b "*currentitem",0,#_long,-1
0001F771 <REDDebugger.ab3@6251>   Dc.b "*nextitem",0,#_long,-1
0001F77B <REDDebugger.ab3@6252>   Dc.b "_length",0,#_long,-1
0001F785 <REDDebugger.ab3@6253>   Dc.b "_pad[4]",0,#_byte,4
0001F786 <REDDebugger.ab3@6254>   Dc.b 0
0001F788 <REDDebugger.ab3@6258>   Dc.w 32
0001F78D <REDDebugger.ab3@6259>   Dc.b "File",0
0001F797 <REDDebugger.ab3@6260>   Dc.b "_handle",0,#_long,-1
0001F7A1 <REDDebugger.ab3@6261>   Dc.b "_reclen",0,#_long,-1
0001F7AB <REDDebugger.ab3@6262>   Dc.b "_pad[4]",0,#_byte,4
0001F7B5 <REDDebugger.ab3@6263>   Dc.b "*fields",0,#_long,-1
0001F7BF <REDDebugger.ab3@6264>   Dc.b "_buffer",0,#_long,-1
0001F7C8 <REDDebugger.ab3@6265>   Dc.b "_flags",0,#_word,-1
0001F7D1 <REDDebugger.ab3@6266>   Dc.b "_valid",0,#_word,-1
0001F7DC <REDDebugger.ab3@6267>   Dc.b "_seekoff",0,#_word,-1
0001F7E4 <REDDebugger.ab3@6268>   Dc.b "_seek",0,#_long,-1
0001F7E5 <REDDebugger.ab3@6269>   Dc.b 0
0001F7E6 <REDDebugger.ab3@6271> Even
0001F7E8 <REDDebugger.ab3@6273>   Dc.w 16
0001F7EF <REDDebugger.ab3@6274>   Dc.b "Buffer",0
0001F7FA <REDDebugger.ab3@6275>   Dc.b "_current",0,#_long,-1
0001F803 <REDDebugger.ab3@6276>   Dc.b "_first",0,#_long,-1
0001F80D <REDDebugger.ab3@6277>   Dc.b "_length",0,#_long,-1
0001F817 <REDDebugger.ab3@6278>   Dc.b "_pad[4]",0,#_byte,4
0001F818 <REDDebugger.ab3@6279>   Dc.b 0
0001F81A <REDDebugger.ab3@6283>   Dc.w 64
0001F820 <REDDebugger.ab3@6284>   Dc.b "Slice",0
0001F828 <REDDebugger.ab3@6285>   Dc.b "_ypos",0,#_word,-1
0001F831 <REDDebugger.ab3@6286>   Dc.b "_flags",0,#_word,-1
0001F841 <REDDebugger.ab3@6287>   Dc.b "_numbitplanes",0,#_word,-1
0001F84F <REDDebugger.ab3@6288>   Dc.b "_numsprites",0,#_word,-1
0001F85D <REDDebugger.ab3@6289>   Dc.b "_numcolours",0,#_word,-1
0001F86A <REDDebugger.ab3@6290>   Dc.b "_bitplanes",0,#_long,-1
0001F875 <REDDebugger.ab3@6291>   Dc.b "_sprites",0,#_long,-1
0001F880 <REDDebugger.ab3@6292>   Dc.b "_colours",0,#_long,-1
0001F88B <REDDebugger.ab3@6293>   Dc.b "_BPLCON1",0,#_long,-1
0001F896 <REDDebugger.ab3@6294>   Dc.b "_BPLCON2",0,#_long,-1
0001F8A0 <REDDebugger.ab3@6295>   Dc.b "_pad[2]",0,#_byte,2
0001F8A1 <REDDebugger.ab3@6296>   Dc.b 0
0001F8A2 <REDDebugger.ab3@6298> Even
0001F8A4 <REDDebugger.ab3@6300>   Dc.w 16
0001F8AA <REDDebugger.ab3@6301>   Dc.b "Sound",0
0001F8B2 <REDDebugger.ab3@6302>   Dc.b "_data",0,#_long,-1
0001F8BC <REDDebugger.ab3@6303>   Dc.b "_period",0,#_word,-1
0001F8C6 <REDDebugger.ab3@6304>   Dc.b "_length",0,#_word,-1
0001F8CE <REDDebugger.ab3@6305>   Dc.b "_loop",0,#_long,-1
0001F8DC <REDDebugger.ab3@6306>   Dc.b "_looplength",0,#_word,-1
0001F8E6 <REDDebugger.ab3@6307>   Dc.b "_pad[2]",0,#_byte,2
0001F8E7 <REDDebugger.ab3@6308>   Dc.b 0
0001F8E8 <REDDebugger.ab3@6310> Even
0001F8EA <REDDebugger.ab3@6312>   Dc.w 16
0001F8F1 <REDDebugger.ab3@6313>   Dc.b "Sprite",0
0001F8F9 <REDDebugger.ab3@6314>   Dc.b "_data",0,#_long,-1
0001F903 <REDDebugger.ab3@6315>   Dc.b "_height",0,#_word,-1
0001F90F <REDDebugger.ab3@6316>   Dc.b "_channels",0,#_word,-1
0001F918 <REDDebugger.ab3@6317>   Dc.b "_flags",0,#_word,-1
0001F923 <REDDebugger.ab3@6318>   Dc.b "_nextoff",0,#_word,-1
0001F92E <REDDebugger.ab3@6319>   Dc.b "_xhandle",0,#_word,-1
0001F939 <REDDebugger.ab3@6320>   Dc.b "_yhandle",0,#_word,-1
0001F93A <REDDebugger.ab3@6321>   Dc.b 0
0001F93C <REDDebugger.ab3@6325>   Dc.w 32
0001F943 <REDDebugger.ab3@6326>   Dc.b "Window",0
0001F94D <REDDebugger.ab3@6327>   Dc.b "_window",0,#_long,-1
0001F956 <REDDebugger.ab3@6328>   Dc.b "_cursx",0,#_word,-1
0001F95F <REDDebugger.ab3@6329>   Dc.b "_cursy",0,#_word,-1
0001F96A <REDDebugger.ab3@6330>   Dc.b "_pointer",0,#_long,-1
0001F974 <REDDebugger.ab3@6331>   Dc.b "_length",0,#_long,-1
0001F975 <REDDebugger.ab3@6332>   Dc.b 0
0001F976 <REDDebugger.ab3@6334> Even
0001F978 <REDDebugger.ab3@6336>   Dc.w 16
0001F982 <REDDebugger.ab3@6337>   Dc.b "Intuifont",0
0001F98E <REDDebugger.ab3@6338>   Dc.b "_fontname",0,#_string,-1
0001F997 <REDDebugger.ab3@6339>   Dc.b "_ysize",0,#_word,-1
0001F99E <REDDebugger.ab3@6340>   Dc.b "_pad",0,#_word,-1
0001F9A6 <REDDebugger.ab3@6341>   Dc.b "_font",0,#_long,-1
0001F9B1 <REDDebugger.ab3@6342>   Dc.b "_pad2[4]",0,#_byte,4
0001F9B2 <REDDebugger.ab3@6343>   Dc.b 0
0001F9B4 <REDDebugger.ab3@6347>   Dc.w 128
0001F9BC <REDDebugger.ab3@6348>   Dc.b "Coplist",0
0001F9C3 <REDDebugger.ab3@6349>   Dc.b "size",0,#_long,-1
0001F9CC <REDDebugger.ab3@6350>   Dc.b "coppos",0,#_long,-1
0001F9D5 <REDDebugger.ab3@6351>   Dc.b "colors",0,#_long,-1
0001F9DF <REDDebugger.ab3@6352>   Dc.b "sprites",0,#_long,-1
0001F9E8 <REDDebugger.ab3@6353>   Dc.b "bpcons",0,#_long,-1
0001F9F2 <REDDebugger.ab3@6354>   Dc.b "bplanes",0,#_long,-1
0001F9F8 <REDDebugger.ab3@6355>   Dc.b "dot",0,#_long,-1
0001FA02 <REDDebugger.ab3@6356>   Dc.b "customs",0,#_long,-1
0001FA08 <REDDebugger.ab3@6357>   Dc.b "dob",0,#_long,-1
0001FA0E <REDDebugger.ab3@6358>   Dc.b "bot",0,#_word,-1
0001FA16 <REDDebugger.ab3@6359>   Dc.b "numbp",0,#_word,-1
0001FA21 <REDDebugger.ab3@6360>   Dc.b "colpokes",0,#_word,-1
0001FA2C <REDDebugger.ab3@6361>   Dc.b "fetchwid",0,#_word,-1
0001FA33 <REDDebugger.ab3@6362>   Dc.b "xand",0,#_word,-1
0001FA3C <REDDebugger.ab3@6363>   Dc.b "xshift",0,#_word,-1
0001FA43 <REDDebugger.ab3@6364>   Dc.b "ypos",0,#_word,-1
0001FA4C <REDDebugger.ab3@6365>   Dc.b "height",0,#_word,-1
0001FA52 <REDDebugger.ab3@6366>   Dc.b "res",0,#_word,-1
0001FA5F <REDDebugger.ab3@6367>   Dc.b "numsprites",0,#_word,-1
0001FA69 <REDDebugger.ab3@6368>   Dc.b "numcols",0,#_word,-1
0001FA76 <REDDebugger.ab3@6369>   Dc.b "numcustoms",0,#_word,-1
0001FA7F <REDDebugger.ab3@6370>   Dc.b "cpline",0,#_word,-1
0001FA84 <REDDebugger.ab3@6371>   Dc.b "x0",0,#_quick,-1
0001FA89 <REDDebugger.ab3@6372>   Dc.b "x1",0,#_quick,-1
0001FA93 <REDDebugger.ab3@6373>   Dc.b "bplcon3",0,#_word,-1
0001FA99 <REDDebugger.ab3@6374>   Dc.b "aga",0,#_word,-1
0001FA9A <REDDebugger.ab3@6375>   Dc.b 0
0001FA9C <REDDebugger.ab3@6378>   Dc.w 16
0001FAA3 <REDDebugger.ab3@6379>   Dc.b "GTList",0
0001FAAC <REDDebugger.ab3@6380>   Dc.b "gadptr",0,#_long,-1
0001FAB9 <REDDebugger.ab3@6381>   Dc.b "visualinfo",0,#_long,-1
0001FAC3 <REDDebugger.ab3@6382>   Dc.b "current",0,#_long,-1
0001FACF <REDDebugger.ab3@6383>   Dc.b "windowptr",0,#_long,-1
0001FAD0 <REDDebugger.ab3@6384>   Dc.b 0
0001FAD2 <REDDebugger.ab3@6387>   Dc.w 32
0001FADC <REDDebugger.ab3@6388>   Dc.b "MapObject",0
0001FAE4 <REDDebugger.ab3@6389>   Dc.b "width"    ,0,#_word,-1
0001FAED <REDDebugger.ab3@6390>   Dc.b "height"   ,0,#_word,-1
0001FAF6 <REDDebugger.ab3@6391>   Dc.b "bwidth"   ,0,#_word,-1
0001FB00 <REDDebugger.ab3@6392>   Dc.b "bheight"  ,0,#_word,-1
0001FB0B <REDDebugger.ab3@6393>   Dc.b "datasize" ,0,#_byte,-1
0001FB15 <REDDebugger.ab3@6394>   Dc.b "mapnull"  ,0,#_byte,-1
0001FB20 <REDDebugger.ab3@6395>   Dc.b "*mapdata" ,0,#_long,-1
0001FB28 <REDDebugger.ab3@6396>   Dc.b "viewx"    ,0,#_word,-1
0001FB30 <REDDebugger.ab3@6397>   Dc.b "viewy"    ,0,#_word,-1
0001FB3B <REDDebugger.ab3@6398>   Dc.b "*mapname" ,0,#_string,-1
0001FB3C <REDDebugger.ab3@6399>   Dc.b 0
0001FB3E <REDDebugger.ab3@6402>   Dc.w 16
0001FB49 <REDDebugger.ab3@6403>   Dc.b "GTMenuList",0
0001FB55 <REDDebugger.ab3@6404>   Dc.b "*Menulist",0,#_long,-1
0001FB64 <REDDebugger.ab3@6405>   Dc.b "*Privatelist",0,#_long,-1
0001FB6F <REDDebugger.ab3@6406>   Dc.b "numitems",0,#_word,-1
0001FB70 <REDDebugger.ab3@6407>   Dc.b 0
0001FB71 <REDDebugger.ab3@6419>   Dc.b 0 ; will be set at program start
0001FB72 <REDDebugger.ab3@6420>   Dc.b 0 ; will be set at program start
0001FB74 <REDDebugger.ab3@6421>   Dc.w #SCR_WB                                             ; actual screen type
0001FB78 <REDDebugger.ab3@6422>   Dc.l $8000                                               ; Screen mode ID
0001FB7A <REDDebugger.ab3@6423>   Dc.w 640                                                 ; Screen width
0001FB7C <REDDebugger.ab3@6424>   Dc.w 256                                                 ; Screen height
0001FB7D <REDDebugger.ab3@6425>   Dc.b 0                                                   ; Tokenise
0001FB7E <REDDebugger.ab3@6426>   Dc.b 0                                                   ; public screen
0001FB80 <REDDebugger.ab3@6427>   Dc.w 2048                                                ; max window height
0001FB82 <REDDebugger.ab3@6428>   Dc.w #save_numwindows                                    ; number of window definitions
0001FB8C <REDDebugger.ab3@6429>   Dc.w -1,0,124,432,256-124                                ; Source window pos,size
0001FB96 <REDDebugger.ab3@6430>   Dc.w -1,0,11,640,26                                      ; Control window pos,size
0001FBA0 <REDDebugger.ab3@6431>   Dc.w 0,0,37,640,87                                       ; Registers
0001FBAA <REDDebugger.ab3@6432>   Dc.w 0,0,0,0,0                                           ; Backdrop
0001FBB4 <REDDebugger.ab3@6433>   Dc.w 0,432,124,208,256-124                               ; Mem1
0001FBBE <REDDebugger.ab3@6434>   Dc.w 0,432,124,208,256-124                               ; Mem2
0001FBC8 <REDDebugger.ab3@6435>   Dc.w 0,0,11,420,100                                      ; Search window
0001FBD2 <REDDebugger.ab3@6436>   Dc.w 0,0,11,320,128                                      ; Variable window
0001FBDC <REDDebugger.ab3@6437>   Dc.w 0,0,11,320,128                                      ; 680x0 Disassembly window
0001FBE6 <REDDebugger.ab3@6438>   Dc.w 0,0,11,320,128                                      ; Copper Disassembly window
0001FBF0 <REDDebugger.ab3@6439>   Dc.w 0,0,11,320,128                                      ; Custom chip registers
0001FBFA <REDDebugger.ab3@6440>   Dc.w 0,0,11,320,128                                      ; Array window
0001FC04 <REDDebugger.ab3@6441>   Dc.w 0,0,11,160,200                                      ; Label List window
0001FC05 <REDDebugger.ab3@6442>   Dc.b 0                                                   ; Status of ProcedureStep
0001FC06 <REDDebugger.ab3@6443>   Dc.b 0                                                   ; Status of Blitzcontrol
0001FC07 <REDDebugger.ab3@6444>   Dc.b 0                                                   ; Status of GosubStep
0001FC08 <REDDebugger.ab3@6445>   Dc.b 0                                                   ; default Public screen mode
0001FC09 <REDDebugger.ab3@6446>   Dc.b 0                                                   ; show syntax mode
0001FC28 <REDDebugger.ab3@6447>   Dcb.b 31,0
0001FCA8 <REDDebugger.ab3@6449> disasmlockstr: Dc.b "pc-2",0 : Ds.b 128-5
0001FCB2 <REDDebugger.ab3@6450>   Dc.w 0,0,11,420,100                                      ; FPU Reg Window
0001FCB4 <REDDebugger.ab3@6455> sizeofsave:         Dc.w endof_init-initstate
0001FCBA <REDDebugger.ab3@6457> help_menus:         Dc.b "MENUS",0
0001FCC0 <REDDebugger.ab3@6458> help_about:         Dc.b "ABOUT",0
0001FCCE <REDDebugger.ab3@6459> help_cntrlwin:      Dc.b "WIN_PROGCNTRL",0
0001FCD9 <REDDebugger.ab3@6460> help_source:        Dc.b "WIN_SOURCE",0
0001FCEB <REDDebugger.ab3@6461> help_configuration: Dc.b "NODEconfiguration",0
0001FCF7 <REDDebugger.ab3@6462> help_screenmode:    Dc.b "NODEscrmode",0
0001FD00 <REDDebugger.ab3@6463> help_reg:           Dc.b "WIN_REGS",0
0001FD08 <REDDebugger.ab3@6464> help_mem:           Dc.b "WIN_MEM",0
0001FD11 <REDDebugger.ab3@6465> help_var:           Dc.b "WIN_VARS",0
0001FD1C <REDDebugger.ab3@6466> help_asm:           Dc.b "WIN_DISASM",0
0001FD27 <REDDebugger.ab3@6467> help_cop:           Dc.b "WIN_COPPER",0
0001FD35 <REDDebugger.ab3@6468> help_gs:            Dc.b "NODEgosubstep",0
0001FD45 <REDDebugger.ab3@6469> help_ps:            Dc.b "NODEproccontrol",0
0001FD56 <REDDebugger.ab3@6470> help_bc:            Dc.b "NODEblitzcontrol",0
0001FD61 <REDDebugger.ab3@6471> help_search:        Dc.b "WIN_SEARCH",0
0001FD6B <REDDebugger.ab3@6472> help_array:         Dc.b "WIN_ARRAY",0
0001FD7A <REDDebugger.ab3@6473> help_struct:        Dc.b "WIN_STRUCTURES",0
0001FD8A <REDDebugger.ab3@6474> help_chips:         Dc.b "WIN_CUSTOMCHIPS",0
0001FD98 <REDDebugger.ab3@6475> help_labels:        Dc.b "WIN_LABELLIST",0
0001FDA4 <REDDebugger.ab3@6476> help_objects:       Dc.b "WIN_OBJECTS",0
0001FDB1 <REDDebugger.ab3@6477> help_autoeval:      Dc.b "NODEautoeval",0
0001FDC1 <REDDebugger.ab3@6478> help_breakpoints:   Dc.b "NODEbreakpoints",0
0001FDC9 <REDDebugger.ab3@6479> help_fpu:           Dc.b "WIN_FPU",0
0001FDD5 <REDDebugger.ab3@6480> help_asmstep:       Dc.b "WIN_ASMSTEP",0
0001FDE0 <REDDebugger.ab3@6481> help_watch0:        Dc.b "WIN_WATCH0",0
00020468 <REDDebugger.ab3@6483> wzdat:              IncBin "reddebug.wizard"
0002046C <REDDebugger.ab3@6488>   fpu.l = PutD0
0002048C <REDDebugger.ab3@6489>   ffp   = SPFieee_(ffp) ; for mathtranspointer
00020490 <REDDebugger.ab3@6490>   GetD0 fpu
00020494 <REDDebugger.ab3@6491>   JSR -$6c(a6)
00020498 <REDDebugger.ab3@6492>   MOVE.l d0,ffp@(a5)
0002049A <REDDebugger.ab3@6493> Return
0002052E <REDDebugger.ab3@6497>   fp$(temp) = RTEZGetString("Insert FPU Value","Insert FPU Value",80,fp$(temp))
0002053A <REDDebugger.ab3@6499>   optimize 7 ; this requires an FPU
0002057C <REDDebugger.ab3@6500>    ffp = Val(fp$(temp))
00020588 <REDDebugger.ab3@6501>   optimize 5
000205A8 <REDDebugger.ab3@6503>   ffp2.f = SPTieee_(ffp2) ; for mathtranspointer
000205AC <REDDebugger.ab3@6504>   MOVE.l ffp@(a5),d0
000205B0 <REDDebugger.ab3@6505>   JSR -102(a6)
000205B4 <REDDebugger.ab3@6506>   fmove.s d0,fp0
000205BA <REDDebugger.ab3@6507>   MOVE.l regpos,a0
000205C0 <REDDebugger.ab3@6508>   ADD.l fpuoffset,a0
000205C4 <REDDebugger.ab3@6509>   GetD0 temp
000205C8 <REDDebugger.ab3@6510>   MULS #12,d0
000205CA <REDDebugger.ab3@6511>   ADD.w d0,a0
000205CE <REDDebugger.ab3@6512>   Dc.l $f2106800    ;fmove.x fp0,(a0)
000205D4 <REDDebugger.ab3@6513>   RedrawRegs{}
000205D6 <REDDebugger.ab3@6514> Return
000205DE <REDDebugger.ab3@6518>   inbrack.l = 0
00020606 <REDDebugger.ab3@6519>   poin$     = ""
0002061E <REDDebugger.ab3@6521>   temp = Peek.b(*ptr+xpos)
00020630 <REDDebugger.ab3@6522>   If temp = @"\"
000206C0 <REDDebugger.ab3@6545>     typepath$ = RTEZGetString(scrtitle$,"Insert a path for newtype begin with \",128,path$)
000206D2 <REDDebugger.ab3@6547>   If temp = @"*"
000206FA <REDDebugger.ab3@6548>     poin$ = "*"
0002070C <REDDebugger.ab3@6550>   If temp = @"#"
00020734 <REDDebugger.ab3@6551>     poin$ = "#"
0002074C <REDDebugger.ab3@6555>   temp = Peek.b(*ptr+xpos)
0002075A <REDDebugger.ab3@6557>   xpos-1
000207A6 <REDDebugger.ab3@6559> 
000207BE <REDDebugger.ab3@6560>   If temp = @"+" Then Goto _wout
000207D0 <REDDebugger.ab3@6561>   If temp = @"\"
000207EA <REDDebugger.ab3@6562>     If Peek.l(i) AND $80000000
00020806 <REDDebugger.ab3@6563>       i3.l = (Peek.l(i) AND $7fffffff)+startcode
0002080C <REDDebugger.ab3@6564>     Else
0002081A <REDDebugger.ab3@6565>       i3 = Peek.l(i)
0002082E <REDDebugger.ab3@6568>       il3.l = Peek.l(i3+4)          ; :
00020848 <REDDebugger.ab3@6569>       If Peek.l(il3) = i3
0002084E <REDDebugger.ab3@6570>         i3 = il3
00020854 <REDDebugger.ab3@6571>       Else
0002085C <REDDebugger.ab3@6572>         i3 = 0
00020866 <REDDebugger.ab3@6574>       If i3
00020894 <REDDebugger.ab3@6575>         p$ = Peek.s (i3+9)
000208EE <REDDebugger.ab3@6576>         If Instr(p$,Mki$ ($80ca))
0002091A <REDDebugger.ab3@6577>           InitArgParse p$
0002093C <REDDebugger.ab3@6578>           ret$ = NextArg$
00020974 <REDDebugger.ab3@6579>           If typepath$ = ""
000209D2 <REDDebugger.ab3@6580>             path$ = NextArgChar$(@" ","","")
000209D8 <REDDebugger.ab3@6581>           Else
00020A0C <REDDebugger.ab3@6582>             path$ = typepath$
00020A14 <REDDebugger.ab3@6584>           i3 = 0
00020A2C <REDDebugger.ab3@6587>     Until i3 = 0
00020A52 <REDDebugger.ab3@6589>   If temp = @"{" Then xpos+1 : Goto _wout
00020A7E <REDDebugger.ab3@6590>   If temp >= $30 AND temp <= $39 Then Goto _wloop ; 0-9
00020AA4 <REDDebugger.ab3@6591>   If temp < $40 Then xpos+1 : Goto _wout
00020ABC <REDDebugger.ab3@6592>   If xpos < 0 Then Goto _wout
00020AC2 <REDDebugger.ab3@6593>   Goto _wloop
00020AD6 <REDDebugger.ab3@6596>   xpos+1 : schar.l = xpos
00020AEE <REDDebugger.ab3@6597>   temp = Peek.b (*ptr+xpos)
00020B56 <REDDebugger.ab3@6598>   If temp = @"$" OR temp = @"-" Then xpos+1 : If Peek.b(*ptr+xpos) = @"$" Then xpos+1
00020B6E <REDDebugger.ab3@6601>   temp = Peek.b(*ptr+xpos)
00020B8E <REDDebugger.ab3@6602>   If temp = @"(" Then inbrack+1
00020BBA <REDDebugger.ab3@6603>   If temp = @")" AND inbrack = 0  Then Goto _wout2
00020BE6 <REDDebugger.ab3@6604>   If temp = @"-" AND inbrack <> 0 Then Goto _weit1
00020C12 <REDDebugger.ab3@6605>   If temp = @" " AND inbrack <> 0 Then Goto _weit1
00020C3E <REDDebugger.ab3@6606>   If temp = $22  AND inbrack <> 0 Then Goto _weit1
00020C5E <REDDebugger.ab3@6607>   If temp = @")" Then inbrack-1
00020C76 <REDDebugger.ab3@6608>   If temp = @"}" Then Goto _wout2
00020CA2 <REDDebugger.ab3@6609>   If inbrack <> 0 AND temp = @"," Then Goto _weit1
00020D0E <REDDebugger.ab3@6610>   If temp = @"." OR temp = @"(" OR temp = @")" OR temp = @"$" OR temp = @"*" OR temp = @"#" Then Goto _weit1
00020D3A <REDDebugger.ab3@6611>   If temp >= $30 AND temp <= $39 Then Goto _weit1
00020D52 <REDDebugger.ab3@6612>   If temp < $40 Then Goto _wout2
00020D60 <REDDebugger.ab3@6615>   xpos+1
00020D66 <REDDebugger.ab3@6616>   Goto _wloop2
00020D9C <REDDebugger.ab3@6619>   part$ = Peeks$(*ptr+schar,xpos-schar)
00020D9E <REDDebugger.ab3@6620> Return
00020DA4 <REDDebugger.ab3@6624>   TST.l regpos
00020DA8 <REDDebugger.ab3@6625>   BEQ 'skip  ;<= this prevents an enforcer hit!
00020DAE <REDDebugger.ab3@6627>   MOVE.l regpos,a0
00020DB4 <REDDebugger.ab3@6628>   ADD.l fpuoffset,a0
00020DB6 <REDDebugger.ab3@6629>   MOVEQ #7,d0
00020DBC <REDDebugger.ab3@6630>   LEA fpustore,a1
00020DBE <REDDebugger.ab3@6633>     MOVE.l (a0)+,(a1)+
00020DC0 <REDDebugger.ab3@6634>     MOVE.l (a0)+,(a1)+
00020DC2 <REDDebugger.ab3@6635>     MOVE.l (a0)+,(a1)+
00020DC6 <REDDebugger.ab3@6636>   DBF d0,'l1
00020DC8 <REDDebugger.ab3@6639> RTS
00020DCE <REDDebugger.ab3@6643>   TST.l regpos
00020DD2 <REDDebugger.ab3@6644>   BEQ 'skip  ; <= this prevents an enforcer hit!
00020DD8 <REDDebugger.ab3@6646>   MOVE.l regpos,a0
00020DDE <REDDebugger.ab3@6647>   ADD.l fpuoffset,a0
00020DE0 <REDDebugger.ab3@6648>   MOVEQ #7,d0
00020DE6 <REDDebugger.ab3@6649>   LEA fpustore,a1
00020DE8 <REDDebugger.ab3@6652>     MOVE.l (a1)+,(a0)+
00020DEA <REDDebugger.ab3@6653>     MOVE.l (a1)+,(a0)+
00020DEC <REDDebugger.ab3@6654>     MOVE.l (a1)+,(a0)+
00020DF0 <REDDebugger.ab3@6655>   DBF d0,'l1
00020DF2 <REDDebugger.ab3@6658> RTS
00020DF6 <REDDebugger.ab3@6663>   MOVEM.l a0/d1,-(a7)
00020DFC <REDDebugger.ab3@6664>   LEA history,a0
00020DFE <REDDebugger.ab3@6665>   MOVEQ #0,d1
00020E04 <REDDebugger.ab3@6666>   MOVE.w historypointer,d1
00020E08 <REDDebugger.ab3@6667>   GetD0 disasm_ad
00020E0C <REDDebugger.ab3@6668>   MOVE.l d0,0(a0,d1)
00020E0E <REDDebugger.ab3@6669>   ADDQ.w #4,d1
00020E12 <REDDebugger.ab3@6670>   CMP.w  #maxhistory*4,d1
00020E16 <REDDebugger.ab3@6671>   BLE 'nowrap
00020E18 <REDDebugger.ab3@6672>   MOVEQ #0,d1
00020E1E <REDDebugger.ab3@6675>   MOVE.w d1,historypointer
00020E22 <REDDebugger.ab3@6676>   MOVEM.l (a7)+,a0/d1
00020E24 <REDDebugger.ab3@6677> RTS
00020E28 <REDDebugger.ab3@6681>   MOVEM.l a0/d1,-(a7)
00020E2E <REDDebugger.ab3@6682>   LEA memhistory,a0
00020E3E <REDDebugger.ab3@6683>   GetD0 mempointer(1)
00020E40 <REDDebugger.ab3@6684>   MOVEQ #0,d1
00020E46 <REDDebugger.ab3@6685>   MOVE.w memhistorypointer,d1
00020E4A <REDDebugger.ab3@6686>   MOVE.l d0,0(a0,d1)
00020E4C <REDDebugger.ab3@6687>   ADDQ.w #4,d1
00020E50 <REDDebugger.ab3@6688>   CMP.w  #maxhistory*4,d1
00020E54 <REDDebugger.ab3@6689>   BLE 'nowrap
00020E56 <REDDebugger.ab3@6690>   MOVEQ #0,d1
00020E5C <REDDebugger.ab3@6693>   MOVE.w d1,memhistorypointer
00020E60 <REDDebugger.ab3@6694>   MOVEM.l (a7)+,a0/d1
00020E62 <REDDebugger.ab3@6695> RTS
00020E64 <REDDebugger.ab3@6700>   MOVE.l a1,-(a7)
00020E6A <REDDebugger.ab3@6701>   LEA memhistory,a0
00020E70 <REDDebugger.ab3@6702>   MOVE.w memhistorypointer,d1
00020E72 <REDDebugger.ab3@6703>   SUBQ #4,d1
00020E76 <REDDebugger.ab3@6704>   BPL 'l10
00020E78 <REDDebugger.ab3@6705>   MOVEQ #maxhistory*4,d1
00020E7E <REDDebugger.ab3@6708>   MOVE.w d1,memhistorypointer
00020E82 <REDDebugger.ab3@6709>   MOVE.l 0(a0,d1.w),d0
00020E9E <REDDebugger.ab3@6710>   PutReg d0,mempointer(1)
00020EA4 <REDDebugger.ab3@6711>   RedrawMem{}
00020EA6 <REDDebugger.ab3@6712>   MOVE.l (a7)+,a1
00020EA8 <REDDebugger.ab3@6713> RTS
00020EAA <REDDebugger.ab3@6718>   MOVE.l a1,-(a7)
00020EB0 <REDDebugger.ab3@6719>   LEA memhistory,a0
00020EB6 <REDDebugger.ab3@6720>   MOVE.w memhistorypointer,d1
00020EB8 <REDDebugger.ab3@6721>   ADDQ #4,d1
00020EBC <REDDebugger.ab3@6722>   CMP.w #maxhistory*4,d1
00020EC0 <REDDebugger.ab3@6723>   BLE 'l10
00020EC2 <REDDebugger.ab3@6724>   MOVEQ #0,d1
00020EC8 <REDDebugger.ab3@6727>   MOVE.w d1,memhistorypointer
00020ECC <REDDebugger.ab3@6728>   MOVE.l 0(a0,d1.w),d0
00020EE8 <REDDebugger.ab3@6729>   PutReg d0,mempointer(1)
00020EEE <REDDebugger.ab3@6731>   RedrawMem{}
00020EF0 <REDDebugger.ab3@6732>   MOVE.l (a7)+,a1
00020EF2 <REDDebugger.ab3@6733> RTS
00020EF4 <REDDebugger.ab3@6738>   MOVE.l a1,-(a7)
00020EFA <REDDebugger.ab3@6739>   LEA history,a0
00020F00 <REDDebugger.ab3@6740>   MOVE.w historypointer,d1
00020F02 <REDDebugger.ab3@6741>   SUBQ #4,d1
00020F06 <REDDebugger.ab3@6742>   BPL 'l10
00020F08 <REDDebugger.ab3@6743>   MOVEQ #maxhistory*4,d1
00020F0E <REDDebugger.ab3@6746>   MOVE.w d1,historypointer
00020F12 <REDDebugger.ab3@6747>   MOVE.l 0(a0,d1.w),d0
00020F16 <REDDebugger.ab3@6748>   disasm_ad = PutD0
00020F24 <REDDebugger.ab3@6749>   UpdateDisAsm{}
00020F26 <REDDebugger.ab3@6750>   MOVE.l (a7)+,a1
00020F28 <REDDebugger.ab3@6751> RTS
00020F2A <REDDebugger.ab3@6756>   MOVE.l a1,-(a7)
00020F30 <REDDebugger.ab3@6757>   LEA history,a0
00020F36 <REDDebugger.ab3@6758>   MOVE.w historypointer,d1
00020F38 <REDDebugger.ab3@6759>   ADDQ #4,d1
00020F3C <REDDebugger.ab3@6760>   CMP.w #maxhistory*4,d1
00020F40 <REDDebugger.ab3@6761>   BLE 'l10
00020F42 <REDDebugger.ab3@6762>   MOVEQ #0,d1
00020F48 <REDDebugger.ab3@6765>   MOVE.w d1,historypointer
00020F4C <REDDebugger.ab3@6766>   MOVE.l 0(a0,d1.w),d0
00020F50 <REDDebugger.ab3@6767>   disasm_ad=PutD0
00020F5E <REDDebugger.ab3@6768>   UpdateDisAsm{}
00020F60 <REDDebugger.ab3@6769>   MOVE.l (a7)+,a1
00020F62 <REDDebugger.ab3@6770> RTS
00020FF2 <REDDebugger.ab3@6774>   na$ = RTEZGetString(varfollow$,"Enter variable name:",80,part$)
0002102A <REDDebugger.ab3@6775>   If na$ <> ""
0002107C <REDDebugger.ab3@6776>     a$ = Left$(na$,1)
000210B4 <REDDebugger.ab3@6777>     If a$ = "%"
000210BA <REDDebugger.ab3@6778>       nf = 3
000210C0 <REDDebugger.ab3@6779>     Else
000210F8 <REDDebugger.ab3@6780>       If a$ = "$"
000210FE <REDDebugger.ab3@6781>         nf = 2
00021104 <REDDebugger.ab3@6782>       Else
0002110A <REDDebugger.ab3@6783>         nf = 1
0002116C <REDDebugger.ab3@6786>     If nf <> 1 Then na$ = Mid$(na$,2)
00021176 <REDDebugger.ab3@6787>     nt = -1
000211D8 <REDDebugger.ab3@6788>     If Right$(na$,1) = "$" Then nt = 4
000212B8 <REDDebugger.ab3@6789>     If Len(na$) > 2 AND Mid$(na$,Len(na$)-1,1) = "."
00021350 <REDDebugger.ab3@6790>       nt  = Instr(objtype$,LCase$(Right$(na$,1)))  ; try to get type of the variable
000213DA <REDDebugger.ab3@6791>       na$ = Left$(na$,Len(na$)-2)
00021454 <REDDebugger.ab3@6793>     If nt = -1 Then nt = RTEZRequest(varfollow$,"Enter variable type:","_b|_w|_l|_s|_q|_f|_Cancel")
0002145A <REDDebugger.ab3@6794>   Else
00021464 <REDDebugger.ab3@6795>     nt = -1
00021466 <REDDebugger.ab3@6797> Return
0002146A <REDDebugger.ab3@6801> memhistorypointer:  Dc.l 0
0002146E <REDDebugger.ab3@6802> historypointer:     Dc.l 0
00021472 <REDDebugger.ab3@6803> regpos:             Dc.l 0
00021476 <REDDebugger.ab3@6804> fpreg:              Dc.l 0
0002147A <REDDebugger.ab3@6805> fpuoffset:          Dc.l 0
0002147E <REDDebugger.ab3@6806> currlinestart:      Dc.l 0
00021489 <REDDebugger.ab3@6807> topazname           Dc.b "topaz.font",0
0002148A <REDDebugger.ab3@6808> Even
0002148C <REDDebugger.ab3@6809> BSS
000214BC <REDDebugger.ab3@6810> history:            Ds.l #maxhistory+2
000214EC <REDDebugger.ab3@6811> memhistory:         Ds.l #maxhistory+2
00021558 <REDDebugger.ab3@6812> fpustore:           Ds.l 3*9
0002155C <REDDebugger.ab3@6813> programstart:       Ds.l 1
00021560 <REDDebugger.ab3@6814> programsize:        Ds.l 1
00021562 <REDDebugger.ab3@6815> newdebug:           Dc.w 1
00021566 <REDDebugger.ab3@6816> trap15addr:         Ds.l 1
00022566 <REDDebugger.ab3@6817> direktbuffer:       Ds.b 4096
